(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('ngx-color'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('ngx-color/compact', ['exports', '@angular/core', 'ngx-color', '@angular/common'], factory) :
    (factory((global['ngx-color'] = global['ngx-color'] || {}, global['ngx-color'].compact = {}),global.ng.core,global['ngx-color'],global.ng.common));
}(this, (function (exports,core,ngxColor,common) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var CompactColorComponent = /** @class */ (function () {
        function CompactColorComponent() {
            this.onClick = new core.EventEmitter();
            this.onSwatchHover = new core.EventEmitter();
            this.swatchStyle = {
                width: '15px',
                height: '15px',
                float: 'left',
                marginRight: '5px',
                marginBottom: '5px',
                position: 'relative',
                cursor: 'pointer',
            };
            this.swatchFocus = {};
            this.getContrastingColor = ngxColor.getContrastingColor;
        }
        /**
         * @return {?}
         */
        CompactColorComponent.prototype.ngOnChanges = /**
         * @return {?}
         */
            function () {
                this.swatchStyle.background = this.color;
                this.swatchFocus.boxShadow = "0 0 4px " + this.color;
                if (this.color.toLowerCase() === '#ffffff') {
                    this.swatchStyle.boxShadow = 'inset 0 0 0 1px #ddd';
                }
            };
        /**
         * @param {?} __0
         * @return {?}
         */
        CompactColorComponent.prototype.handleClick = /**
         * @param {?} __0
         * @return {?}
         */
            function (_a) {
                var hex = _a.hex, $event = _a.$event;
                this.onClick.emit({ hex: hex, $event: $event });
            };
        CompactColorComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'color-compact-color',
                        template: "\n  <div class=\"compact-color\">\n    <color-swatch class=\"swatch\"\n      [color]=\"color\" [style]=\"swatchStyle\"\n      [focusStyle]=\"swatchFocus\"\n      (onClick)=\"handleClick($event)\" (onHover)=\"onSwatchHover.emit($event)\"\n      >\n      <div class=\"compact-dot\"\n        [class.active]=\"active\" [style.background]=\"getContrastingColor(color)\"\n      ></div>\n    </color-swatch>\n  </div>\n  ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        preserveWhitespaces: false,
                        styles: ["\n  .compact-dot {\n    position: absolute;\n    top: 5px;\n    right: 5px;\n    bottom: 5px;\n    left: 5px;\n    border-radius: 50%;\n    opacity: 0;\n  }\n  .compact-dot.active {\n    opacity: 1;\n  }\n  "]
                    }] }
        ];
        CompactColorComponent.propDecorators = {
            color: [{ type: core.Input }],
            active: [{ type: core.Input }],
            onClick: [{ type: core.Output }],
            onSwatchHover: [{ type: core.Output }]
        };
        return CompactColorComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var CompactFieldsComponent = /** @class */ (function () {
        function CompactFieldsComponent() {
            this.onChange = new core.EventEmitter();
            this.HEXWrap = {
                marginTop: '-3px',
                marginBottom: '-3px',
                // flex: '6 1 0%',
                position: 'relative',
            };
            this.HEXinput = {
                width: '80%',
                padding: '0px',
                paddingLeft: '20%',
                border: 'none',
                outline: 'none',
                background: 'none',
                fontSize: '12px',
                color: '#333',
                height: '16px',
            };
            this.HEXlabel = {
                display: 'none',
            };
            this.RGBwrap = {
                marginTop: '-3px',
                marginBottom: '-3px',
                // flex: '3 1 0%',
                position: 'relative',
            };
            this.RGBinput = {
                width: '80%',
                padding: '0px',
                paddingLeft: '30%',
                border: 'none',
                outline: 'none',
                background: 'none',
                fontSize: '12px',
                color: '#333',
                height: '16px',
            };
            this.RGBlabel = {
                position: 'absolute',
                top: '6px',
                left: '0px',
                'line-height': '16px',
                'text-transform': 'uppercase',
                fontSize: '12px',
                color: '#999',
            };
        }
        /**
         * @param {?} __0
         * @return {?}
         */
        CompactFieldsComponent.prototype.handleChange = /**
         * @param {?} __0
         * @return {?}
         */
            function (_a) {
                var data = _a.data, $event = _a.$event;
                if (data.hex) {
                    if (ngxColor.isValidHex(data.hex)) {
                        this.onChange.emit({
                            data: {
                                hex: data.hex,
                                source: 'hex',
                            },
                            $event: $event,
                        });
                    }
                }
                else {
                    this.onChange.emit({
                        data: {
                            r: data.r || this.rgb.r,
                            g: data.g || this.rgb.g,
                            b: data.b || this.rgb.b,
                            source: 'rgb',
                        },
                        $event: $event,
                    });
                }
            };
        CompactFieldsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'color-compact-fields',
                        template: "\n  <div class=\"compact-fields\">\n    <div class=\"compact-active\" [style.background]=\"hex\"></div>\n    <color-editable-input\n      style=\"flex: 6 1 0%;\"\n      [style]=\"{ wrap: HEXWrap, input: HEXinput, label: HEXlabel }\"\n      label=\"hex\"\n      [value]=\"hex\"\n      (onChange)=\"handleChange($event)\"\n    ></color-editable-input>\n    <color-editable-input\n      style=\"flex: 3 1 0%\"\n      [style]=\"{ wrap: RGBwrap, input: RGBinput, label: RGBlabel }\"\n      label=\"r\"\n      [value]=\"rgb.r\"\n      (onChange)=\"handleChange($event)\"\n    ></color-editable-input>\n    <color-editable-input\n      style=\"flex: 3 1 0%\"\n      [style]=\"{ wrap: RGBwrap, input: RGBinput, label: RGBlabel }\"\n      label=\"g\"\n      [value]=\"rgb.g\"\n      (onChange)=\"handleChange($event)\"\n    ></color-editable-input>\n    <color-editable-input\n      style=\"flex: 3 1 0%\"\n      [style]=\"{ wrap: RGBwrap, input: RGBinput, label: RGBlabel }\"\n      label=\"b\"\n      [value]=\"rgb.b\"\n      (onChange)=\"handleChange($event)\"\n    ></color-editable-input>\n  </div>\n  ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        preserveWhitespaces: false,
                        styles: ["\n  .compact-fields {\n    display: flex;\n    padding-bottom: 6px;\n    padding-right: 5px;\n    position: relative;\n  }\n  .compact-active {\n    position: absolute;\n    top: 6px;\n    left: 5px;\n    height: 9px;\n    width: 9px;\n  }\n  "]
                    }] }
        ];
        CompactFieldsComponent.propDecorators = {
            hex: [{ type: core.Input }],
            rgb: [{ type: core.Input }],
            onChange: [{ type: core.Output }]
        };
        return CompactFieldsComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var CompactComponent = /** @class */ (function (_super) {
        __extends(CompactComponent, _super);
        function CompactComponent() {
            var _this = _super.call(this) || this;
            /**
             * Color squares to display
             */
            _this.colors = [
                '#4D4D4D',
                '#999999',
                '#FFFFFF',
                '#F44E3B',
                '#FE9200',
                '#FCDC00',
                '#DBDF00',
                '#A4DD00',
                '#68CCCA',
                '#73D8FF',
                '#AEA1FF',
                '#FDA1FF',
                '#333333',
                '#808080',
                '#cccccc',
                '#D33115',
                '#E27300',
                '#FCC400',
                '#B0BC00',
                '#68BC00',
                '#16A5A5',
                '#009CE0',
                '#7B64FF',
                '#FA28FF',
                '#000000',
                '#666666',
                '#B3B3B3',
                '#9F0500',
                '#C45100',
                '#FB9E00',
                '#808900',
                '#194D33',
                '#0C797D',
                '#0062B1',
                '#653294',
                '#AB149E',
            ];
            return _this;
        }
        /**
         * @param {?} __0
         * @return {?}
         */
        CompactComponent.prototype.handleBlockChange = /**
         * @param {?} __0
         * @return {?}
         */
            function (_a) {
                var hex = _a.hex, $event = _a.$event;
                if (ngxColor.isValidHex(hex)) {
                    this.handleChange({ hex: hex, source: 'hex' }, $event);
                }
            };
        /**
         * @param {?} __0
         * @return {?}
         */
        CompactComponent.prototype.handleValueChange = /**
         * @param {?} __0
         * @return {?}
         */
            function (_a) {
                var data = _a.data, $event = _a.$event;
                this.handleChange(data, $event);
            };
        CompactComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'color-compact',
                        template: "\n  <color-raised class=\"color-compact\">\n    <div class=\"compact-picker {{ className }}\">\n      <div>\n        <color-compact-color\n          *ngFor=\"let color of colors\" [color]=\"color\"\n          [active]=\"color.toLowerCase() === hex.toLowerCase()\"\n          (onClick)=\"handleBlockChange($event)\"\n        ></color-compact-color>\n        <div class=\"compact-clear\"></div>\n      </div>\n      <color-compact-fields\n        [hex]=\"hex\"\n        [rgb]=\"rgb\"\n        (onChange)=\"handleValueChange($event)\"\n      ></color-compact-fields>\n    </div>\n  </color-raised>\n  ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        preserveWhitespaces: false,
                        styles: ["\n    .color-compact {\n      background: #f6f6f6;\n      radius: 4px;\n    }\n    .compact-picker {\n      padding-top: 5px;\n      padding-left: 5px;\n      box-sizing: border-box;\n      width: 245px;\n    }\n    .compact-clear {\n      clear: both;\n    }\n  "]
                    }] }
        ];
        /** @nocollapse */
        CompactComponent.ctorParameters = function () { return []; };
        CompactComponent.propDecorators = {
            colors: [{ type: core.Input }]
        };
        return CompactComponent;
    }(ngxColor.ColorWrap));
    var ColorCompactModule = /** @class */ (function () {
        function ColorCompactModule() {
        }
        ColorCompactModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            CompactComponent,
                            CompactColorComponent,
                            CompactFieldsComponent,
                        ],
                        exports: [CompactComponent, CompactColorComponent, CompactFieldsComponent],
                        imports: [common.CommonModule, ngxColor.EditableInputModule, ngxColor.SwatchModule, ngxColor.RaisedModule],
                    },] }
        ];
        return ColorCompactModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    exports.CompactComponent = CompactComponent;
    exports.ColorCompactModule = ColorCompactModule;
    exports.ɵa = CompactColorComponent;
    exports.ɵb = CompactFieldsComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWNvbG9yLWNvbXBhY3QudW1kLmpzLm1hcCIsInNvdXJjZXMiOlsibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIm5nOi8vbmd4LWNvbG9yL2NvbXBhY3QvY29tcGFjdC1jb2xvci5jb21wb25lbnQudHMiLCJuZzovL25neC1jb2xvci9jb21wYWN0L2NvbXBhY3QtZmllbGRzLmNvbXBvbmVudC50cyIsIm5nOi8vbmd4LWNvbG9yL2NvbXBhY3QvY29tcGFjdC5jb21wb25lbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG4iLCJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIE91dHB1dCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IGdldENvbnRyYXN0aW5nQ29sb3IgfSBmcm9tICduZ3gtY29sb3InO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjb2xvci1jb21wYWN0LWNvbG9yJyxcbiAgdGVtcGxhdGU6IGBcbiAgPGRpdiBjbGFzcz1cImNvbXBhY3QtY29sb3JcIj5cbiAgICA8Y29sb3Itc3dhdGNoIGNsYXNzPVwic3dhdGNoXCJcbiAgICAgIFtjb2xvcl09XCJjb2xvclwiIFtzdHlsZV09XCJzd2F0Y2hTdHlsZVwiXG4gICAgICBbZm9jdXNTdHlsZV09XCJzd2F0Y2hGb2N1c1wiXG4gICAgICAob25DbGljayk9XCJoYW5kbGVDbGljaygkZXZlbnQpXCIgKG9uSG92ZXIpPVwib25Td2F0Y2hIb3Zlci5lbWl0KCRldmVudClcIlxuICAgICAgPlxuICAgICAgPGRpdiBjbGFzcz1cImNvbXBhY3QtZG90XCJcbiAgICAgICAgW2NsYXNzLmFjdGl2ZV09XCJhY3RpdmVcIiBbc3R5bGUuYmFja2dyb3VuZF09XCJnZXRDb250cmFzdGluZ0NvbG9yKGNvbG9yKVwiXG4gICAgICA+PC9kaXY+XG4gICAgPC9jb2xvci1zd2F0Y2g+XG4gIDwvZGl2PlxuICBgLFxuICBzdHlsZXM6IFtcbiAgICBgXG4gIC5jb21wYWN0LWRvdCB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogNXB4O1xuICAgIHJpZ2h0OiA1cHg7XG4gICAgYm90dG9tOiA1cHg7XG4gICAgbGVmdDogNXB4O1xuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICBvcGFjaXR5OiAwO1xuICB9XG4gIC5jb21wYWN0LWRvdC5hY3RpdmUge1xuICAgIG9wYWNpdHk6IDE7XG4gIH1cbiAgYCxcbiAgXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxufSlcbmV4cG9ydCBjbGFzcyBDb21wYWN0Q29sb3JDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICBASW5wdXQoKSBjb2xvcjogc3RyaW5nO1xuICBASW5wdXQoKSBhY3RpdmU6IGJvb2xlYW47XG4gIEBPdXRwdXQoKSBvbkNsaWNrID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG4gIEBPdXRwdXQoKSBvblN3YXRjaEhvdmVyID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG4gIHN3YXRjaFN0eWxlOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge1xuICAgIHdpZHRoOiAnMTVweCcsXG4gICAgaGVpZ2h0OiAnMTVweCcsXG4gICAgZmxvYXQ6ICdsZWZ0JyxcbiAgICBtYXJnaW5SaWdodDogJzVweCcsXG4gICAgbWFyZ2luQm90dG9tOiAnNXB4JyxcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgfTtcbiAgc3dhdGNoRm9jdXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcbiAgZ2V0Q29udHJhc3RpbmdDb2xvciA9IGdldENvbnRyYXN0aW5nQ29sb3I7XG5cbiAgbmdPbkNoYW5nZXMoKSB7XG4gICAgdGhpcy5zd2F0Y2hTdHlsZS5iYWNrZ3JvdW5kID0gdGhpcy5jb2xvcjtcbiAgICB0aGlzLnN3YXRjaEZvY3VzLmJveFNoYWRvdyA9IGAwIDAgNHB4ICR7dGhpcy5jb2xvcn1gO1xuICAgIGlmICh0aGlzLmNvbG9yLnRvTG93ZXJDYXNlKCkgPT09ICcjZmZmZmZmJykge1xuICAgICAgdGhpcy5zd2F0Y2hTdHlsZS5ib3hTaGFkb3cgPSAnaW5zZXQgMCAwIDAgMXB4ICNkZGQnO1xuICAgIH1cbiAgfVxuICBoYW5kbGVDbGljayh7IGhleCwgJGV2ZW50IH0pIHtcbiAgICB0aGlzLm9uQ2xpY2suZW1pdCh7IGhleCwgJGV2ZW50IH0pO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPdXRwdXQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBpc1ZhbGlkSGV4LCBSR0JBIH0gZnJvbSAnbmd4LWNvbG9yJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY29sb3ItY29tcGFjdC1maWVsZHMnLFxuICB0ZW1wbGF0ZTogYFxuICA8ZGl2IGNsYXNzPVwiY29tcGFjdC1maWVsZHNcIj5cbiAgICA8ZGl2IGNsYXNzPVwiY29tcGFjdC1hY3RpdmVcIiBbc3R5bGUuYmFja2dyb3VuZF09XCJoZXhcIj48L2Rpdj5cbiAgICA8Y29sb3ItZWRpdGFibGUtaW5wdXRcbiAgICAgIHN0eWxlPVwiZmxleDogNiAxIDAlO1wiXG4gICAgICBbc3R5bGVdPVwieyB3cmFwOiBIRVhXcmFwLCBpbnB1dDogSEVYaW5wdXQsIGxhYmVsOiBIRVhsYWJlbCB9XCJcbiAgICAgIGxhYmVsPVwiaGV4XCJcbiAgICAgIFt2YWx1ZV09XCJoZXhcIlxuICAgICAgKG9uQ2hhbmdlKT1cImhhbmRsZUNoYW5nZSgkZXZlbnQpXCJcbiAgICA+PC9jb2xvci1lZGl0YWJsZS1pbnB1dD5cbiAgICA8Y29sb3ItZWRpdGFibGUtaW5wdXRcbiAgICAgIHN0eWxlPVwiZmxleDogMyAxIDAlXCJcbiAgICAgIFtzdHlsZV09XCJ7IHdyYXA6IFJHQndyYXAsIGlucHV0OiBSR0JpbnB1dCwgbGFiZWw6IFJHQmxhYmVsIH1cIlxuICAgICAgbGFiZWw9XCJyXCJcbiAgICAgIFt2YWx1ZV09XCJyZ2IuclwiXG4gICAgICAob25DaGFuZ2UpPVwiaGFuZGxlQ2hhbmdlKCRldmVudClcIlxuICAgID48L2NvbG9yLWVkaXRhYmxlLWlucHV0PlxuICAgIDxjb2xvci1lZGl0YWJsZS1pbnB1dFxuICAgICAgc3R5bGU9XCJmbGV4OiAzIDEgMCVcIlxuICAgICAgW3N0eWxlXT1cInsgd3JhcDogUkdCd3JhcCwgaW5wdXQ6IFJHQmlucHV0LCBsYWJlbDogUkdCbGFiZWwgfVwiXG4gICAgICBsYWJlbD1cImdcIlxuICAgICAgW3ZhbHVlXT1cInJnYi5nXCJcbiAgICAgIChvbkNoYW5nZSk9XCJoYW5kbGVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgPjwvY29sb3ItZWRpdGFibGUtaW5wdXQ+XG4gICAgPGNvbG9yLWVkaXRhYmxlLWlucHV0XG4gICAgICBzdHlsZT1cImZsZXg6IDMgMSAwJVwiXG4gICAgICBbc3R5bGVdPVwieyB3cmFwOiBSR0J3cmFwLCBpbnB1dDogUkdCaW5wdXQsIGxhYmVsOiBSR0JsYWJlbCB9XCJcbiAgICAgIGxhYmVsPVwiYlwiXG4gICAgICBbdmFsdWVdPVwicmdiLmJcIlxuICAgICAgKG9uQ2hhbmdlKT1cImhhbmRsZUNoYW5nZSgkZXZlbnQpXCJcbiAgICA+PC9jb2xvci1lZGl0YWJsZS1pbnB1dD5cbiAgPC9kaXY+XG4gIGAsXG4gIHN0eWxlczogW1xuICAgIGBcbiAgLmNvbXBhY3QtZmllbGRzIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIHBhZGRpbmctYm90dG9tOiA2cHg7XG4gICAgcGFkZGluZy1yaWdodDogNXB4O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgfVxuICAuY29tcGFjdC1hY3RpdmUge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDZweDtcbiAgICBsZWZ0OiA1cHg7XG4gICAgaGVpZ2h0OiA5cHg7XG4gICAgd2lkdGg6IDlweDtcbiAgfVxuICBgLFxuICBdLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG59KVxuZXhwb3J0IGNsYXNzIENvbXBhY3RGaWVsZHNDb21wb25lbnQge1xuICBASW5wdXQoKSBoZXg6IHN0cmluZztcbiAgQElucHV0KCkgcmdiOiBSR0JBO1xuICBAT3V0cHV0KCkgb25DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgSEVYV3JhcDoge1trZXk6IHN0cmluZ106IHN0cmluZ30gPSB7XG4gICAgbWFyZ2luVG9wOiAnLTNweCcsXG4gICAgbWFyZ2luQm90dG9tOiAnLTNweCcsXG4gICAgLy8gZmxleDogJzYgMSAwJScsXG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gIH07XG4gIEhFWGlucHV0OiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSA9IHtcbiAgICB3aWR0aDogJzgwJScsXG4gICAgcGFkZGluZzogJzBweCcsXG4gICAgcGFkZGluZ0xlZnQ6ICcyMCUnLFxuICAgIGJvcmRlcjogJ25vbmUnLFxuICAgIG91dGxpbmU6ICdub25lJyxcbiAgICBiYWNrZ3JvdW5kOiAnbm9uZScsXG4gICAgZm9udFNpemU6ICcxMnB4JyxcbiAgICBjb2xvcjogJyMzMzMnLFxuICAgIGhlaWdodDogJzE2cHgnLFxuICB9O1xuICBIRVhsYWJlbDoge1trZXk6IHN0cmluZ106IHN0cmluZ30gPSB7XG4gICAgZGlzcGxheTogJ25vbmUnLFxuICB9O1xuICBSR0J3cmFwOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSA9IHtcbiAgICBtYXJnaW5Ub3A6ICctM3B4JyxcbiAgICBtYXJnaW5Cb3R0b206ICctM3B4JyxcbiAgICAvLyBmbGV4OiAnMyAxIDAlJyxcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgfTtcbiAgUkdCaW5wdXQ6IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9ID0ge1xuICAgIHdpZHRoOiAnODAlJyxcbiAgICBwYWRkaW5nOiAnMHB4JyxcbiAgICBwYWRkaW5nTGVmdDogJzMwJScsXG4gICAgYm9yZGVyOiAnbm9uZScsXG4gICAgb3V0bGluZTogJ25vbmUnLFxuICAgIGJhY2tncm91bmQ6ICdub25lJyxcbiAgICBmb250U2l6ZTogJzEycHgnLFxuICAgIGNvbG9yOiAnIzMzMycsXG4gICAgaGVpZ2h0OiAnMTZweCcsXG4gIH07XG4gIFJHQmxhYmVsOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSA9IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6ICc2cHgnLFxuICAgIGxlZnQ6ICcwcHgnLFxuICAgICdsaW5lLWhlaWdodCc6ICcxNnB4JyxcbiAgICAndGV4dC10cmFuc2Zvcm0nOiAndXBwZXJjYXNlJyxcbiAgICBmb250U2l6ZTogJzEycHgnLFxuICAgIGNvbG9yOiAnIzk5OScsXG4gIH07XG5cbiAgaGFuZGxlQ2hhbmdlKHsgZGF0YSwgJGV2ZW50IH0pIHtcbiAgICBpZiAoZGF0YS5oZXgpIHtcbiAgICAgIGlmIChpc1ZhbGlkSGV4KGRhdGEuaGV4KSkge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGhleDogZGF0YS5oZXgsXG4gICAgICAgICAgICBzb3VyY2U6ICdoZXgnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgJGV2ZW50LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbkNoYW5nZS5lbWl0KHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHI6IGRhdGEuciB8fCB0aGlzLnJnYi5yLFxuICAgICAgICAgIGc6IGRhdGEuZyB8fCB0aGlzLnJnYi5nLFxuICAgICAgICAgIGI6IGRhdGEuYiB8fCB0aGlzLnJnYi5iLFxuICAgICAgICAgIHNvdXJjZTogJ3JnYicsXG4gICAgICAgIH0sXG4gICAgICAgICRldmVudCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIElucHV0LFxuICBOZ01vZHVsZSxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7XG4gIENvbG9yV3JhcCxcbiAgRWRpdGFibGVJbnB1dE1vZHVsZSxcbiAgUmFpc2VkTW9kdWxlLFxuICBTd2F0Y2hNb2R1bGUsXG59IGZyb20gJ25neC1jb2xvcic7XG5pbXBvcnQgeyBpc1ZhbGlkSGV4IH0gZnJvbSAnbmd4LWNvbG9yJztcbmltcG9ydCB7IENvbXBhY3RDb2xvckNvbXBvbmVudCB9IGZyb20gJy4vY29tcGFjdC1jb2xvci5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29tcGFjdEZpZWxkc0NvbXBvbmVudCB9IGZyb20gJy4vY29tcGFjdC1maWVsZHMuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY29sb3ItY29tcGFjdCcsXG4gIHRlbXBsYXRlOiBgXG4gIDxjb2xvci1yYWlzZWQgY2xhc3M9XCJjb2xvci1jb21wYWN0XCI+XG4gICAgPGRpdiBjbGFzcz1cImNvbXBhY3QtcGlja2VyIHt7IGNsYXNzTmFtZSB9fVwiPlxuICAgICAgPGRpdj5cbiAgICAgICAgPGNvbG9yLWNvbXBhY3QtY29sb3JcbiAgICAgICAgICAqbmdGb3I9XCJsZXQgY29sb3Igb2YgY29sb3JzXCIgW2NvbG9yXT1cImNvbG9yXCJcbiAgICAgICAgICBbYWN0aXZlXT1cImNvbG9yLnRvTG93ZXJDYXNlKCkgPT09IGhleC50b0xvd2VyQ2FzZSgpXCJcbiAgICAgICAgICAob25DbGljayk9XCJoYW5kbGVCbG9ja0NoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgPjwvY29sb3ItY29tcGFjdC1jb2xvcj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbXBhY3QtY2xlYXJcIj48L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGNvbG9yLWNvbXBhY3QtZmllbGRzXG4gICAgICAgIFtoZXhdPVwiaGV4XCJcbiAgICAgICAgW3JnYl09XCJyZ2JcIlxuICAgICAgICAob25DaGFuZ2UpPVwiaGFuZGxlVmFsdWVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICA+PC9jb2xvci1jb21wYWN0LWZpZWxkcz5cbiAgICA8L2Rpdj5cbiAgPC9jb2xvci1yYWlzZWQ+XG4gIGAsXG4gIHN0eWxlczogW1xuICAgIGBcbiAgICAuY29sb3ItY29tcGFjdCB7XG4gICAgICBiYWNrZ3JvdW5kOiAjZjZmNmY2O1xuICAgICAgcmFkaXVzOiA0cHg7XG4gICAgfVxuICAgIC5jb21wYWN0LXBpY2tlciB7XG4gICAgICBwYWRkaW5nLXRvcDogNXB4O1xuICAgICAgcGFkZGluZy1sZWZ0OiA1cHg7XG4gICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgd2lkdGg6IDI0NXB4O1xuICAgIH1cbiAgICAuY29tcGFjdC1jbGVhciB7XG4gICAgICBjbGVhcjogYm90aDtcbiAgICB9XG4gIGAsXG4gIF0sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZSxcbn0pXG5leHBvcnQgY2xhc3MgQ29tcGFjdENvbXBvbmVudCBleHRlbmRzIENvbG9yV3JhcCB7XG4gIC8qKiBDb2xvciBzcXVhcmVzIHRvIGRpc3BsYXkgKi9cbiAgQElucHV0KCkgY29sb3JzID0gW1xuICAgICcjNEQ0RDREJyxcbiAgICAnIzk5OTk5OScsXG4gICAgJyNGRkZGRkYnLFxuICAgICcjRjQ0RTNCJyxcbiAgICAnI0ZFOTIwMCcsXG4gICAgJyNGQ0RDMDAnLFxuICAgICcjREJERjAwJyxcbiAgICAnI0E0REQwMCcsXG4gICAgJyM2OENDQ0EnLFxuICAgICcjNzNEOEZGJyxcbiAgICAnI0FFQTFGRicsXG4gICAgJyNGREExRkYnLFxuICAgICcjMzMzMzMzJyxcbiAgICAnIzgwODA4MCcsXG4gICAgJyNjY2NjY2MnLFxuICAgICcjRDMzMTE1JyxcbiAgICAnI0UyNzMwMCcsXG4gICAgJyNGQ0M0MDAnLFxuICAgICcjQjBCQzAwJyxcbiAgICAnIzY4QkMwMCcsXG4gICAgJyMxNkE1QTUnLFxuICAgICcjMDA5Q0UwJyxcbiAgICAnIzdCNjRGRicsXG4gICAgJyNGQTI4RkYnLFxuICAgICcjMDAwMDAwJyxcbiAgICAnIzY2NjY2NicsXG4gICAgJyNCM0IzQjMnLFxuICAgICcjOUYwNTAwJyxcbiAgICAnI0M0NTEwMCcsXG4gICAgJyNGQjlFMDAnLFxuICAgICcjODA4OTAwJyxcbiAgICAnIzE5NEQzMycsXG4gICAgJyMwQzc5N0QnLFxuICAgICcjMDA2MkIxJyxcbiAgICAnIzY1MzI5NCcsXG4gICAgJyNBQjE0OUUnLFxuICBdO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cbiAgaGFuZGxlQmxvY2tDaGFuZ2UoeyBoZXgsICRldmVudCB9KSB7XG4gICAgaWYgKGlzVmFsaWRIZXgoaGV4KSkge1xuICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UoeyBoZXgsIHNvdXJjZTogJ2hleCcgfSwgJGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlVmFsdWVDaGFuZ2UoeyBkYXRhLCAkZXZlbnQgfSkge1xuICAgIHRoaXMuaGFuZGxlQ2hhbmdlKGRhdGEsICRldmVudCk7XG4gIH1cbn1cblxuQE5nTW9kdWxlKHtcbiAgZGVjbGFyYXRpb25zOiBbXG4gICAgQ29tcGFjdENvbXBvbmVudCxcbiAgICBDb21wYWN0Q29sb3JDb21wb25lbnQsXG4gICAgQ29tcGFjdEZpZWxkc0NvbXBvbmVudCxcbiAgXSxcbiAgZXhwb3J0czogW0NvbXBhY3RDb21wb25lbnQsIENvbXBhY3RDb2xvckNvbXBvbmVudCwgQ29tcGFjdEZpZWxkc0NvbXBvbmVudF0sXG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIEVkaXRhYmxlSW5wdXRNb2R1bGUsIFN3YXRjaE1vZHVsZSwgUmFpc2VkTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ29sb3JDb21wYWN0TW9kdWxlIHt9XG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwiZ2V0Q29udHJhc3RpbmdDb2xvciIsIkNvbXBvbmVudCIsIkNoYW5nZURldGVjdGlvblN0cmF0ZWd5IiwiSW5wdXQiLCJPdXRwdXQiLCJpc1ZhbGlkSGV4IiwidHNsaWJfMS5fX2V4dGVuZHMiLCJDb2xvcldyYXAiLCJOZ01vZHVsZSIsIkNvbW1vbk1vZHVsZSIsIkVkaXRhYmxlSW5wdXRNb2R1bGUiLCJTd2F0Y2hNb2R1bGUiLCJSYWlzZWRNb2R1bGUiXSwibWFwcGluZ3MiOiI7Ozs7OztJQUFBOzs7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