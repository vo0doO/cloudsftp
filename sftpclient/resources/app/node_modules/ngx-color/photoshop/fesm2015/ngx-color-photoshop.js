import { ChangeDetectionStrategy, Component, EventEmitter, Input, Output, NgModule } from '@angular/core';
import { isValidHex, ColorWrap, AlphaModule, EditableInputModule, HueModule, SaturationModule, SwatchModule } from 'ngx-color';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class PhotoshopButtonComponent {
    constructor() {
        this.label = '';
        this.active = false;
        this.click = new EventEmitter();
    }
}
PhotoshopButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'color-photoshop-button',
                template: `
    <div class="photoshop-button"  [class.active]="active"
      (click)="click.emit($event)"
    >
      {{ label }}
    </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                styles: [`
    .photoshop-button {
      background-image: linear-gradient(
        -180deg,
        rgb(255, 255, 255) 0%,
        rgb(230, 230, 230) 100%
      );
      border: 1px solid rgb(135, 135, 135);
      border-radius: 2px;
      height: 22px;
      box-shadow: rgb(234, 234, 234) 0px 1px 0px 0px;
      font-size: 14px;
      color: rgb(0, 0, 0);
      line-height: 20px;
      text-align: center;
      margin-bottom: 10px;
      cursor: pointer;
    }
    .photoshop-button.active {
      box-shadow: 0 0 0 1px #878787;
    }
  `]
            }] }
];
PhotoshopButtonComponent.propDecorators = {
    label: [{ type: Input }],
    active: [{ type: Input }],
    click: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class PhotoshopFieldsComponent {
    constructor() {
        this.onChange = new EventEmitter();
        this.RGBinput = {
            marginLeft: '35%',
            width: '40%',
            height: '22px',
            border: '1px solid rgb(136, 136, 136)',
            boxShadow: 'rgba(0, 0, 0, 0.1) 0px 1px 1px inset, rgb(236, 236, 236) 0px 1px 0px 0px',
            marginBottom: '2px',
            fontSize: '13px',
            paddingLeft: '3px',
            marginRight: '10px',
        };
        this.RGBwrap = {
            position: 'relative',
        };
        this.RGBlabel = {
            left: '0px',
            width: '34px',
            textTransform: 'uppercase',
            fontSize: '13px',
            height: '24px',
            lineHeight: '24px',
            position: 'absolute',
        };
        this.HEXinput = {
            marginLeft: '20%',
            width: '80%',
            height: '22px',
            border: '1px solid #888888',
            boxShadow: 'inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC',
            marginBottom: '3px',
            fontSize: '13px',
            paddingLeft: '3px',
        };
        this.HEXwrap = {
            position: 'relative',
        };
        this.HEXlabel = {
            position: 'absolute',
            top: '0px',
            left: '0px',
            width: '14px',
            textTransform: 'uppercase',
            fontSize: '13px',
            height: '24px',
            lineHeight: '24px',
        };
    }
    /**
     * @param {?} v
     * @return {?}
     */
    round(v) {
        return Math.round(v);
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    handleValueChange({ data, $event }) {
        if (data['#']) {
            if (isValidHex(data['#'])) {
                this.onChange.emit({
                    data: {
                        hex: data['#'],
                        source: 'hex',
                    },
                    $event,
                });
            }
        }
        else if (data.r || data.g || data.b) {
            this.onChange.emit({
                data: {
                    r: data.r || this.rgb.r,
                    g: data.g || this.rgb.g,
                    b: data.b || this.rgb.b,
                    source: 'rgb',
                },
                $event,
            });
        }
        else if (data.h || data.s || data.v) {
            this.onChange.emit({
                data: {
                    h: data.h || this.hsv.h,
                    s: data.s || this.hsv.s,
                    v: data.v || this.hsv.v,
                    source: 'hsv',
                },
                $event,
            });
        }
    }
}
PhotoshopFieldsComponent.decorators = [
    { type: Component, args: [{
                selector: 'color-photoshop-fields',
                template: `
  <div class="photoshop-fields">
    <color-editable-input
      [value]="round(hsv.h)"
      label="h"
      (onChange)="handleValueChange($event)"
      [style]="{input: RGBinput, wrap: RGBwrap, label: RGBlabel}"
    ></color-editable-input>
    <color-editable-input
      [value]="round(hsv.s * 100)"
      label="s"
      (onChange)="handleValueChange($event)"
      [style]="{input: RGBinput, wrap: RGBwrap, label: RGBlabel}"
    ></color-editable-input>
    <color-editable-input
      [value]="round(hsv.v * 100)"
      label="v"
      (onChange)="handleValueChange($event)"
      [style]="{input: RGBinput, wrap: RGBwrap, label: RGBlabel}"
    ></color-editable-input>
    <div class="photoshop-divider"></div>
    <color-editable-input
      [value]="rgb.r"
      label="r"
      (onChange)="handleValueChange($event)"
      [style]="{input: RGBinput, wrap: RGBwrap, label: RGBlabel}"
    ></color-editable-input>
    <color-editable-input
      [value]="rgb.g"
      label="g"
      (onChange)="handleValueChange($event)"
      [style]="{input: RGBinput, wrap: RGBwrap, label: RGBlabel}"
    ></color-editable-input>
    <color-editable-input
      [value]="rgb.b"
      label="b"
      (onChange)="handleValueChange($event)"
      [style]="{input: RGBinput, wrap: RGBwrap, label: RGBlabel}"
    ></color-editable-input>
    <div class="photoshop-divider"></div>
    <color-editable-input
      [value]="hex.replace('#', '')"
      label="#"
      (onChange)="handleValueChange($event)"
      [style]="{input: HEXinput, wrap: HEXwrap, label: HEXlabel}"
    ></color-editable-input>
    <div class="photoshop-field-symbols">
      <div class="photoshop-symbol">°</div>
      <div class="photoshop-symbol">%</div>
      <div class="photoshop-symbol">%</div>
    </div>
  </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                styles: [`
    .photoshop-fields {
      padding-top: 5px;
      padding-bottom: 9px;
      width: 85px;
      position: relative;
    }
    .photoshop-field-symbols {
      position: absolute;
      top: 5px;
      right: -7px;
      font-size: 13px;
    }
    .photoshop-symbol {
      height: 24px;
      line-height: 24px;
      padding-bottom: 7px;
    }
    .photoshop-divider {
      height: 5px;
    }
  `]
            }] }
];
PhotoshopFieldsComponent.propDecorators = {
    rgb: [{ type: Input }],
    hsv: [{ type: Input }],
    hex: [{ type: Input }],
    onChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class PhotoshopPreviewsComponent {
    constructor() {
        this.currentColor = '';
        this.backgroundNew = '';
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.backgroundNew = `rgb(${this.rgb.r},${this.rgb.g}, ${this.rgb.b})`;
    }
}
PhotoshopPreviewsComponent.decorators = [
    { type: Component, args: [{
                selector: 'color-photoshop-previews',
                template: `
  <div>
    <div class="photoshop-label">new</div>
    <div class="photoshop-swatches">
      <div class="photoshop-new" [style.background]="backgroundNew"></div>
      <div class="photoshop-current" [style.background]="currentColor"></div>
    </div>
    <div class="photoshop-label">current</div>
  </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                styles: [`
  .photoshop-swatches {
    border: 1px solid #B3B3B3;
    border-bottom: 1px solid #F0F0F0;
    margin-bottom: 2px;
    margin-top: 1px;
  }
  .photoshop-new {
    height: 34px;
    box-shadow: inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 1px 0 #000;
  }
  .photoshop-current {
    height: 34px;
    box-shadow: inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 -1px 0 #000;
  }
  .photoshop-label {
    font-size: 14px;
    color: #000;
    text-align: center;
  }
  `]
            }] }
];
PhotoshopPreviewsComponent.propDecorators = {
    rgb: [{ type: Input }],
    currentColor: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class PhotoshopComponent extends ColorWrap {
    constructor() {
        super();
        /**
         * Title text
         */
        this.header = 'Color Picker';
        this.onAccept = new EventEmitter();
        this.onCancel = new EventEmitter();
        this.circle = {
            width: '12px',
            height: '12px',
            borderRadius: '6px',
            boxShadow: 'rgb(255, 255, 255) 0px 0px 0px 1px inset',
            transform: 'translate(-6px, -10px)',
        };
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    handleValueChange({ data, $event }) {
        this.handleChange(data, $event);
    }
}
PhotoshopComponent.decorators = [
    { type: Component, args: [{
                selector: 'color-photoshop',
                template: `
  <div class="photoshop-picker {{ className }}">
    <div class="photoshop-head">{{ header }}</div>
    <div class="photoshop-body">
      <div class="photoshop-saturation">
        <color-saturation
          [hsl]="hsl" [hsv]="hsv" [circle]="circle"
          (onChange)="handleValueChange($event)"
        ></color-saturation>
      </div>
      <div class="photoshop-hue">
        <color-hue direction="vertical"
          [hsl]="hsl" [hidePointer]="true"
          (onChange)="handleValueChange($event)"
        ></color-hue>
      </div>
      <div class="photoshop-controls">
        <div class="photoshop-top">
          <div class="photoshop-previews">
            <color-photoshop-previews
              [rgb]="rgb" [currentColor]="currentColor"
            ></color-photoshop-previews>
          </div>
          <div class="photoshop-actions">
            <color-photoshop-button label="OK"
              [active]="true" (click)="onAccept.emit($event)"
            ></color-photoshop-button>
            <color-photoshop-button label="Cancel"
              (click)="onCancel.emit($event)"
            >
            </color-photoshop-button>
            <color-photoshop-fields
              [rgb]="rgb" [hex]="hex" [hsv]="hsv"
              (onChange)="handleValueChange($event)"
            ></color-photoshop-fields>
          </div>
        </div>
      </div>
    </div>
  </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                styles: [`
    .photoshop-picker {
      background: rgb(220, 220, 220);
      border-radius: 4px;
      box-shadow: rgba(0, 0, 0, 0.25) 0px 0px 0px 1px, rgba(0, 0, 0, 0.15) 0px 8px 16px;
      box-sizing: initial; width: 513px;
    }
    .photoshop-head {
      background-image: linear-gradient(
        -180deg,
        rgb(240, 240, 240) 0%,
        rgb(212, 212, 212) 100%
      );
      border-bottom: 1px solid rgb(177, 177, 177);
      box-shadow: rgba(255, 255, 255, 0.2) 0px 1px 0px 0px inset,
        rgba(0, 0, 0, 0.02) 0px -1px 0px 0px inset;
      height: 23px;
      line-height: 24px;
      border-radius: 4px 4px 0px 0px;
      font-size: 13px;
      color: rgb(77, 77, 77);
      text-align: center;
    }
    .photoshop-body {
      padding: 15px 15px 0px;
      display: flex;
    }
    .photoshop-saturation {
      width: 256px;
      height: 256px;
      position: relative;
      border-width: 2px;
      border-style: solid;
      border-color: rgb(179, 179, 179) rgb(179, 179, 179) rgb(240, 240, 240);
      border-image: initial;
      overflow: hidden;
    }
    .photoshop-hue {
      position: relative;
      height: 256px;
      width: 23px;
      margin-left: 10px;
      border-width: 2px;
      border-style: solid;
      border-color: rgb(179, 179, 179) rgb(179, 179, 179) rgb(240, 240, 240);
      border-image: initial;
    }
    .photoshop-controls {
      width: 180px;
      margin-left: 10px;
    }
    .photoshop-top {
      display: flex;
    }
    .photoshop-previews {
      width: 60px;
    }
    .photoshop-actions {
      -webkit-box-flex: 1;
      flex: 1 1 0%;
      margin-left: 20px;
    }
  `]
            }] }
];
/** @nocollapse */
PhotoshopComponent.ctorParameters = () => [];
PhotoshopComponent.propDecorators = {
    header: [{ type: Input }],
    onAccept: [{ type: Output }],
    onCancel: [{ type: Output }]
};
class ColorPhotoshopModule {
}
ColorPhotoshopModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    PhotoshopComponent,
                    PhotoshopPreviewsComponent,
                    PhotoshopButtonComponent,
                    PhotoshopFieldsComponent,
                ],
                exports: [
                    PhotoshopComponent,
                    PhotoshopPreviewsComponent,
                    PhotoshopButtonComponent,
                    PhotoshopFieldsComponent,
                ],
                imports: [
                    CommonModule,
                    EditableInputModule,
                    HueModule,
                    AlphaModule,
                    SwatchModule,
                    SaturationModule,
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { PhotoshopComponent, ColorPhotoshopModule, PhotoshopButtonComponent as ɵb, PhotoshopFieldsComponent as ɵc, PhotoshopPreviewsComponent as ɵa };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWNvbG9yLXBob3Rvc2hvcC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vbmd4LWNvbG9yL3Bob3Rvc2hvcC9waG90b3Nob3AtYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vbmd4LWNvbG9yL3Bob3Rvc2hvcC9waG90b3Nob3AtZmllbGRzLmNvbXBvbmVudC50cyIsIm5nOi8vbmd4LWNvbG9yL3Bob3Rvc2hvcC9waG90b3Nob3AtcHJldmlld3MuY29tcG9uZW50LnRzIiwibmc6Ly9uZ3gtY29sb3IvcGhvdG9zaG9wL3Bob3Rvc2hvcC5jb21wb25lbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT3V0cHV0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY29sb3ItcGhvdG9zaG9wLWJ1dHRvbicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPGRpdiBjbGFzcz1cInBob3Rvc2hvcC1idXR0b25cIiAgW2NsYXNzLmFjdGl2ZV09XCJhY3RpdmVcIlxuICAgICAgKGNsaWNrKT1cImNsaWNrLmVtaXQoJGV2ZW50KVwiXG4gICAgPlxuICAgICAge3sgbGFiZWwgfX1cbiAgICA8L2Rpdj5cbiAgYCxcbiAgc3R5bGVzOiBbXG4gICAgYFxuICAgIC5waG90b3Nob3AtYnV0dG9uIHtcbiAgICAgIGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudChcbiAgICAgICAgLTE4MGRlZyxcbiAgICAgICAgcmdiKDI1NSwgMjU1LCAyNTUpIDAlLFxuICAgICAgICByZ2IoMjMwLCAyMzAsIDIzMCkgMTAwJVxuICAgICAgKTtcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYigxMzUsIDEzNSwgMTM1KTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICAgIGhlaWdodDogMjJweDtcbiAgICAgIGJveC1zaGFkb3c6IHJnYigyMzQsIDIzNCwgMjM0KSAwcHggMXB4IDBweCAwcHg7XG4gICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICBjb2xvcjogcmdiKDAsIDAsIDApO1xuICAgICAgbGluZS1oZWlnaHQ6IDIwcHg7XG4gICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xuICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cbiAgICAucGhvdG9zaG9wLWJ1dHRvbi5hY3RpdmUge1xuICAgICAgYm94LXNoYWRvdzogMCAwIDAgMXB4ICM4Nzg3ODc7XG4gICAgfVxuICBgLFxuICBdLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG59KVxuZXhwb3J0IGNsYXNzIFBob3Rvc2hvcEJ1dHRvbkNvbXBvbmVudCB7XG4gIEBJbnB1dCgpIGxhYmVsID0gJyc7XG4gIEBJbnB1dCgpIGFjdGl2ZSA9IGZhbHNlO1xuICBAT3V0cHV0KCkgY2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyPEV2ZW50PigpO1xufVxuIiwiaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT3V0cHV0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgaXNWYWxpZEhleCwgSFNWLCBSR0IgfSBmcm9tICduZ3gtY29sb3InO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjb2xvci1waG90b3Nob3AtZmllbGRzJyxcbiAgdGVtcGxhdGU6IGBcbiAgPGRpdiBjbGFzcz1cInBob3Rvc2hvcC1maWVsZHNcIj5cbiAgICA8Y29sb3ItZWRpdGFibGUtaW5wdXRcbiAgICAgIFt2YWx1ZV09XCJyb3VuZChoc3YuaClcIlxuICAgICAgbGFiZWw9XCJoXCJcbiAgICAgIChvbkNoYW5nZSk9XCJoYW5kbGVWYWx1ZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgIFtzdHlsZV09XCJ7aW5wdXQ6IFJHQmlucHV0LCB3cmFwOiBSR0J3cmFwLCBsYWJlbDogUkdCbGFiZWx9XCJcbiAgICA+PC9jb2xvci1lZGl0YWJsZS1pbnB1dD5cbiAgICA8Y29sb3ItZWRpdGFibGUtaW5wdXRcbiAgICAgIFt2YWx1ZV09XCJyb3VuZChoc3YucyAqIDEwMClcIlxuICAgICAgbGFiZWw9XCJzXCJcbiAgICAgIChvbkNoYW5nZSk9XCJoYW5kbGVWYWx1ZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgIFtzdHlsZV09XCJ7aW5wdXQ6IFJHQmlucHV0LCB3cmFwOiBSR0J3cmFwLCBsYWJlbDogUkdCbGFiZWx9XCJcbiAgICA+PC9jb2xvci1lZGl0YWJsZS1pbnB1dD5cbiAgICA8Y29sb3ItZWRpdGFibGUtaW5wdXRcbiAgICAgIFt2YWx1ZV09XCJyb3VuZChoc3YudiAqIDEwMClcIlxuICAgICAgbGFiZWw9XCJ2XCJcbiAgICAgIChvbkNoYW5nZSk9XCJoYW5kbGVWYWx1ZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgIFtzdHlsZV09XCJ7aW5wdXQ6IFJHQmlucHV0LCB3cmFwOiBSR0J3cmFwLCBsYWJlbDogUkdCbGFiZWx9XCJcbiAgICA+PC9jb2xvci1lZGl0YWJsZS1pbnB1dD5cbiAgICA8ZGl2IGNsYXNzPVwicGhvdG9zaG9wLWRpdmlkZXJcIj48L2Rpdj5cbiAgICA8Y29sb3ItZWRpdGFibGUtaW5wdXRcbiAgICAgIFt2YWx1ZV09XCJyZ2IuclwiXG4gICAgICBsYWJlbD1cInJcIlxuICAgICAgKG9uQ2hhbmdlKT1cImhhbmRsZVZhbHVlQ2hhbmdlKCRldmVudClcIlxuICAgICAgW3N0eWxlXT1cIntpbnB1dDogUkdCaW5wdXQsIHdyYXA6IFJHQndyYXAsIGxhYmVsOiBSR0JsYWJlbH1cIlxuICAgID48L2NvbG9yLWVkaXRhYmxlLWlucHV0PlxuICAgIDxjb2xvci1lZGl0YWJsZS1pbnB1dFxuICAgICAgW3ZhbHVlXT1cInJnYi5nXCJcbiAgICAgIGxhYmVsPVwiZ1wiXG4gICAgICAob25DaGFuZ2UpPVwiaGFuZGxlVmFsdWVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICBbc3R5bGVdPVwie2lucHV0OiBSR0JpbnB1dCwgd3JhcDogUkdCd3JhcCwgbGFiZWw6IFJHQmxhYmVsfVwiXG4gICAgPjwvY29sb3ItZWRpdGFibGUtaW5wdXQ+XG4gICAgPGNvbG9yLWVkaXRhYmxlLWlucHV0XG4gICAgICBbdmFsdWVdPVwicmdiLmJcIlxuICAgICAgbGFiZWw9XCJiXCJcbiAgICAgIChvbkNoYW5nZSk9XCJoYW5kbGVWYWx1ZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgIFtzdHlsZV09XCJ7aW5wdXQ6IFJHQmlucHV0LCB3cmFwOiBSR0J3cmFwLCBsYWJlbDogUkdCbGFiZWx9XCJcbiAgICA+PC9jb2xvci1lZGl0YWJsZS1pbnB1dD5cbiAgICA8ZGl2IGNsYXNzPVwicGhvdG9zaG9wLWRpdmlkZXJcIj48L2Rpdj5cbiAgICA8Y29sb3ItZWRpdGFibGUtaW5wdXRcbiAgICAgIFt2YWx1ZV09XCJoZXgucmVwbGFjZSgnIycsICcnKVwiXG4gICAgICBsYWJlbD1cIiNcIlxuICAgICAgKG9uQ2hhbmdlKT1cImhhbmRsZVZhbHVlQ2hhbmdlKCRldmVudClcIlxuICAgICAgW3N0eWxlXT1cIntpbnB1dDogSEVYaW5wdXQsIHdyYXA6IEhFWHdyYXAsIGxhYmVsOiBIRVhsYWJlbH1cIlxuICAgID48L2NvbG9yLWVkaXRhYmxlLWlucHV0PlxuICAgIDxkaXYgY2xhc3M9XCJwaG90b3Nob3AtZmllbGQtc3ltYm9sc1wiPlxuICAgICAgPGRpdiBjbGFzcz1cInBob3Rvc2hvcC1zeW1ib2xcIj7DgsKwPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwicGhvdG9zaG9wLXN5bWJvbFwiPiU8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJwaG90b3Nob3Atc3ltYm9sXCI+JTwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbiAgYCxcbiAgc3R5bGVzOiBbXG4gICAgYFxuICAgIC5waG90b3Nob3AtZmllbGRzIHtcbiAgICAgIHBhZGRpbmctdG9wOiA1cHg7XG4gICAgICBwYWRkaW5nLWJvdHRvbTogOXB4O1xuICAgICAgd2lkdGg6IDg1cHg7XG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgfVxuICAgIC5waG90b3Nob3AtZmllbGQtc3ltYm9scyB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB0b3A6IDVweDtcbiAgICAgIHJpZ2h0OiAtN3B4O1xuICAgICAgZm9udC1zaXplOiAxM3B4O1xuICAgIH1cbiAgICAucGhvdG9zaG9wLXN5bWJvbCB7XG4gICAgICBoZWlnaHQ6IDI0cHg7XG4gICAgICBsaW5lLWhlaWdodDogMjRweDtcbiAgICAgIHBhZGRpbmctYm90dG9tOiA3cHg7XG4gICAgfVxuICAgIC5waG90b3Nob3AtZGl2aWRlciB7XG4gICAgICBoZWlnaHQ6IDVweDtcbiAgICB9XG4gIGAsXG4gIF0sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZSxcbn0pXG5leHBvcnQgY2xhc3MgUGhvdG9zaG9wRmllbGRzQ29tcG9uZW50IHtcbiAgQElucHV0KCkgcmdiOiBSR0I7XG4gIEBJbnB1dCgpIGhzdjogSFNWO1xuICBASW5wdXQoKSBoZXg6IHN0cmluZztcbiAgQE91dHB1dCgpIG9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG4gIFJHQmlucHV0OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge1xuICAgIG1hcmdpbkxlZnQ6ICczNSUnLFxuICAgIHdpZHRoOiAnNDAlJyxcbiAgICBoZWlnaHQ6ICcyMnB4JyxcbiAgICBib3JkZXI6ICcxcHggc29saWQgcmdiKDEzNiwgMTM2LCAxMzYpJyxcbiAgICBib3hTaGFkb3c6XG4gICAgICAncmdiYSgwLCAwLCAwLCAwLjEpIDBweCAxcHggMXB4IGluc2V0LCByZ2IoMjM2LCAyMzYsIDIzNikgMHB4IDFweCAwcHggMHB4JyxcbiAgICBtYXJnaW5Cb3R0b206ICcycHgnLFxuICAgIGZvbnRTaXplOiAnMTNweCcsXG4gICAgcGFkZGluZ0xlZnQ6ICczcHgnLFxuICAgIG1hcmdpblJpZ2h0OiAnMTBweCcsXG4gIH07XG4gIFJHQndyYXA6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gIH07XG4gIFJHQmxhYmVsOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge1xuICAgIGxlZnQ6ICcwcHgnLFxuICAgIHdpZHRoOiAnMzRweCcsXG4gICAgdGV4dFRyYW5zZm9ybTogJ3VwcGVyY2FzZScsXG4gICAgZm9udFNpemU6ICcxM3B4JyxcbiAgICBoZWlnaHQ6ICcyNHB4JyxcbiAgICBsaW5lSGVpZ2h0OiAnMjRweCcsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gIH07XG4gIEhFWGlucHV0OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge1xuICAgIG1hcmdpbkxlZnQ6ICcyMCUnLFxuICAgIHdpZHRoOiAnODAlJyxcbiAgICBoZWlnaHQ6ICcyMnB4JyxcbiAgICBib3JkZXI6ICcxcHggc29saWQgIzg4ODg4OCcsXG4gICAgYm94U2hhZG93OiAnaW5zZXQgMCAxcHggMXB4IHJnYmEoMCwwLDAsLjEpLCAwIDFweCAwIDAgI0VDRUNFQycsXG4gICAgbWFyZ2luQm90dG9tOiAnM3B4JyxcbiAgICBmb250U2l6ZTogJzEzcHgnLFxuICAgIHBhZGRpbmdMZWZ0OiAnM3B4JyxcbiAgfTtcbiAgSEVYd3JhcDogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgfTtcbiAgSEVYbGFiZWw6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdG9wOiAnMHB4JyxcbiAgICBsZWZ0OiAnMHB4JyxcbiAgICB3aWR0aDogJzE0cHgnLFxuICAgIHRleHRUcmFuc2Zvcm06ICd1cHBlcmNhc2UnLFxuICAgIGZvbnRTaXplOiAnMTNweCcsXG4gICAgaGVpZ2h0OiAnMjRweCcsXG4gICAgbGluZUhlaWdodDogJzI0cHgnLFxuICB9O1xuXG4gIHJvdW5kKHYpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2KTtcbiAgfVxuICBoYW5kbGVWYWx1ZUNoYW5nZSh7IGRhdGEsICRldmVudCB9KSB7XG4gICAgaWYgKGRhdGFbJyMnXSkge1xuICAgICAgaWYgKGlzVmFsaWRIZXgoZGF0YVsnIyddKSkge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGhleDogZGF0YVsnIyddLFxuICAgICAgICAgICAgc291cmNlOiAnaGV4JyxcbiAgICAgICAgICB9LFxuICAgICAgICAgICRldmVudCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhLnIgfHwgZGF0YS5nIHx8IGRhdGEuYikge1xuICAgICAgdGhpcy5vbkNoYW5nZS5lbWl0KHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHI6IGRhdGEuciB8fCB0aGlzLnJnYi5yLFxuICAgICAgICAgIGc6IGRhdGEuZyB8fCB0aGlzLnJnYi5nLFxuICAgICAgICAgIGI6IGRhdGEuYiB8fCB0aGlzLnJnYi5iLFxuICAgICAgICAgIHNvdXJjZTogJ3JnYicsXG4gICAgICAgIH0sXG4gICAgICAgICRldmVudCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5oIHx8IGRhdGEucyB8fCBkYXRhLnYpIHtcbiAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBoOiBkYXRhLmggfHwgdGhpcy5oc3YuaCxcbiAgICAgICAgICBzOiBkYXRhLnMgfHwgdGhpcy5oc3YucyxcbiAgICAgICAgICB2OiBkYXRhLnYgfHwgdGhpcy5oc3YudixcbiAgICAgICAgICBzb3VyY2U6ICdoc3YnLFxuICAgICAgICB9LFxuICAgICAgICAkZXZlbnQsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUkdCIH0gZnJvbSAnbmd4LWNvbG9yJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY29sb3ItcGhvdG9zaG9wLXByZXZpZXdzJyxcbiAgdGVtcGxhdGU6IGBcbiAgPGRpdj5cbiAgICA8ZGl2IGNsYXNzPVwicGhvdG9zaG9wLWxhYmVsXCI+bmV3PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInBob3Rvc2hvcC1zd2F0Y2hlc1wiPlxuICAgICAgPGRpdiBjbGFzcz1cInBob3Rvc2hvcC1uZXdcIiBbc3R5bGUuYmFja2dyb3VuZF09XCJiYWNrZ3JvdW5kTmV3XCI+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwicGhvdG9zaG9wLWN1cnJlbnRcIiBbc3R5bGUuYmFja2dyb3VuZF09XCJjdXJyZW50Q29sb3JcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwicGhvdG9zaG9wLWxhYmVsXCI+Y3VycmVudDwvZGl2PlxuICA8L2Rpdj5cbiAgYCxcbiAgc3R5bGVzOiBbXG4gICAgYFxuICAucGhvdG9zaG9wLXN3YXRjaGVzIHtcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjQjNCM0IzO1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjRjBGMEYwO1xuICAgIG1hcmdpbi1ib3R0b206IDJweDtcbiAgICBtYXJnaW4tdG9wOiAxcHg7XG4gIH1cbiAgLnBob3Rvc2hvcC1uZXcge1xuICAgIGhlaWdodDogMzRweDtcbiAgICBib3gtc2hhZG93OiBpbnNldCAxcHggMCAwICMwMDAsIGluc2V0IC0xcHggMCAwICMwMDAsIGluc2V0IDAgMXB4IDAgIzAwMDtcbiAgfVxuICAucGhvdG9zaG9wLWN1cnJlbnQge1xuICAgIGhlaWdodDogMzRweDtcbiAgICBib3gtc2hhZG93OiBpbnNldCAxcHggMCAwICMwMDAsIGluc2V0IC0xcHggMCAwICMwMDAsIGluc2V0IDAgLTFweCAwICMwMDA7XG4gIH1cbiAgLnBob3Rvc2hvcC1sYWJlbCB7XG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGNvbG9yOiAjMDAwO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgfVxuICBgLFxuICBdLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG59KVxuZXhwb3J0IGNsYXNzIFBob3Rvc2hvcFByZXZpZXdzQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgcmdiOiBSR0I7XG4gIEBJbnB1dCgpIGN1cnJlbnRDb2xvciA9ICcnO1xuICBiYWNrZ3JvdW5kTmV3ID0gJyc7XG5cbiAgbmdPbkNoYW5nZXMoKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTmV3ID0gYHJnYigke3RoaXMucmdiLnJ9LCR7dGhpcy5yZ2IuZ30sICR7dGhpcy5yZ2IuYn0pYDtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE5nTW9kdWxlLFxuICBPdXRwdXQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDb2xvcldyYXAgfSBmcm9tICduZ3gtY29sb3InO1xuaW1wb3J0IHtcbiAgQWxwaGFNb2R1bGUsXG4gIEVkaXRhYmxlSW5wdXRNb2R1bGUsXG4gIEh1ZU1vZHVsZSxcbiAgU2F0dXJhdGlvbk1vZHVsZSxcbiAgU3dhdGNoTW9kdWxlLFxufSBmcm9tICduZ3gtY29sb3InO1xuaW1wb3J0IHsgUGhvdG9zaG9wQnV0dG9uQ29tcG9uZW50IH0gZnJvbSAnLi9waG90b3Nob3AtYnV0dG9uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQaG90b3Nob3BGaWVsZHNDb21wb25lbnQgfSBmcm9tICcuL3Bob3Rvc2hvcC1maWVsZHMuY29tcG9uZW50JztcbmltcG9ydCB7IFBob3Rvc2hvcFByZXZpZXdzQ29tcG9uZW50IH0gZnJvbSAnLi9waG90b3Nob3AtcHJldmlld3MuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY29sb3ItcGhvdG9zaG9wJyxcbiAgdGVtcGxhdGU6IGBcbiAgPGRpdiBjbGFzcz1cInBob3Rvc2hvcC1waWNrZXIge3sgY2xhc3NOYW1lIH19XCI+XG4gICAgPGRpdiBjbGFzcz1cInBob3Rvc2hvcC1oZWFkXCI+e3sgaGVhZGVyIH19PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInBob3Rvc2hvcC1ib2R5XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwicGhvdG9zaG9wLXNhdHVyYXRpb25cIj5cbiAgICAgICAgPGNvbG9yLXNhdHVyYXRpb25cbiAgICAgICAgICBbaHNsXT1cImhzbFwiIFtoc3ZdPVwiaHN2XCIgW2NpcmNsZV09XCJjaXJjbGVcIlxuICAgICAgICAgIChvbkNoYW5nZSk9XCJoYW5kbGVWYWx1ZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgPjwvY29sb3Itc2F0dXJhdGlvbj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInBob3Rvc2hvcC1odWVcIj5cbiAgICAgICAgPGNvbG9yLWh1ZSBkaXJlY3Rpb249XCJ2ZXJ0aWNhbFwiXG4gICAgICAgICAgW2hzbF09XCJoc2xcIiBbaGlkZVBvaW50ZXJdPVwidHJ1ZVwiXG4gICAgICAgICAgKG9uQ2hhbmdlKT1cImhhbmRsZVZhbHVlQ2hhbmdlKCRldmVudClcIlxuICAgICAgICA+PC9jb2xvci1odWU+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJwaG90b3Nob3AtY29udHJvbHNcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInBob3Rvc2hvcC10b3BcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwicGhvdG9zaG9wLXByZXZpZXdzXCI+XG4gICAgICAgICAgICA8Y29sb3ItcGhvdG9zaG9wLXByZXZpZXdzXG4gICAgICAgICAgICAgIFtyZ2JdPVwicmdiXCIgW2N1cnJlbnRDb2xvcl09XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgPjwvY29sb3ItcGhvdG9zaG9wLXByZXZpZXdzPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJwaG90b3Nob3AtYWN0aW9uc1wiPlxuICAgICAgICAgICAgPGNvbG9yLXBob3Rvc2hvcC1idXR0b24gbGFiZWw9XCJPS1wiXG4gICAgICAgICAgICAgIFthY3RpdmVdPVwidHJ1ZVwiIChjbGljayk9XCJvbkFjY2VwdC5lbWl0KCRldmVudClcIlxuICAgICAgICAgICAgPjwvY29sb3ItcGhvdG9zaG9wLWJ1dHRvbj5cbiAgICAgICAgICAgIDxjb2xvci1waG90b3Nob3AtYnV0dG9uIGxhYmVsPVwiQ2FuY2VsXCJcbiAgICAgICAgICAgICAgKGNsaWNrKT1cIm9uQ2FuY2VsLmVtaXQoJGV2ZW50KVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICA8L2NvbG9yLXBob3Rvc2hvcC1idXR0b24+XG4gICAgICAgICAgICA8Y29sb3ItcGhvdG9zaG9wLWZpZWxkc1xuICAgICAgICAgICAgICBbcmdiXT1cInJnYlwiIFtoZXhdPVwiaGV4XCIgW2hzdl09XCJoc3ZcIlxuICAgICAgICAgICAgICAob25DaGFuZ2UpPVwiaGFuZGxlVmFsdWVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICA+PC9jb2xvci1waG90b3Nob3AtZmllbGRzPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbiAgYCxcbiAgc3R5bGVzOiBbXG4gICAgYFxuICAgIC5waG90b3Nob3AtcGlja2VyIHtcbiAgICAgIGJhY2tncm91bmQ6IHJnYigyMjAsIDIyMCwgMjIwKTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgIGJveC1zaGFkb3c6IHJnYmEoMCwgMCwgMCwgMC4yNSkgMHB4IDBweCAwcHggMXB4LCByZ2JhKDAsIDAsIDAsIDAuMTUpIDBweCA4cHggMTZweDtcbiAgICAgIGJveC1zaXppbmc6IGluaXRpYWw7IHdpZHRoOiA1MTNweDtcbiAgICB9XG4gICAgLnBob3Rvc2hvcC1oZWFkIHtcbiAgICAgIGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudChcbiAgICAgICAgLTE4MGRlZyxcbiAgICAgICAgcmdiKDI0MCwgMjQwLCAyNDApIDAlLFxuICAgICAgICByZ2IoMjEyLCAyMTIsIDIxMikgMTAwJVxuICAgICAgKTtcbiAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2IoMTc3LCAxNzcsIDE3Nyk7XG4gICAgICBib3gtc2hhZG93OiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMikgMHB4IDFweCAwcHggMHB4IGluc2V0LFxuICAgICAgICByZ2JhKDAsIDAsIDAsIDAuMDIpIDBweCAtMXB4IDBweCAwcHggaW5zZXQ7XG4gICAgICBoZWlnaHQ6IDIzcHg7XG4gICAgICBsaW5lLWhlaWdodDogMjRweDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDRweCA0cHggMHB4IDBweDtcbiAgICAgIGZvbnQtc2l6ZTogMTNweDtcbiAgICAgIGNvbG9yOiByZ2IoNzcsIDc3LCA3Nyk7XG4gICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgfVxuICAgIC5waG90b3Nob3AtYm9keSB7XG4gICAgICBwYWRkaW5nOiAxNXB4IDE1cHggMHB4O1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICB9XG4gICAgLnBob3Rvc2hvcC1zYXR1cmF0aW9uIHtcbiAgICAgIHdpZHRoOiAyNTZweDtcbiAgICAgIGhlaWdodDogMjU2cHg7XG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICBib3JkZXItd2lkdGg6IDJweDtcbiAgICAgIGJvcmRlci1zdHlsZTogc29saWQ7XG4gICAgICBib3JkZXItY29sb3I6IHJnYigxNzksIDE3OSwgMTc5KSByZ2IoMTc5LCAxNzksIDE3OSkgcmdiKDI0MCwgMjQwLCAyNDApO1xuICAgICAgYm9yZGVyLWltYWdlOiBpbml0aWFsO1xuICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB9XG4gICAgLnBob3Rvc2hvcC1odWUge1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgaGVpZ2h0OiAyNTZweDtcbiAgICAgIHdpZHRoOiAyM3B4O1xuICAgICAgbWFyZ2luLWxlZnQ6IDEwcHg7XG4gICAgICBib3JkZXItd2lkdGg6IDJweDtcbiAgICAgIGJvcmRlci1zdHlsZTogc29saWQ7XG4gICAgICBib3JkZXItY29sb3I6IHJnYigxNzksIDE3OSwgMTc5KSByZ2IoMTc5LCAxNzksIDE3OSkgcmdiKDI0MCwgMjQwLCAyNDApO1xuICAgICAgYm9yZGVyLWltYWdlOiBpbml0aWFsO1xuICAgIH1cbiAgICAucGhvdG9zaG9wLWNvbnRyb2xzIHtcbiAgICAgIHdpZHRoOiAxODBweDtcbiAgICAgIG1hcmdpbi1sZWZ0OiAxMHB4O1xuICAgIH1cbiAgICAucGhvdG9zaG9wLXRvcCB7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgIH1cbiAgICAucGhvdG9zaG9wLXByZXZpZXdzIHtcbiAgICAgIHdpZHRoOiA2MHB4O1xuICAgIH1cbiAgICAucGhvdG9zaG9wLWFjdGlvbnMge1xuICAgICAgLXdlYmtpdC1ib3gtZmxleDogMTtcbiAgICAgIGZsZXg6IDEgMSAwJTtcbiAgICAgIG1hcmdpbi1sZWZ0OiAyMHB4O1xuICAgIH1cbiAgYCxcbiAgXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxufSlcbmV4cG9ydCBjbGFzcyBQaG90b3Nob3BDb21wb25lbnQgZXh0ZW5kcyBDb2xvcldyYXAge1xuICAvKiogVGl0bGUgdGV4dCAqL1xuICBASW5wdXQoKSBoZWFkZXIgPSAnQ29sb3IgUGlja2VyJztcbiAgQE91dHB1dCgpIG9uQWNjZXB0ID0gbmV3IEV2ZW50RW1pdHRlcjxFdmVudD4oKTtcbiAgQE91dHB1dCgpIG9uQ2FuY2VsID0gbmV3IEV2ZW50RW1pdHRlcjxFdmVudD4oKTtcbiAgY2lyY2xlID0ge1xuICAgIHdpZHRoOiAnMTJweCcsXG4gICAgaGVpZ2h0OiAnMTJweCcsXG4gICAgYm9yZGVyUmFkaXVzOiAnNnB4JyxcbiAgICBib3hTaGFkb3c6ICdyZ2IoMjU1LCAyNTUsIDI1NSkgMHB4IDBweCAwcHggMXB4IGluc2V0JyxcbiAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoLTZweCwgLTEwcHgpJyxcbiAgfTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuICBoYW5kbGVWYWx1ZUNoYW5nZSh7IGRhdGEsICRldmVudCB9KSB7XG4gICAgdGhpcy5oYW5kbGVDaGFuZ2UoZGF0YSwgJGV2ZW50KTtcbiAgfVxufVxuXG5ATmdNb2R1bGUoe1xuICBkZWNsYXJhdGlvbnM6IFtcbiAgICBQaG90b3Nob3BDb21wb25lbnQsXG4gICAgUGhvdG9zaG9wUHJldmlld3NDb21wb25lbnQsXG4gICAgUGhvdG9zaG9wQnV0dG9uQ29tcG9uZW50LFxuICAgIFBob3Rvc2hvcEZpZWxkc0NvbXBvbmVudCxcbiAgXSxcbiAgZXhwb3J0czogW1xuICAgIFBob3Rvc2hvcENvbXBvbmVudCxcbiAgICBQaG90b3Nob3BQcmV2aWV3c0NvbXBvbmVudCxcbiAgICBQaG90b3Nob3BCdXR0b25Db21wb25lbnQsXG4gICAgUGhvdG9zaG9wRmllbGRzQ29tcG9uZW50LFxuICBdLFxuICBpbXBvcnRzOiBbXG4gICAgQ29tbW9uTW9kdWxlLFxuICAgIEVkaXRhYmxlSW5wdXRNb2R1bGUsXG4gICAgSHVlTW9kdWxlLFxuICAgIEFscGhhTW9kdWxlLFxuICAgIFN3YXRjaE1vZHVsZSxcbiAgICBTYXR1cmF0aW9uTW9kdWxlLFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBDb2xvclBob3Rvc2hvcE1vZHVsZSB7fVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsTUE0Q2Esd0JBQXdCO0lBcENyQztRQXFDVyxVQUFLLEdBQUcsRUFBRSxDQUFDO1FBQ1gsV0FBTSxHQUFHLEtBQUssQ0FBQztRQUNkLFVBQUssR0FBRyxJQUFJLFlBQVksRUFBUyxDQUFDO0tBQzdDOzs7WUF4Q0EsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSx3QkFBd0I7Z0JBQ2xDLFFBQVEsRUFBRTs7Ozs7O0dBTVQ7Z0JBeUJELGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO2dCQUMvQyxtQkFBbUIsRUFBRSxLQUFLO3lCQXhCeEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFCRDthQUlGOzs7b0JBRUUsS0FBSztxQkFDTCxLQUFLO29CQUNMLE1BQU07Ozs7Ozs7QUMvQ1QsTUE0RmEsd0JBQXdCO0lBbEZyQztRQXNGWSxhQUFRLEdBQUcsSUFBSSxZQUFZLEVBQU8sQ0FBQztRQUM3QyxhQUFRLEdBQThCO1lBQ3BDLFVBQVUsRUFBRSxLQUFLO1lBQ2pCLEtBQUssRUFBRSxLQUFLO1lBQ1osTUFBTSxFQUFFLE1BQU07WUFDZCxNQUFNLEVBQUUsOEJBQThCO1lBQ3RDLFNBQVMsRUFDUCwwRUFBMEU7WUFDNUUsWUFBWSxFQUFFLEtBQUs7WUFDbkIsUUFBUSxFQUFFLE1BQU07WUFDaEIsV0FBVyxFQUFFLEtBQUs7WUFDbEIsV0FBVyxFQUFFLE1BQU07U0FDcEIsQ0FBQztRQUNGLFlBQU8sR0FBOEI7WUFDbkMsUUFBUSxFQUFFLFVBQVU7U0FDckIsQ0FBQztRQUNGLGFBQVEsR0FBOEI7WUFDcEMsSUFBSSxFQUFFLEtBQUs7WUFDWCxLQUFLLEVBQUUsTUFBTTtZQUNi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