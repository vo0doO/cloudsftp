(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('ngx-color'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('ngx-color/sketch', ['exports', '@angular/core', 'ngx-color', '@angular/common'], factory) :
    (factory((global['ngx-color'] = global['ngx-color'] || {}, global['ngx-color'].sketch = {}),global.ng.core,global['ngx-color'],global.ng.common));
}(this, (function (exports,core,ngxColor,common) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var SketchFieldsComponent = /** @class */ (function () {
        function SketchFieldsComponent() {
            this.disableAlpha = false;
            this.onChange = new core.EventEmitter();
            this.input = {
                width: '100%',
                padding: '4px 10% 3px',
                border: 'none',
                boxSizing: 'border-box',
                boxShadow: 'inset 0 0 0 1px #ccc',
                fontSize: '11px',
            };
            this.label = {
                display: 'block',
                textAlign: 'center',
                fontSize: '11px',
                color: '#222',
                paddingTop: '3px',
                paddingBottom: '4px',
                textTransform: 'capitalize',
            };
        }
        /**
         * @param {?} value
         * @return {?}
         */
        SketchFieldsComponent.prototype.round = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                return Math.round(value);
            };
        /**
         * @param {?} __0
         * @return {?}
         */
        SketchFieldsComponent.prototype.handleChange = /**
         * @param {?} __0
         * @return {?}
         */
            function (_a) {
                var data = _a.data, $event = _a.$event;
                if (data.hex) {
                    if (ngxColor.isValidHex(data.hex)) {
                        this.onChange.emit({
                            data: {
                                hex: data.hex,
                                source: 'hex',
                            },
                            $event: $event,
                        });
                    }
                }
                else if (data.r || data.g || data.b) {
                    this.onChange.emit({
                        data: {
                            r: data.r || this.rgb.r,
                            g: data.g || this.rgb.g,
                            b: data.b || this.rgb.b,
                            source: 'rgb',
                        },
                        $event: $event,
                    });
                }
                else if (data.a) {
                    if (data.a < 0) {
                        data.a = 0;
                    }
                    else if (data.a > 100) {
                        data.a = 100;
                    }
                    data.a /= 100;
                    this.onChange.emit({
                        data: {
                            h: this.hsl.h,
                            s: this.hsl.s,
                            l: this.hsl.l,
                            a: Math.round(data.a * 100) / 100,
                            source: 'rgb',
                        },
                        $event: $event,
                    });
                }
                else if (data.h || data.s || data.l) {
                    this.onChange.emit({
                        data: {
                            h: data.h || this.hsl.h,
                            s: Number((data.s && data.s) || this.hsl.s),
                            l: Number((data.l && data.l) || this.hsl.l),
                            source: 'hsl',
                        },
                        $event: $event,
                    });
                }
            };
        SketchFieldsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'color-sketch-fields',
                        template: "\n  <div class=\"sketch-fields\">\n    <div class=\"sketch-double\">\n      <color-editable-input\n        [style]=\"{ input: input, label: label }\"\n        label=\"hex\"\n        [value]=\"hex.replace('#', '')\"\n        (onChange)=\"handleChange($event)\"\n      ></color-editable-input>\n    </div>\n    <div class=\"sketch-single\">\n      <color-editable-input\n        [style]=\"{ input: input, label: label }\"\n        label=\"r\"\n        [value]=\"rgb.r\"\n        (onChange)=\"handleChange($event)\"\n        [dragLabel]=\"true\"\n        [dragMax]=\"255\"\n      ></color-editable-input>\n    </div>\n    <div class=\"sketch-single\">\n      <color-editable-input\n        [style]=\"{ input: input, label: label }\"\n        label=\"g\"\n        [value]=\"rgb.g\"\n        (onChange)=\"handleChange($event)\"\n        [dragLabel]=\"true\"\n        [dragMax]=\"255\"\n      ></color-editable-input>\n    </div>\n    <div class=\"sketch-single\">\n      <color-editable-input\n        [style]=\"{ input: input, label: label }\"\n        label=\"b\"\n        [value]=\"rgb.b\"\n        (onChange)=\"handleChange($event)\"\n        [dragLabel]=\"true\"\n        [dragMax]=\"255\"\n      ></color-editable-input>\n    </div>\n    <div class=\"sketch-alpha\" *ngIf=\"disableAlpha === false\">\n      <color-editable-input\n        [style]=\"{ input: input, label: label }\"\n        label=\"a\"\n        [value]=\"round(rgb.a * 100)\"\n        (onChange)=\"handleChange($event)\"\n        [dragLabel]=\"true\"\n        [dragMax]=\"100\"\n      ></color-editable-input>\n    </div>\n  </div>\n  ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        preserveWhitespaces: false,
                        styles: ["\n    .sketch-fields {\n      display: flex;\n      padding-top: 4px;\n    }\n    .sketch-double {\n      -webkit-box-flex: 2;\n      flex: 2 1 0%;\n    }\n    .sketch-single {\n      flex: 1 1 0%;\n      padding-left: 6px;\n    }\n    .sketch-alpha {\n      -webkit-box-flex: 1;\n      flex: 1 1 0%;\n      padding-left: 6px;\n    }\n  "]
                    }] }
        ];
        SketchFieldsComponent.propDecorators = {
            hsl: [{ type: core.Input }],
            rgb: [{ type: core.Input }],
            hex: [{ type: core.Input }],
            disableAlpha: [{ type: core.Input }],
            onChange: [{ type: core.Output }]
        };
        return SketchFieldsComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var SketchPresetColorsComponent = /** @class */ (function () {
        function SketchPresetColorsComponent() {
            this.onClick = new core.EventEmitter();
            this.onSwatchHover = new core.EventEmitter();
            this.swatchStyle = {
                borderRadius: '3px',
                boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.15)',
            };
        }
        /**
         * @param {?} __0
         * @return {?}
         */
        SketchPresetColorsComponent.prototype.handleClick = /**
         * @param {?} __0
         * @return {?}
         */
            function (_a) {
                var hex = _a.hex, $event = _a.$event;
                this.onClick.emit({ hex: hex, $event: $event });
            };
        /**
         * @param {?} val
         * @return {?}
         */
        SketchPresetColorsComponent.prototype.normalizeValue = /**
         * @param {?} val
         * @return {?}
         */
            function (val) {
                if (typeof val === 'string') {
                    return { color: val };
                }
                return val;
            };
        /**
         * @param {?} val
         * @return {?}
         */
        SketchPresetColorsComponent.prototype.focusStyle = /**
         * @param {?} val
         * @return {?}
         */
            function (val) {
                /** @type {?} */
                var c = this.normalizeValue(val);
                return {
                    boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15), 0 0 4px " + c.color,
                };
            };
        SketchPresetColorsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'color-sketch-preset-colors',
                        template: "\n  <div class=\"sketch-swatches\">\n    <div class=\"sketch-wrap\" *ngFor=\"let c of colors\">\n      <color-swatch\n        [color]=\"normalizeValue(c).color\"\n        [style]=\"swatchStyle\"\n        [focusStyle]=\"focusStyle(c)\"\n        (onClick)=\"handleClick($event)\"\n        (onHover)=\"onSwatchHover.emit($event)\"\n        class=\"swatch\"\n      ></color-swatch>\n    </div>\n  </div>\n  ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        preserveWhitespaces: false,
                        styles: ["\n    .sketch-swatches {\n      margin: 0px -10px;\n      padding: 10px 0px 0px 10px;\n      border-top: 1px solid rgb(238, 238, 238);\n      display: flex;\n      flex-wrap: wrap;\n      position: relative;\n    }\n    .sketch-wrap {\n      width: 16px;\n      height: 16px;\n      margin: 0px 10px 10px 0px;\n    }\n  "]
                    }] }
        ];
        SketchPresetColorsComponent.propDecorators = {
            colors: [{ type: core.Input }],
            onClick: [{ type: core.Output }],
            onSwatchHover: [{ type: core.Output }]
        };
        return SketchPresetColorsComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var SketchComponent = /** @class */ (function (_super) {
        __extends(SketchComponent, _super);
        function SketchComponent() {
            var _this = _super.call(this) || this;
            /**
             * Remove alpha slider and options from picker
             */
            _this.disableAlpha = false;
            /**
             * Hex strings for default colors at bottom of picker
             */
            _this.presetColors = [
                '#D0021B',
                '#F5A623',
                '#F8E71C',
                '#8B572A',
                '#7ED321',
                '#417505',
                '#BD10E0',
                '#9013FE',
                '#4A90E2',
                '#50E3C2',
                '#B8E986',
                '#000000',
                '#4A4A4A',
                '#9B9B9B',
                '#FFFFFF',
            ];
            /**
             * Width of picker
             */
            _this.width = 200;
            return _this;
        }
        /**
         * @return {?}
         */
        SketchComponent.prototype.afterValidChange = /**
         * @return {?}
         */
            function () {
                this.activeBackground = "rgba(" + this.rgb.r + ", " + this.rgb.g + ", " + this.rgb.b + ", " + this.rgb.a + ")";
            };
        /**
         * @param {?} __0
         * @return {?}
         */
        SketchComponent.prototype.handleValueChange = /**
         * @param {?} __0
         * @return {?}
         */
            function (_a) {
                var data = _a.data, $event = _a.$event;
                this.handleChange(data, $event);
            };
        /**
         * @param {?} __0
         * @return {?}
         */
        SketchComponent.prototype.handleBlockChange = /**
         * @param {?} __0
         * @return {?}
         */
            function (_a) {
                var hex = _a.hex, $event = _a.$event;
                if (ngxColor.isValidHex(hex)) {
                    // this.hex = hex;
                    this.handleChange({
                        hex: hex,
                        source: 'hex',
                    }, $event);
                }
            };
        SketchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'color-sketch',
                        template: "\n  <div class=\"sketch-picker {{ className }}\" [style.width]=\"width\">\n    <div class=\"sketch-saturation\">\n      <color-saturation [hsl]=\"hsl\" [hsv]=\"hsv\"\n        (onChange)=\"handleValueChange($event)\"\n      >\n      </color-saturation>\n    </div>\n    <div class=\"sketch-controls\">\n      <div class=\"sketch-sliders\">\n        <div class=\"sketch-hue\">\n          <color-hue [hsl]=\"hsl\"\n            (onChange)=\"handleValueChange($event)\"\n          ></color-hue>\n        </div>\n        <div class=\"sketch-alpha\">\n          <color-alpha\n            [radius]=\"2\" [rgb]=\"rgb\" [hsl]=\"hsl\"\n            (onChange)=\"handleValueChange($event)\"\n          ></color-alpha>\n        </div>\n      </div>\n      <div class=\"sketch-color\">\n        <color-checkboard></color-checkboard>\n        <div class=\"sketch-active\" [style.background]=\"activeBackground\"></div>\n      </div>\n    </div>\n    <div class=\"sketch-controls\">\n      <color-sketch-fields\n        [rgb]=\"rgb\" [hsl]=\"hsl\" [hex]=\"hex\"\n        [disableAlpha]=\"disableAlpha\"\n        (onChange)=\"handleValueChange($event)\"\n      ></color-sketch-fields>\n    </div>\n    <div class=\"sketch-controls\">\n      <color-sketch-preset-colors\n        [colors]=\"presetColors\"\n        (onClick)=\"handleBlockChange($event)\"\n        (onSwatchHover)=\"onSwatchHover.emit($event)\"\n      ></color-sketch-preset-colors>\n    </div>\n  </div>\n  ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        preserveWhitespaces: false,
                        styles: ["\n    .sketch-picker {\n      padding: 10px 10px 0;\n      box-sizing: initial;\n      background: #fff;\n      border-radius: 4px;\n      box-shadow: 0 0 0 1px rgba(0,0,0,.15), 0 8px 16px rgba(0,0,0,.15);\n    }\n    .sketch-saturation {\n      width: 100%;\n      padding-bottom: 75%;\n      position: relative;\n      overflow: hidden;\n    }\n    .sketch-controls {\n      display: flex;\n    }\n    .sketch-sliders {\n      padding: 4px 0px;\n      -webkit-box-flex: 1;\n      flex: 1 1 0%;\n    }\n    .sketch-hue {\n      position: relative;\n      height: 10px;\n      overflow: hidden;\n    }\n    .sketch-alpha {\n      position: relative;\n      height: 10px;\n      margin-top: 4px;\n      overflow: hidden;\n    }\n    .sketch-color {\n      width: 24px;\n      height: 24px;\n      position: relative;\n      margin-top: 4px;\n      margin-left: 4px;\n      border-radius: 3px;\n    }\n    .sketch-active {\n      position: absolute;\n      top: 0px;\n      right: 0px;\n      bottom: 0px;\n      left: 0px;\n      border-radius: 2px;\n      box-shadow: rgba(0, 0, 0, 0.15) 0px 0px 0px 1px inset, rgba(0, 0, 0, 0.25) 0px 0px 4px inset;\n    }\n  "]
                    }] }
        ];
        /** @nocollapse */
        SketchComponent.ctorParameters = function () { return []; };
        SketchComponent.propDecorators = {
            disableAlpha: [{ type: core.Input }],
            presetColors: [{ type: core.Input }],
            width: [{ type: core.Input }]
        };
        return SketchComponent;
    }(ngxColor.ColorWrap));
    var ColorSketchModule = /** @class */ (function () {
        function ColorSketchModule() {
        }
        ColorSketchModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            SketchComponent,
                            SketchFieldsComponent,
                            SketchPresetColorsComponent,
                        ],
                        exports: [
                            SketchComponent,
                            SketchFieldsComponent,
                            SketchPresetColorsComponent,
                        ],
                        imports: [
                            common.CommonModule,
                            ngxColor.AlphaModule,
                            ngxColor.CheckboardModule,
                            ngxColor.EditableInputModule,
                            ngxColor.HueModule,
                            ngxColor.SaturationModule,
                            ngxColor.SwatchModule,
                        ],
                    },] }
        ];
        return ColorSketchModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    exports.SketchComponent = SketchComponent;
    exports.ColorSketchModule = ColorSketchModule;
    exports.ɵa = SketchFieldsComponent;
    exports.ɵb = SketchPresetColorsComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWNvbG9yLXNrZXRjaC51bWQuanMubWFwIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwibmc6Ly9uZ3gtY29sb3Ivc2tldGNoL3NrZXRjaC1maWVsZHMuY29tcG9uZW50LnRzIiwibmc6Ly9uZ3gtY29sb3Ivc2tldGNoL3NrZXRjaC1wcmVzZXQtY29sb3JzLmNvbXBvbmVudC50cyIsIm5nOi8vbmd4LWNvbG9yL3NrZXRjaC9za2V0Y2guY29tcG9uZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMClcclxuICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuIiwiaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT3V0cHV0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgaXNWYWxpZEhleCwgSFNMQSwgUkdCQSB9IGZyb20gJ25neC1jb2xvcic7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2NvbG9yLXNrZXRjaC1maWVsZHMnLFxuICB0ZW1wbGF0ZTogYFxuICA8ZGl2IGNsYXNzPVwic2tldGNoLWZpZWxkc1wiPlxuICAgIDxkaXYgY2xhc3M9XCJza2V0Y2gtZG91YmxlXCI+XG4gICAgICA8Y29sb3ItZWRpdGFibGUtaW5wdXRcbiAgICAgICAgW3N0eWxlXT1cInsgaW5wdXQ6IGlucHV0LCBsYWJlbDogbGFiZWwgfVwiXG4gICAgICAgIGxhYmVsPVwiaGV4XCJcbiAgICAgICAgW3ZhbHVlXT1cImhleC5yZXBsYWNlKCcjJywgJycpXCJcbiAgICAgICAgKG9uQ2hhbmdlKT1cImhhbmRsZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgID48L2NvbG9yLWVkaXRhYmxlLWlucHV0PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJza2V0Y2gtc2luZ2xlXCI+XG4gICAgICA8Y29sb3ItZWRpdGFibGUtaW5wdXRcbiAgICAgICAgW3N0eWxlXT1cInsgaW5wdXQ6IGlucHV0LCBsYWJlbDogbGFiZWwgfVwiXG4gICAgICAgIGxhYmVsPVwiclwiXG4gICAgICAgIFt2YWx1ZV09XCJyZ2IuclwiXG4gICAgICAgIChvbkNoYW5nZSk9XCJoYW5kbGVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgIFtkcmFnTGFiZWxdPVwidHJ1ZVwiXG4gICAgICAgIFtkcmFnTWF4XT1cIjI1NVwiXG4gICAgICA+PC9jb2xvci1lZGl0YWJsZS1pbnB1dD5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwic2tldGNoLXNpbmdsZVwiPlxuICAgICAgPGNvbG9yLWVkaXRhYmxlLWlucHV0XG4gICAgICAgIFtzdHlsZV09XCJ7IGlucHV0OiBpbnB1dCwgbGFiZWw6IGxhYmVsIH1cIlxuICAgICAgICBsYWJlbD1cImdcIlxuICAgICAgICBbdmFsdWVdPVwicmdiLmdcIlxuICAgICAgICAob25DaGFuZ2UpPVwiaGFuZGxlQ2hhbmdlKCRldmVudClcIlxuICAgICAgICBbZHJhZ0xhYmVsXT1cInRydWVcIlxuICAgICAgICBbZHJhZ01heF09XCIyNTVcIlxuICAgICAgPjwvY29sb3ItZWRpdGFibGUtaW5wdXQ+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInNrZXRjaC1zaW5nbGVcIj5cbiAgICAgIDxjb2xvci1lZGl0YWJsZS1pbnB1dFxuICAgICAgICBbc3R5bGVdPVwieyBpbnB1dDogaW5wdXQsIGxhYmVsOiBsYWJlbCB9XCJcbiAgICAgICAgbGFiZWw9XCJiXCJcbiAgICAgICAgW3ZhbHVlXT1cInJnYi5iXCJcbiAgICAgICAgKG9uQ2hhbmdlKT1cImhhbmRsZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgW2RyYWdMYWJlbF09XCJ0cnVlXCJcbiAgICAgICAgW2RyYWdNYXhdPVwiMjU1XCJcbiAgICAgID48L2NvbG9yLWVkaXRhYmxlLWlucHV0PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJza2V0Y2gtYWxwaGFcIiAqbmdJZj1cImRpc2FibGVBbHBoYSA9PT0gZmFsc2VcIj5cbiAgICAgIDxjb2xvci1lZGl0YWJsZS1pbnB1dFxuICAgICAgICBbc3R5bGVdPVwieyBpbnB1dDogaW5wdXQsIGxhYmVsOiBsYWJlbCB9XCJcbiAgICAgICAgbGFiZWw9XCJhXCJcbiAgICAgICAgW3ZhbHVlXT1cInJvdW5kKHJnYi5hICogMTAwKVwiXG4gICAgICAgIChvbkNoYW5nZSk9XCJoYW5kbGVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgIFtkcmFnTGFiZWxdPVwidHJ1ZVwiXG4gICAgICAgIFtkcmFnTWF4XT1cIjEwMFwiXG4gICAgICA+PC9jb2xvci1lZGl0YWJsZS1pbnB1dD5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4gIGAsXG4gIHN0eWxlczogW1xuICAgIGBcbiAgICAuc2tldGNoLWZpZWxkcyB7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgcGFkZGluZy10b3A6IDRweDtcbiAgICB9XG4gICAgLnNrZXRjaC1kb3VibGUge1xuICAgICAgLXdlYmtpdC1ib3gtZmxleDogMjtcbiAgICAgIGZsZXg6IDIgMSAwJTtcbiAgICB9XG4gICAgLnNrZXRjaC1zaW5nbGUge1xuICAgICAgZmxleDogMSAxIDAlO1xuICAgICAgcGFkZGluZy1sZWZ0OiA2cHg7XG4gICAgfVxuICAgIC5za2V0Y2gtYWxwaGEge1xuICAgICAgLXdlYmtpdC1ib3gtZmxleDogMTtcbiAgICAgIGZsZXg6IDEgMSAwJTtcbiAgICAgIHBhZGRpbmctbGVmdDogNnB4O1xuICAgIH1cbiAgYCxcbiAgXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxufSlcbmV4cG9ydCBjbGFzcyBTa2V0Y2hGaWVsZHNDb21wb25lbnQge1xuICBASW5wdXQoKSBoc2w6IEhTTEE7XG4gIEBJbnB1dCgpIHJnYjogUkdCQTtcbiAgQElucHV0KCkgaGV4OiBzdHJpbmc7XG4gIEBJbnB1dCgpIGRpc2FibGVBbHBoYSA9IGZhbHNlO1xuICBAT3V0cHV0KCkgb25DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgaW5wdXQ6IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9ID0ge1xuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgcGFkZGluZzogJzRweCAxMCUgM3B4JyxcbiAgICBib3JkZXI6ICdub25lJyxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICBib3hTaGFkb3c6ICdpbnNldCAwIDAgMCAxcHggI2NjYycsXG4gICAgZm9udFNpemU6ICcxMXB4JyxcbiAgfTtcbiAgbGFiZWw6IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9ID0ge1xuICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICBmb250U2l6ZTogJzExcHgnLFxuICAgIGNvbG9yOiAnIzIyMicsXG4gICAgcGFkZGluZ1RvcDogJzNweCcsXG4gICAgcGFkZGluZ0JvdHRvbTogJzRweCcsXG4gICAgdGV4dFRyYW5zZm9ybTogJ2NhcGl0YWxpemUnLFxuICB9O1xuXG4gIHJvdW5kKHZhbHVlKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpO1xuICB9XG4gIGhhbmRsZUNoYW5nZSh7IGRhdGEsICRldmVudCB9KSB7XG4gICAgaWYgKGRhdGEuaGV4KSB7XG4gICAgICBpZiAoaXNWYWxpZEhleChkYXRhLmhleCkpIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZS5lbWl0KHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBoZXg6IGRhdGEuaGV4LFxuICAgICAgICAgICAgc291cmNlOiAnaGV4JyxcbiAgICAgICAgICB9LFxuICAgICAgICAgICRldmVudCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhLnIgfHwgZGF0YS5nIHx8IGRhdGEuYikge1xuICAgICAgdGhpcy5vbkNoYW5nZS5lbWl0KHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHI6IGRhdGEuciB8fCB0aGlzLnJnYi5yLFxuICAgICAgICAgIGc6IGRhdGEuZyB8fCB0aGlzLnJnYi5nLFxuICAgICAgICAgIGI6IGRhdGEuYiB8fCB0aGlzLnJnYi5iLFxuICAgICAgICAgIHNvdXJjZTogJ3JnYicsXG4gICAgICAgIH0sXG4gICAgICAgICRldmVudCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5hKSB7XG4gICAgICBpZiAoZGF0YS5hIDwgMCkge1xuICAgICAgICBkYXRhLmEgPSAwO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLmEgPiAxMDApIHtcbiAgICAgICAgZGF0YS5hID0gMTAwO1xuICAgICAgfVxuICAgICAgZGF0YS5hIC89IDEwMDtcblxuICAgICAgdGhpcy5vbkNoYW5nZS5lbWl0KHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGg6IHRoaXMuaHNsLmgsXG4gICAgICAgICAgczogdGhpcy5oc2wucyxcbiAgICAgICAgICBsOiB0aGlzLmhzbC5sLFxuICAgICAgICAgIGE6IE1hdGgucm91bmQoZGF0YS5hICogMTAwKSAvIDEwMCxcbiAgICAgICAgICBzb3VyY2U6ICdyZ2InLFxuICAgICAgICB9LFxuICAgICAgICAkZXZlbnQsXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuaCB8fCBkYXRhLnMgfHwgZGF0YS5sKSB7XG4gICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaDogZGF0YS5oIHx8IHRoaXMuaHNsLmgsXG4gICAgICAgICAgczogTnVtYmVyKChkYXRhLnMgJiYgZGF0YS5zKSB8fCB0aGlzLmhzbC5zKSxcbiAgICAgICAgICBsOiBOdW1iZXIoKGRhdGEubCAmJiBkYXRhLmwpIHx8IHRoaXMuaHNsLmwpLFxuICAgICAgICAgIHNvdXJjZTogJ2hzbCcsXG4gICAgICAgIH0sXG4gICAgICAgICRldmVudCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT3V0cHV0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICduZ3gtY29sb3InO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjb2xvci1za2V0Y2gtcHJlc2V0LWNvbG9ycycsXG4gIHRlbXBsYXRlOiBgXG4gIDxkaXYgY2xhc3M9XCJza2V0Y2gtc3dhdGNoZXNcIj5cbiAgICA8ZGl2IGNsYXNzPVwic2tldGNoLXdyYXBcIiAqbmdGb3I9XCJsZXQgYyBvZiBjb2xvcnNcIj5cbiAgICAgIDxjb2xvci1zd2F0Y2hcbiAgICAgICAgW2NvbG9yXT1cIm5vcm1hbGl6ZVZhbHVlKGMpLmNvbG9yXCJcbiAgICAgICAgW3N0eWxlXT1cInN3YXRjaFN0eWxlXCJcbiAgICAgICAgW2ZvY3VzU3R5bGVdPVwiZm9jdXNTdHlsZShjKVwiXG4gICAgICAgIChvbkNsaWNrKT1cImhhbmRsZUNsaWNrKCRldmVudClcIlxuICAgICAgICAob25Ib3Zlcik9XCJvblN3YXRjaEhvdmVyLmVtaXQoJGV2ZW50KVwiXG4gICAgICAgIGNsYXNzPVwic3dhdGNoXCJcbiAgICAgID48L2NvbG9yLXN3YXRjaD5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4gIGAsXG4gIHN0eWxlczogW1xuICAgIGBcbiAgICAuc2tldGNoLXN3YXRjaGVzIHtcbiAgICAgIG1hcmdpbjogMHB4IC0xMHB4O1xuICAgICAgcGFkZGluZzogMTBweCAwcHggMHB4IDEwcHg7XG4gICAgICBib3JkZXItdG9wOiAxcHggc29saWQgcmdiKDIzOCwgMjM4LCAyMzgpO1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB9XG4gICAgLnNrZXRjaC13cmFwIHtcbiAgICAgIHdpZHRoOiAxNnB4O1xuICAgICAgaGVpZ2h0OiAxNnB4O1xuICAgICAgbWFyZ2luOiAwcHggMTBweCAxMHB4IDBweDtcbiAgICB9XG4gIGAsXG4gIF0sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZSxcbn0pXG5leHBvcnQgY2xhc3MgU2tldGNoUHJlc2V0Q29sb3JzQ29tcG9uZW50IHtcbiAgQElucHV0KCkgY29sb3JzOiBzdHJpbmdbXSB8IFNoYXBlW107XG4gIEBPdXRwdXQoKSBvbkNsaWNrID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG4gIEBPdXRwdXQoKSBvblN3YXRjaEhvdmVyID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG4gIHN3YXRjaFN0eWxlID0ge1xuICAgIGJvcmRlclJhZGl1czogJzNweCcsXG4gICAgYm94U2hhZG93OiAnaW5zZXQgMCAwIDAgMXB4IHJnYmEoMCwwLDAsLjE1KScsXG4gIH07XG5cbiAgaGFuZGxlQ2xpY2soeyBoZXgsICRldmVudCB9KSB7XG4gICAgdGhpcy5vbkNsaWNrLmVtaXQoeyBoZXgsICRldmVudCB9KTtcbiAgfVxuICBub3JtYWxpemVWYWx1ZSh2YWw6IHN0cmluZyB8IFNoYXBlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4geyBjb2xvcjogdmFsIH07XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgZm9jdXNTdHlsZSh2YWw6IHN0cmluZyB8IFNoYXBlKSB7XG4gICAgY29uc3QgYyA9IHRoaXMubm9ybWFsaXplVmFsdWUodmFsKTtcbiAgICByZXR1cm4ge1xuICAgICAgYm94U2hhZG93OiBgaW5zZXQgMCAwIDAgMXB4IHJnYmEoMCwwLDAsLjE1KSwgMCAwIDRweCAke2MuY29sb3J9YCxcbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgSW5wdXQsXG4gIE5nTW9kdWxlLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHtcbiAgQWxwaGFNb2R1bGUsXG4gIENoZWNrYm9hcmRNb2R1bGUsXG4gIENvbG9yV3JhcCxcbiAgRWRpdGFibGVJbnB1dE1vZHVsZSxcbiAgSHVlTW9kdWxlLFxuICBTYXR1cmF0aW9uTW9kdWxlLFxuICBTd2F0Y2hNb2R1bGUsXG59IGZyb20gJ25neC1jb2xvcic7XG5pbXBvcnQgeyBpc1ZhbGlkSGV4IH0gZnJvbSAnbmd4LWNvbG9yJztcbmltcG9ydCB7IFNrZXRjaEZpZWxkc0NvbXBvbmVudCB9IGZyb20gJy4vc2tldGNoLWZpZWxkcy5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2tldGNoUHJlc2V0Q29sb3JzQ29tcG9uZW50IH0gZnJvbSAnLi9za2V0Y2gtcHJlc2V0LWNvbG9ycy5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjb2xvci1za2V0Y2gnLFxuICB0ZW1wbGF0ZTogYFxuICA8ZGl2IGNsYXNzPVwic2tldGNoLXBpY2tlciB7eyBjbGFzc05hbWUgfX1cIiBbc3R5bGUud2lkdGhdPVwid2lkdGhcIj5cbiAgICA8ZGl2IGNsYXNzPVwic2tldGNoLXNhdHVyYXRpb25cIj5cbiAgICAgIDxjb2xvci1zYXR1cmF0aW9uIFtoc2xdPVwiaHNsXCIgW2hzdl09XCJoc3ZcIlxuICAgICAgICAob25DaGFuZ2UpPVwiaGFuZGxlVmFsdWVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICA+XG4gICAgICA8L2NvbG9yLXNhdHVyYXRpb24+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInNrZXRjaC1jb250cm9sc1wiPlxuICAgICAgPGRpdiBjbGFzcz1cInNrZXRjaC1zbGlkZXJzXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJza2V0Y2gtaHVlXCI+XG4gICAgICAgICAgPGNvbG9yLWh1ZSBbaHNsXT1cImhzbFwiXG4gICAgICAgICAgICAob25DaGFuZ2UpPVwiaGFuZGxlVmFsdWVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgPjwvY29sb3ItaHVlPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNrZXRjaC1hbHBoYVwiPlxuICAgICAgICAgIDxjb2xvci1hbHBoYVxuICAgICAgICAgICAgW3JhZGl1c109XCIyXCIgW3JnYl09XCJyZ2JcIiBbaHNsXT1cImhzbFwiXG4gICAgICAgICAgICAob25DaGFuZ2UpPVwiaGFuZGxlVmFsdWVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgPjwvY29sb3ItYWxwaGE+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwic2tldGNoLWNvbG9yXCI+XG4gICAgICAgIDxjb2xvci1jaGVja2JvYXJkPjwvY29sb3ItY2hlY2tib2FyZD5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNrZXRjaC1hY3RpdmVcIiBbc3R5bGUuYmFja2dyb3VuZF09XCJhY3RpdmVCYWNrZ3JvdW5kXCI+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwic2tldGNoLWNvbnRyb2xzXCI+XG4gICAgICA8Y29sb3Itc2tldGNoLWZpZWxkc1xuICAgICAgICBbcmdiXT1cInJnYlwiIFtoc2xdPVwiaHNsXCIgW2hleF09XCJoZXhcIlxuICAgICAgICBbZGlzYWJsZUFscGhhXT1cImRpc2FibGVBbHBoYVwiXG4gICAgICAgIChvbkNoYW5nZSk9XCJoYW5kbGVWYWx1ZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgID48L2NvbG9yLXNrZXRjaC1maWVsZHM+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInNrZXRjaC1jb250cm9sc1wiPlxuICAgICAgPGNvbG9yLXNrZXRjaC1wcmVzZXQtY29sb3JzXG4gICAgICAgIFtjb2xvcnNdPVwicHJlc2V0Q29sb3JzXCJcbiAgICAgICAgKG9uQ2xpY2spPVwiaGFuZGxlQmxvY2tDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgIChvblN3YXRjaEhvdmVyKT1cIm9uU3dhdGNoSG92ZXIuZW1pdCgkZXZlbnQpXCJcbiAgICAgID48L2NvbG9yLXNrZXRjaC1wcmVzZXQtY29sb3JzPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbiAgYCxcbiAgc3R5bGVzOiBbXG4gICAgYFxuICAgIC5za2V0Y2gtcGlja2VyIHtcbiAgICAgIHBhZGRpbmc6IDEwcHggMTBweCAwO1xuICAgICAgYm94LXNpemluZzogaW5pdGlhbDtcbiAgICAgIGJhY2tncm91bmQ6ICNmZmY7XG4gICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICBib3gtc2hhZG93OiAwIDAgMCAxcHggcmdiYSgwLDAsMCwuMTUpLCAwIDhweCAxNnB4IHJnYmEoMCwwLDAsLjE1KTtcbiAgICB9XG4gICAgLnNrZXRjaC1zYXR1cmF0aW9uIHtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgcGFkZGluZy1ib3R0b206IDc1JTtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgfVxuICAgIC5za2V0Y2gtY29udHJvbHMge1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICB9XG4gICAgLnNrZXRjaC1zbGlkZXJzIHtcbiAgICAgIHBhZGRpbmc6IDRweCAwcHg7XG4gICAgICAtd2Via2l0LWJveC1mbGV4OiAxO1xuICAgICAgZmxleDogMSAxIDAlO1xuICAgIH1cbiAgICAuc2tldGNoLWh1ZSB7XG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICBoZWlnaHQ6IDEwcHg7XG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIH1cbiAgICAuc2tldGNoLWFscGhhIHtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIGhlaWdodDogMTBweDtcbiAgICAgIG1hcmdpbi10b3A6IDRweDtcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgfVxuICAgIC5za2V0Y2gtY29sb3Ige1xuICAgICAgd2lkdGg6IDI0cHg7XG4gICAgICBoZWlnaHQ6IDI0cHg7XG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICBtYXJnaW4tdG9wOiA0cHg7XG4gICAgICBtYXJnaW4tbGVmdDogNHB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgIH1cbiAgICAuc2tldGNoLWFjdGl2ZSB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB0b3A6IDBweDtcbiAgICAgIHJpZ2h0OiAwcHg7XG4gICAgICBib3R0b206IDBweDtcbiAgICAgIGxlZnQ6IDBweDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICAgIGJveC1zaGFkb3c6IHJnYmEoMCwgMCwgMCwgMC4xNSkgMHB4IDBweCAwcHggMXB4IGluc2V0LCByZ2JhKDAsIDAsIDAsIDAuMjUpIDBweCAwcHggNHB4IGluc2V0O1xuICAgIH1cbiAgYCxcbiAgXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxufSlcbmV4cG9ydCBjbGFzcyBTa2V0Y2hDb21wb25lbnQgZXh0ZW5kcyBDb2xvcldyYXAge1xuICAvKiogUmVtb3ZlIGFscGhhIHNsaWRlciBhbmQgb3B0aW9ucyBmcm9tIHBpY2tlciAqL1xuICBASW5wdXQoKSBkaXNhYmxlQWxwaGEgPSBmYWxzZTtcbiAgLyoqIEhleCBzdHJpbmdzIGZvciBkZWZhdWx0IGNvbG9ycyBhdCBib3R0b20gb2YgcGlja2VyICovXG4gIEBJbnB1dCgpIHByZXNldENvbG9ycyA9IFtcbiAgICAnI0QwMDIxQicsXG4gICAgJyNGNUE2MjMnLFxuICAgICcjRjhFNzFDJyxcbiAgICAnIzhCNTcyQScsXG4gICAgJyM3RUQzMjEnLFxuICAgICcjNDE3NTA1JyxcbiAgICAnI0JEMTBFMCcsXG4gICAgJyM5MDEzRkUnLFxuICAgICcjNEE5MEUyJyxcbiAgICAnIzUwRTNDMicsXG4gICAgJyNCOEU5ODYnLFxuICAgICcjMDAwMDAwJyxcbiAgICAnIzRBNEE0QScsXG4gICAgJyM5QjlCOUInLFxuICAgICcjRkZGRkZGJyxcbiAgXTtcbiAgLyoqIFdpZHRoIG9mIHBpY2tlciAqL1xuICBASW5wdXQoKSB3aWR0aCA9IDIwMDtcbiAgYWN0aXZlQmFja2dyb3VuZDogc3RyaW5nO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG4gIGFmdGVyVmFsaWRDaGFuZ2UoKSB7XG4gICAgdGhpcy5hY3RpdmVCYWNrZ3JvdW5kID0gYHJnYmEoJHt0aGlzLnJnYi5yfSwgJHt0aGlzLnJnYi5nfSwgJHt0aGlzLnJnYi5ifSwgJHt0aGlzLnJnYi5hfSlgO1xuICB9XG4gIGhhbmRsZVZhbHVlQ2hhbmdlKHsgZGF0YSwgJGV2ZW50IH0pIHtcbiAgICB0aGlzLmhhbmRsZUNoYW5nZShkYXRhLCAkZXZlbnQpO1xuICB9XG4gIGhhbmRsZUJsb2NrQ2hhbmdlKHsgaGV4LCAkZXZlbnQgfSkge1xuICAgIGlmIChpc1ZhbGlkSGV4KGhleCkpIHtcbiAgICAgIC8vIHRoaXMuaGV4ID0gaGV4O1xuICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UoXG4gICAgICAgIHtcbiAgICAgICAgICBoZXgsXG4gICAgICAgICAgc291cmNlOiAnaGV4JyxcbiAgICAgICAgfSxcbiAgICAgICAgJGV2ZW50LFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuQE5nTW9kdWxlKHtcbiAgZGVjbGFyYXRpb25zOiBbXG4gICAgU2tldGNoQ29tcG9uZW50LFxuICAgIFNrZXRjaEZpZWxkc0NvbXBvbmVudCxcbiAgICBTa2V0Y2hQcmVzZXRDb2xvcnNDb21wb25lbnQsXG4gIF0sXG4gIGV4cG9ydHM6IFtcbiAgICBTa2V0Y2hDb21wb25lbnQsXG4gICAgU2tldGNoRmllbGRzQ29tcG9uZW50LFxuICAgIFNrZXRjaFByZXNldENvbG9yc0NvbXBvbmVudCxcbiAgXSxcbiAgaW1wb3J0czogW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBBbHBoYU1vZHVsZSxcbiAgICBDaGVja2JvYXJkTW9kdWxlLFxuICAgIEVkaXRhYmxlSW5wdXRNb2R1bGUsXG4gICAgSHVlTW9kdWxlLFxuICAgIFNhdHVyYXRpb25Nb2R1bGUsXG4gICAgU3dhdGNoTW9kdWxlLFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBDb2xvclNrZXRjaE1vZHVsZSB7fVxuIl0sIm5hbWVzIjpbIkV2ZW50RW1pdHRlciIsImlzVmFsaWRIZXgiLCJDb21wb25lbnQiLCJDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSIsIklucHV0IiwiT3V0cHV0IiwidHNsaWJfMS5fX2V4dGVuZHMiLCJDb2xvcldyYXAiLCJOZ01vZHVsZSIsIkNvbW1vbk1vZHVsZSIsIkFscGhhTW9kdWxlIiwiQ2hlY2tib2FyZE1vZHVsZSIsIkVkaXRhYmxlSW5wdXRNb2R1bGUiLCJIdWVNb2R1bGUiLCJTYXR1cmF0aW9u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