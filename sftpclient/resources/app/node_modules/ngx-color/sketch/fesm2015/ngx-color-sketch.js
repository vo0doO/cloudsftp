import { ChangeDetectionStrategy, Component, EventEmitter, Input, Output, NgModule } from '@angular/core';
import { isValidHex, AlphaModule, CheckboardModule, ColorWrap, EditableInputModule, HueModule, SaturationModule, SwatchModule } from 'ngx-color';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SketchFieldsComponent {
    constructor() {
        this.disableAlpha = false;
        this.onChange = new EventEmitter();
        this.input = {
            width: '100%',
            padding: '4px 10% 3px',
            border: 'none',
            boxSizing: 'border-box',
            boxShadow: 'inset 0 0 0 1px #ccc',
            fontSize: '11px',
        };
        this.label = {
            display: 'block',
            textAlign: 'center',
            fontSize: '11px',
            color: '#222',
            paddingTop: '3px',
            paddingBottom: '4px',
            textTransform: 'capitalize',
        };
    }
    /**
     * @param {?} value
     * @return {?}
     */
    round(value) {
        return Math.round(value);
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    handleChange({ data, $event }) {
        if (data.hex) {
            if (isValidHex(data.hex)) {
                this.onChange.emit({
                    data: {
                        hex: data.hex,
                        source: 'hex',
                    },
                    $event,
                });
            }
        }
        else if (data.r || data.g || data.b) {
            this.onChange.emit({
                data: {
                    r: data.r || this.rgb.r,
                    g: data.g || this.rgb.g,
                    b: data.b || this.rgb.b,
                    source: 'rgb',
                },
                $event,
            });
        }
        else if (data.a) {
            if (data.a < 0) {
                data.a = 0;
            }
            else if (data.a > 100) {
                data.a = 100;
            }
            data.a /= 100;
            this.onChange.emit({
                data: {
                    h: this.hsl.h,
                    s: this.hsl.s,
                    l: this.hsl.l,
                    a: Math.round(data.a * 100) / 100,
                    source: 'rgb',
                },
                $event,
            });
        }
        else if (data.h || data.s || data.l) {
            this.onChange.emit({
                data: {
                    h: data.h || this.hsl.h,
                    s: Number((data.s && data.s) || this.hsl.s),
                    l: Number((data.l && data.l) || this.hsl.l),
                    source: 'hsl',
                },
                $event,
            });
        }
    }
}
SketchFieldsComponent.decorators = [
    { type: Component, args: [{
                selector: 'color-sketch-fields',
                template: `
  <div class="sketch-fields">
    <div class="sketch-double">
      <color-editable-input
        [style]="{ input: input, label: label }"
        label="hex"
        [value]="hex.replace('#', '')"
        (onChange)="handleChange($event)"
      ></color-editable-input>
    </div>
    <div class="sketch-single">
      <color-editable-input
        [style]="{ input: input, label: label }"
        label="r"
        [value]="rgb.r"
        (onChange)="handleChange($event)"
        [dragLabel]="true"
        [dragMax]="255"
      ></color-editable-input>
    </div>
    <div class="sketch-single">
      <color-editable-input
        [style]="{ input: input, label: label }"
        label="g"
        [value]="rgb.g"
        (onChange)="handleChange($event)"
        [dragLabel]="true"
        [dragMax]="255"
      ></color-editable-input>
    </div>
    <div class="sketch-single">
      <color-editable-input
        [style]="{ input: input, label: label }"
        label="b"
        [value]="rgb.b"
        (onChange)="handleChange($event)"
        [dragLabel]="true"
        [dragMax]="255"
      ></color-editable-input>
    </div>
    <div class="sketch-alpha" *ngIf="disableAlpha === false">
      <color-editable-input
        [style]="{ input: input, label: label }"
        label="a"
        [value]="round(rgb.a * 100)"
        (onChange)="handleChange($event)"
        [dragLabel]="true"
        [dragMax]="100"
      ></color-editable-input>
    </div>
  </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                styles: [`
    .sketch-fields {
      display: flex;
      padding-top: 4px;
    }
    .sketch-double {
      -webkit-box-flex: 2;
      flex: 2 1 0%;
    }
    .sketch-single {
      flex: 1 1 0%;
      padding-left: 6px;
    }
    .sketch-alpha {
      -webkit-box-flex: 1;
      flex: 1 1 0%;
      padding-left: 6px;
    }
  `]
            }] }
];
SketchFieldsComponent.propDecorators = {
    hsl: [{ type: Input }],
    rgb: [{ type: Input }],
    hex: [{ type: Input }],
    disableAlpha: [{ type: Input }],
    onChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SketchPresetColorsComponent {
    constructor() {
        this.onClick = new EventEmitter();
        this.onSwatchHover = new EventEmitter();
        this.swatchStyle = {
            borderRadius: '3px',
            boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.15)',
        };
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    handleClick({ hex, $event }) {
        this.onClick.emit({ hex, $event });
    }
    /**
     * @param {?} val
     * @return {?}
     */
    normalizeValue(val) {
        if (typeof val === 'string') {
            return { color: val };
        }
        return val;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    focusStyle(val) {
        /** @type {?} */
        const c = this.normalizeValue(val);
        return {
            boxShadow: `inset 0 0 0 1px rgba(0,0,0,.15), 0 0 4px ${c.color}`,
        };
    }
}
SketchPresetColorsComponent.decorators = [
    { type: Component, args: [{
                selector: 'color-sketch-preset-colors',
                template: `
  <div class="sketch-swatches">
    <div class="sketch-wrap" *ngFor="let c of colors">
      <color-swatch
        [color]="normalizeValue(c).color"
        [style]="swatchStyle"
        [focusStyle]="focusStyle(c)"
        (onClick)="handleClick($event)"
        (onHover)="onSwatchHover.emit($event)"
        class="swatch"
      ></color-swatch>
    </div>
  </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                styles: [`
    .sketch-swatches {
      margin: 0px -10px;
      padding: 10px 0px 0px 10px;
      border-top: 1px solid rgb(238, 238, 238);
      display: flex;
      flex-wrap: wrap;
      position: relative;
    }
    .sketch-wrap {
      width: 16px;
      height: 16px;
      margin: 0px 10px 10px 0px;
    }
  `]
            }] }
];
SketchPresetColorsComponent.propDecorators = {
    colors: [{ type: Input }],
    onClick: [{ type: Output }],
    onSwatchHover: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SketchComponent extends ColorWrap {
    constructor() {
        super();
        /**
         * Remove alpha slider and options from picker
         */
        this.disableAlpha = false;
        /**
         * Hex strings for default colors at bottom of picker
         */
        this.presetColors = [
            '#D0021B',
            '#F5A623',
            '#F8E71C',
            '#8B572A',
            '#7ED321',
            '#417505',
            '#BD10E0',
            '#9013FE',
            '#4A90E2',
            '#50E3C2',
            '#B8E986',
            '#000000',
            '#4A4A4A',
            '#9B9B9B',
            '#FFFFFF',
        ];
        /**
         * Width of picker
         */
        this.width = 200;
    }
    /**
     * @return {?}
     */
    afterValidChange() {
        this.activeBackground = `rgba(${this.rgb.r}, ${this.rgb.g}, ${this.rgb.b}, ${this.rgb.a})`;
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    handleValueChange({ data, $event }) {
        this.handleChange(data, $event);
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    handleBlockChange({ hex, $event }) {
        if (isValidHex(hex)) {
            // this.hex = hex;
            this.handleChange({
                hex,
                source: 'hex',
            }, $event);
        }
    }
}
SketchComponent.decorators = [
    { type: Component, args: [{
                selector: 'color-sketch',
                template: `
  <div class="sketch-picker {{ className }}" [style.width]="width">
    <div class="sketch-saturation">
      <color-saturation [hsl]="hsl" [hsv]="hsv"
        (onChange)="handleValueChange($event)"
      >
      </color-saturation>
    </div>
    <div class="sketch-controls">
      <div class="sketch-sliders">
        <div class="sketch-hue">
          <color-hue [hsl]="hsl"
            (onChange)="handleValueChange($event)"
          ></color-hue>
        </div>
        <div class="sketch-alpha">
          <color-alpha
            [radius]="2" [rgb]="rgb" [hsl]="hsl"
            (onChange)="handleValueChange($event)"
          ></color-alpha>
        </div>
      </div>
      <div class="sketch-color">
        <color-checkboard></color-checkboard>
        <div class="sketch-active" [style.background]="activeBackground"></div>
      </div>
    </div>
    <div class="sketch-controls">
      <color-sketch-fields
        [rgb]="rgb" [hsl]="hsl" [hex]="hex"
        [disableAlpha]="disableAlpha"
        (onChange)="handleValueChange($event)"
      ></color-sketch-fields>
    </div>
    <div class="sketch-controls">
      <color-sketch-preset-colors
        [colors]="presetColors"
        (onClick)="handleBlockChange($event)"
        (onSwatchHover)="onSwatchHover.emit($event)"
      ></color-sketch-preset-colors>
    </div>
  </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                styles: [`
    .sketch-picker {
      padding: 10px 10px 0;
      box-sizing: initial;
      background: #fff;
      border-radius: 4px;
      box-shadow: 0 0 0 1px rgba(0,0,0,.15), 0 8px 16px rgba(0,0,0,.15);
    }
    .sketch-saturation {
      width: 100%;
      padding-bottom: 75%;
      position: relative;
      overflow: hidden;
    }
    .sketch-controls {
      display: flex;
    }
    .sketch-sliders {
      padding: 4px 0px;
      -webkit-box-flex: 1;
      flex: 1 1 0%;
    }
    .sketch-hue {
      position: relative;
      height: 10px;
      overflow: hidden;
    }
    .sketch-alpha {
      position: relative;
      height: 10px;
      margin-top: 4px;
      overflow: hidden;
    }
    .sketch-color {
      width: 24px;
      height: 24px;
      position: relative;
      margin-top: 4px;
      margin-left: 4px;
      border-radius: 3px;
    }
    .sketch-active {
      position: absolute;
      top: 0px;
      right: 0px;
      bottom: 0px;
      left: 0px;
      border-radius: 2px;
      box-shadow: rgba(0, 0, 0, 0.15) 0px 0px 0px 1px inset, rgba(0, 0, 0, 0.25) 0px 0px 4px inset;
    }
  `]
            }] }
];
/** @nocollapse */
SketchComponent.ctorParameters = () => [];
SketchComponent.propDecorators = {
    disableAlpha: [{ type: Input }],
    presetColors: [{ type: Input }],
    width: [{ type: Input }]
};
class ColorSketchModule {
}
ColorSketchModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    SketchComponent,
                    SketchFieldsComponent,
                    SketchPresetColorsComponent,
                ],
                exports: [
                    SketchComponent,
                    SketchFieldsComponent,
                    SketchPresetColorsComponent,
                ],
                imports: [
                    CommonModule,
                    AlphaModule,
                    CheckboardModule,
                    EditableInputModule,
                    HueModule,
                    SaturationModule,
                    SwatchModule,
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { SketchComponent, ColorSketchModule, SketchFieldsComponent as ɵa, SketchPresetColorsComponent as ɵb };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWNvbG9yLXNrZXRjaC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vbmd4LWNvbG9yL3NrZXRjaC9za2V0Y2gtZmllbGRzLmNvbXBvbmVudC50cyIsIm5nOi8vbmd4LWNvbG9yL3NrZXRjaC9za2V0Y2gtcHJlc2V0LWNvbG9ycy5jb21wb25lbnQudHMiLCJuZzovL25neC1jb2xvci9za2V0Y2gvc2tldGNoLmNvbXBvbmVudC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPdXRwdXQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBpc1ZhbGlkSGV4LCBIU0xBLCBSR0JBIH0gZnJvbSAnbmd4LWNvbG9yJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY29sb3Itc2tldGNoLWZpZWxkcycsXG4gIHRlbXBsYXRlOiBgXG4gIDxkaXYgY2xhc3M9XCJza2V0Y2gtZmllbGRzXCI+XG4gICAgPGRpdiBjbGFzcz1cInNrZXRjaC1kb3VibGVcIj5cbiAgICAgIDxjb2xvci1lZGl0YWJsZS1pbnB1dFxuICAgICAgICBbc3R5bGVdPVwieyBpbnB1dDogaW5wdXQsIGxhYmVsOiBsYWJlbCB9XCJcbiAgICAgICAgbGFiZWw9XCJoZXhcIlxuICAgICAgICBbdmFsdWVdPVwiaGV4LnJlcGxhY2UoJyMnLCAnJylcIlxuICAgICAgICAob25DaGFuZ2UpPVwiaGFuZGxlQ2hhbmdlKCRldmVudClcIlxuICAgICAgPjwvY29sb3ItZWRpdGFibGUtaW5wdXQ+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInNrZXRjaC1zaW5nbGVcIj5cbiAgICAgIDxjb2xvci1lZGl0YWJsZS1pbnB1dFxuICAgICAgICBbc3R5bGVdPVwieyBpbnB1dDogaW5wdXQsIGxhYmVsOiBsYWJlbCB9XCJcbiAgICAgICAgbGFiZWw9XCJyXCJcbiAgICAgICAgW3ZhbHVlXT1cInJnYi5yXCJcbiAgICAgICAgKG9uQ2hhbmdlKT1cImhhbmRsZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgW2RyYWdMYWJlbF09XCJ0cnVlXCJcbiAgICAgICAgW2RyYWdNYXhdPVwiMjU1XCJcbiAgICAgID48L2NvbG9yLWVkaXRhYmxlLWlucHV0PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJza2V0Y2gtc2luZ2xlXCI+XG4gICAgICA8Y29sb3ItZWRpdGFibGUtaW5wdXRcbiAgICAgICAgW3N0eWxlXT1cInsgaW5wdXQ6IGlucHV0LCBsYWJlbDogbGFiZWwgfVwiXG4gICAgICAgIGxhYmVsPVwiZ1wiXG4gICAgICAgIFt2YWx1ZV09XCJyZ2IuZ1wiXG4gICAgICAgIChvbkNoYW5nZSk9XCJoYW5kbGVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgIFtkcmFnTGFiZWxdPVwidHJ1ZVwiXG4gICAgICAgIFtkcmFnTWF4XT1cIjI1NVwiXG4gICAgICA+PC9jb2xvci1lZGl0YWJsZS1pbnB1dD5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwic2tldGNoLXNpbmdsZVwiPlxuICAgICAgPGNvbG9yLWVkaXRhYmxlLWlucHV0XG4gICAgICAgIFtzdHlsZV09XCJ7IGlucHV0OiBpbnB1dCwgbGFiZWw6IGxhYmVsIH1cIlxuICAgICAgICBsYWJlbD1cImJcIlxuICAgICAgICBbdmFsdWVdPVwicmdiLmJcIlxuICAgICAgICAob25DaGFuZ2UpPVwiaGFuZGxlQ2hhbmdlKCRldmVudClcIlxuICAgICAgICBbZHJhZ0xhYmVsXT1cInRydWVcIlxuICAgICAgICBbZHJhZ01heF09XCIyNTVcIlxuICAgICAgPjwvY29sb3ItZWRpdGFibGUtaW5wdXQ+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInNrZXRjaC1hbHBoYVwiICpuZ0lmPVwiZGlzYWJsZUFscGhhID09PSBmYWxzZVwiPlxuICAgICAgPGNvbG9yLWVkaXRhYmxlLWlucHV0XG4gICAgICAgIFtzdHlsZV09XCJ7IGlucHV0OiBpbnB1dCwgbGFiZWw6IGxhYmVsIH1cIlxuICAgICAgICBsYWJlbD1cImFcIlxuICAgICAgICBbdmFsdWVdPVwicm91bmQocmdiLmEgKiAxMDApXCJcbiAgICAgICAgKG9uQ2hhbmdlKT1cImhhbmRsZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgW2RyYWdMYWJlbF09XCJ0cnVlXCJcbiAgICAgICAgW2RyYWdNYXhdPVwiMTAwXCJcbiAgICAgID48L2NvbG9yLWVkaXRhYmxlLWlucHV0PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbiAgYCxcbiAgc3R5bGVzOiBbXG4gICAgYFxuICAgIC5za2V0Y2gtZmllbGRzIHtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBwYWRkaW5nLXRvcDogNHB4O1xuICAgIH1cbiAgICAuc2tldGNoLWRvdWJsZSB7XG4gICAgICAtd2Via2l0LWJveC1mbGV4OiAyO1xuICAgICAgZmxleDogMiAxIDAlO1xuICAgIH1cbiAgICAuc2tldGNoLXNpbmdsZSB7XG4gICAgICBmbGV4OiAxIDEgMCU7XG4gICAgICBwYWRkaW5nLWxlZnQ6IDZweDtcbiAgICB9XG4gICAgLnNrZXRjaC1hbHBoYSB7XG4gICAgICAtd2Via2l0LWJveC1mbGV4OiAxO1xuICAgICAgZmxleDogMSAxIDAlO1xuICAgICAgcGFkZGluZy1sZWZ0OiA2cHg7XG4gICAgfVxuICBgLFxuICBdLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG59KVxuZXhwb3J0IGNsYXNzIFNrZXRjaEZpZWxkc0NvbXBvbmVudCB7XG4gIEBJbnB1dCgpIGhzbDogSFNMQTtcbiAgQElucHV0KCkgcmdiOiBSR0JBO1xuICBASW5wdXQoKSBoZXg6IHN0cmluZztcbiAgQElucHV0KCkgZGlzYWJsZUFscGhhID0gZmFsc2U7XG4gIEBPdXRwdXQoKSBvbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuICBpbnB1dDoge1trZXk6IHN0cmluZ106IHN0cmluZ30gPSB7XG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBwYWRkaW5nOiAnNHB4IDEwJSAzcHgnLFxuICAgIGJvcmRlcjogJ25vbmUnLFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIGJveFNoYWRvdzogJ2luc2V0IDAgMCAwIDFweCAjY2NjJyxcbiAgICBmb250U2l6ZTogJzExcHgnLFxuICB9O1xuICBsYWJlbDoge1trZXk6IHN0cmluZ106IHN0cmluZ30gPSB7XG4gICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgIGZvbnRTaXplOiAnMTFweCcsXG4gICAgY29sb3I6ICcjMjIyJyxcbiAgICBwYWRkaW5nVG9wOiAnM3B4JyxcbiAgICBwYWRkaW5nQm90dG9tOiAnNHB4JyxcbiAgICB0ZXh0VHJhbnNmb3JtOiAnY2FwaXRhbGl6ZScsXG4gIH07XG5cbiAgcm91bmQodmFsdWUpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gIH1cbiAgaGFuZGxlQ2hhbmdlKHsgZGF0YSwgJGV2ZW50IH0pIHtcbiAgICBpZiAoZGF0YS5oZXgpIHtcbiAgICAgIGlmIChpc1ZhbGlkSGV4KGRhdGEuaGV4KSkge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGhleDogZGF0YS5oZXgsXG4gICAgICAgICAgICBzb3VyY2U6ICdoZXgnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgJGV2ZW50LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEuciB8fCBkYXRhLmcgfHwgZGF0YS5iKSB7XG4gICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcjogZGF0YS5yIHx8IHRoaXMucmdiLnIsXG4gICAgICAgICAgZzogZGF0YS5nIHx8IHRoaXMucmdiLmcsXG4gICAgICAgICAgYjogZGF0YS5iIHx8IHRoaXMucmdiLmIsXG4gICAgICAgICAgc291cmNlOiAncmdiJyxcbiAgICAgICAgfSxcbiAgICAgICAgJGV2ZW50LFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChkYXRhLmEpIHtcbiAgICAgIGlmIChkYXRhLmEgPCAwKSB7XG4gICAgICAgIGRhdGEuYSA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEuYSA+IDEwMCkge1xuICAgICAgICBkYXRhLmEgPSAxMDA7XG4gICAgICB9XG4gICAgICBkYXRhLmEgLz0gMTAwO1xuXG4gICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaDogdGhpcy5oc2wuaCxcbiAgICAgICAgICBzOiB0aGlzLmhzbC5zLFxuICAgICAgICAgIGw6IHRoaXMuaHNsLmwsXG4gICAgICAgICAgYTogTWF0aC5yb3VuZChkYXRhLmEgKiAxMDApIC8gMTAwLFxuICAgICAgICAgIHNvdXJjZTogJ3JnYicsXG4gICAgICAgIH0sXG4gICAgICAgICRldmVudCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5oIHx8IGRhdGEucyB8fCBkYXRhLmwpIHtcbiAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBoOiBkYXRhLmggfHwgdGhpcy5oc2wuaCxcbiAgICAgICAgICBzOiBOdW1iZXIoKGRhdGEucyAmJiBkYXRhLnMpIHx8IHRoaXMuaHNsLnMpLFxuICAgICAgICAgIGw6IE51bWJlcigoZGF0YS5sICYmIGRhdGEubCkgfHwgdGhpcy5oc2wubCksXG4gICAgICAgICAgc291cmNlOiAnaHNsJyxcbiAgICAgICAgfSxcbiAgICAgICAgJGV2ZW50LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPdXRwdXQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJ25neC1jb2xvcic7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2NvbG9yLXNrZXRjaC1wcmVzZXQtY29sb3JzJyxcbiAgdGVtcGxhdGU6IGBcbiAgPGRpdiBjbGFzcz1cInNrZXRjaC1zd2F0Y2hlc1wiPlxuICAgIDxkaXYgY2xhc3M9XCJza2V0Y2gtd3JhcFwiICpuZ0Zvcj1cImxldCBjIG9mIGNvbG9yc1wiPlxuICAgICAgPGNvbG9yLXN3YXRjaFxuICAgICAgICBbY29sb3JdPVwibm9ybWFsaXplVmFsdWUoYykuY29sb3JcIlxuICAgICAgICBbc3R5bGVdPVwic3dhdGNoU3R5bGVcIlxuICAgICAgICBbZm9jdXNTdHlsZV09XCJmb2N1c1N0eWxlKGMpXCJcbiAgICAgICAgKG9uQ2xpY2spPVwiaGFuZGxlQ2xpY2soJGV2ZW50KVwiXG4gICAgICAgIChvbkhvdmVyKT1cIm9uU3dhdGNoSG92ZXIuZW1pdCgkZXZlbnQpXCJcbiAgICAgICAgY2xhc3M9XCJzd2F0Y2hcIlxuICAgICAgPjwvY29sb3Itc3dhdGNoPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbiAgYCxcbiAgc3R5bGVzOiBbXG4gICAgYFxuICAgIC5za2V0Y2gtc3dhdGNoZXMge1xuICAgICAgbWFyZ2luOiAwcHggLTEwcHg7XG4gICAgICBwYWRkaW5nOiAxMHB4IDBweCAwcHggMTBweDtcbiAgICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCByZ2IoMjM4LCAyMzgsIDIzOCk7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgZmxleC13cmFwOiB3cmFwO1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIH1cbiAgICAuc2tldGNoLXdyYXAge1xuICAgICAgd2lkdGg6IDE2cHg7XG4gICAgICBoZWlnaHQ6IDE2cHg7XG4gICAgICBtYXJnaW46IDBweCAxMHB4IDEwcHggMHB4O1xuICAgIH1cbiAgYCxcbiAgXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxufSlcbmV4cG9ydCBjbGFzcyBTa2V0Y2hQcmVzZXRDb2xvcnNDb21wb25lbnQge1xuICBASW5wdXQoKSBjb2xvcnM6IHN0cmluZ1tdIHwgU2hhcGVbXTtcbiAgQE91dHB1dCgpIG9uQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgQE91dHB1dCgpIG9uU3dhdGNoSG92ZXIgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgc3dhdGNoU3R5bGUgPSB7XG4gICAgYm9yZGVyUmFkaXVzOiAnM3B4JyxcbiAgICBib3hTaGFkb3c6ICdpbnNldCAwIDAgMCAxcHggcmdiYSgwLDAsMCwuMTUpJyxcbiAgfTtcblxuICBoYW5kbGVDbGljayh7IGhleCwgJGV2ZW50IH0pIHtcbiAgICB0aGlzLm9uQ2xpY2suZW1pdCh7IGhleCwgJGV2ZW50IH0pO1xuICB9XG4gIG5vcm1hbGl6ZVZhbHVlKHZhbDogc3RyaW5nIHwgU2hhcGUpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB7IGNvbG9yOiB2YWwgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBmb2N1c1N0eWxlKHZhbDogc3RyaW5nIHwgU2hhcGUpIHtcbiAgICBjb25zdCBjID0gdGhpcy5ub3JtYWxpemVWYWx1ZSh2YWwpO1xuICAgIHJldHVybiB7XG4gICAgICBib3hTaGFkb3c6IGBpbnNldCAwIDAgMCAxcHggcmdiYSgwLDAsMCwuMTUpLCAwIDAgNHB4ICR7Yy5jb2xvcn1gLFxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBJbnB1dCxcbiAgTmdNb2R1bGUsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQge1xuICBBbHBoYU1vZHVsZSxcbiAgQ2hlY2tib2FyZE1vZHVsZSxcbiAgQ29sb3JXcmFwLFxuICBFZGl0YWJsZUlucHV0TW9kdWxlLFxuICBIdWVNb2R1bGUsXG4gIFNhdHVyYXRpb25Nb2R1bGUsXG4gIFN3YXRjaE1vZHVsZSxcbn0gZnJvbSAnbmd4LWNvbG9yJztcbmltcG9ydCB7IGlzVmFsaWRIZXggfSBmcm9tICduZ3gtY29sb3InO1xuaW1wb3J0IHsgU2tldGNoRmllbGRzQ29tcG9uZW50IH0gZnJvbSAnLi9za2V0Y2gtZmllbGRzLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTa2V0Y2hQcmVzZXRDb2xvcnNDb21wb25lbnQgfSBmcm9tICcuL3NrZXRjaC1wcmVzZXQtY29sb3JzLmNvbXBvbmVudCc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2NvbG9yLXNrZXRjaCcsXG4gIHRlbXBsYXRlOiBgXG4gIDxkaXYgY2xhc3M9XCJza2V0Y2gtcGlja2VyIHt7IGNsYXNzTmFtZSB9fVwiIFtzdHlsZS53aWR0aF09XCJ3aWR0aFwiPlxuICAgIDxkaXYgY2xhc3M9XCJza2V0Y2gtc2F0dXJhdGlvblwiPlxuICAgICAgPGNvbG9yLXNhdHVyYXRpb24gW2hzbF09XCJoc2xcIiBbaHN2XT1cImhzdlwiXG4gICAgICAgIChvbkNoYW5nZSk9XCJoYW5kbGVWYWx1ZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgID5cbiAgICAgIDwvY29sb3Itc2F0dXJhdGlvbj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwic2tldGNoLWNvbnRyb2xzXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwic2tldGNoLXNsaWRlcnNcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNrZXRjaC1odWVcIj5cbiAgICAgICAgICA8Y29sb3ItaHVlIFtoc2xdPVwiaHNsXCJcbiAgICAgICAgICAgIChvbkNoYW5nZSk9XCJoYW5kbGVWYWx1ZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICA+PC9jb2xvci1odWU+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwic2tldGNoLWFscGhhXCI+XG4gICAgICAgICAgPGNvbG9yLWFscGhhXG4gICAgICAgICAgICBbcmFkaXVzXT1cIjJcIiBbcmdiXT1cInJnYlwiIFtoc2xdPVwiaHNsXCJcbiAgICAgICAgICAgIChvbkNoYW5nZSk9XCJoYW5kbGVWYWx1ZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICA+PC9jb2xvci1hbHBoYT5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJza2V0Y2gtY29sb3JcIj5cbiAgICAgICAgPGNvbG9yLWNoZWNrYm9hcmQ+PC9jb2xvci1jaGVja2JvYXJkPlxuICAgICAgICA8ZGl2IGNsYXNzPVwic2tldGNoLWFjdGl2ZVwiIFtzdHlsZS5iYWNrZ3JvdW5kXT1cImFjdGl2ZUJhY2tncm91bmRcIj48L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJza2V0Y2gtY29udHJvbHNcIj5cbiAgICAgIDxjb2xvci1za2V0Y2gtZmllbGRzXG4gICAgICAgIFtyZ2JdPVwicmdiXCIgW2hzbF09XCJoc2xcIiBbaGV4XT1cImhleFwiXG4gICAgICAgIFtkaXNhYmxlQWxwaGFdPVwiZGlzYWJsZUFscGhhXCJcbiAgICAgICAgKG9uQ2hhbmdlKT1cImhhbmRsZVZhbHVlQ2hhbmdlKCRldmVudClcIlxuICAgICAgPjwvY29sb3Itc2tldGNoLWZpZWxkcz5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwic2tldGNoLWNvbnRyb2xzXCI+XG4gICAgICA8Y29sb3Itc2tldGNoLXByZXNldC1jb2xvcnNcbiAgICAgICAgW2NvbG9yc109XCJwcmVzZXRDb2xvcnNcIlxuICAgICAgICAob25DbGljayk9XCJoYW5kbGVCbG9ja0NoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgKG9uU3dhdGNoSG92ZXIpPVwib25Td2F0Y2hIb3Zlci5lbWl0KCRldmVudClcIlxuICAgICAgPjwvY29sb3Itc2tldGNoLXByZXNldC1jb2xvcnM+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuICBgLFxuICBzdHlsZXM6IFtcbiAgICBgXG4gICAgLnNrZXRjaC1waWNrZXIge1xuICAgICAgcGFkZGluZzogMTBweCAxMHB4IDA7XG4gICAgICBib3gtc2l6aW5nOiBpbml0aWFsO1xuICAgICAgYmFja2dyb3VuZDogI2ZmZjtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgIGJveC1zaGFkb3c6IDAgMCAwIDFweCByZ2JhKDAsMCwwLC4xNSksIDAgOHB4IDE2cHggcmdiYSgwLDAsMCwuMTUpO1xuICAgIH1cbiAgICAuc2tldGNoLXNhdHVyYXRpb24ge1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBwYWRkaW5nLWJvdHRvbTogNzUlO1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB9XG4gICAgLnNrZXRjaC1jb250cm9scyB7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgIH1cbiAgICAuc2tldGNoLXNsaWRlcnMge1xuICAgICAgcGFkZGluZzogNHB4IDBweDtcbiAgICAgIC13ZWJraXQtYm94LWZsZXg6IDE7XG4gICAgICBmbGV4OiAxIDEgMCU7XG4gICAgfVxuICAgIC5za2V0Y2gtaHVlIHtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIGhlaWdodDogMTBweDtcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgfVxuICAgIC5za2V0Y2gtYWxwaGEge1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgaGVpZ2h0OiAxMHB4O1xuICAgICAgbWFyZ2luLXRvcDogNHB4O1xuICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB9XG4gICAgLnNrZXRjaC1jb2xvciB7XG4gICAgICB3aWR0aDogMjRweDtcbiAgICAgIGhlaWdodDogMjRweDtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIG1hcmdpbi10b3A6IDRweDtcbiAgICAgIG1hcmdpbi1sZWZ0OiA0cHg7XG4gICAgICBib3JkZXItcmFkaXVzOiAzcHg7XG4gICAgfVxuICAgIC5za2V0Y2gtYWN0aXZlIHtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHRvcDogMHB4O1xuICAgICAgcmlnaHQ6IDBweDtcbiAgICAgIGJvdHRvbTogMHB4O1xuICAgICAgbGVmdDogMHB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICAgICAgYm94LXNoYWRvdzogcmdiYSgwLCAwLCAwLCAwLjE1KSAwcHggMHB4IDBweCAxcHggaW5zZXQsIHJnYmEoMCwgMCwgMCwgMC4yNSkgMHB4IDBweCA0cHggaW5zZXQ7XG4gICAgfVxuICBgLFxuICBdLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG59KVxuZXhwb3J0IGNsYXNzIFNrZXRjaENvbXBvbmVudCBleHRlbmRzIENvbG9yV3JhcCB7XG4gIC8qKiBSZW1vdmUgYWxwaGEgc2xpZGVyIGFuZCBvcHRpb25zIGZyb20gcGlja2VyICovXG4gIEBJbnB1dCgpIGRpc2FibGVBbHBoYSA9IGZhbHNlO1xuICAvKiogSGV4IHN0cmluZ3MgZm9yIGRlZmF1bHQgY29sb3JzIGF0IGJvdHRvbSBvZiBwaWNrZXIgKi9cbiAgQElucHV0KCkgcHJlc2V0Q29sb3JzID0gW1xuICAgICcjRDAwMjFCJyxcbiAgICAnI0Y1QTYyMycsXG4gICAgJyNGOEU3MUMnLFxuICAgICcjOEI1NzJBJyxcbiAgICAnIzdFRDMyMScsXG4gICAgJyM0MTc1MDUnLFxuICAgICcjQkQxMEUwJyxcbiAgICAnIzkwMTNGRScsXG4gICAgJyM0QTkwRTInLFxuICAgICcjNTBFM0MyJyxcbiAgICAnI0I4RTk4NicsXG4gICAgJyMwMDAwMDAnLFxuICAgICcjNEE0QTRBJyxcbiAgICAnIzlCOUI5QicsXG4gICAgJyNGRkZGRkYnLFxuICBdO1xuICAvKiogV2lkdGggb2YgcGlja2VyICovXG4gIEBJbnB1dCgpIHdpZHRoID0gMjAwO1xuICBhY3RpdmVCYWNrZ3JvdW5kOiBzdHJpbmc7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cbiAgYWZ0ZXJWYWxpZENoYW5nZSgpIHtcbiAgICB0aGlzLmFjdGl2ZUJhY2tncm91bmQgPSBgcmdiYSgke3RoaXMucmdiLnJ9LCAke3RoaXMucmdiLmd9LCAke3RoaXMucmdiLmJ9LCAke3RoaXMucmdiLmF9KWA7XG4gIH1cbiAgaGFuZGxlVmFsdWVDaGFuZ2UoeyBkYXRhLCAkZXZlbnQgfSkge1xuICAgIHRoaXMuaGFuZGxlQ2hhbmdlKGRhdGEsICRldmVudCk7XG4gIH1cbiAgaGFuZGxlQmxvY2tDaGFuZ2UoeyBoZXgsICRldmVudCB9KSB7XG4gICAgaWYgKGlzVmFsaWRIZXgoaGV4KSkge1xuICAgICAgLy8gdGhpcy5oZXggPSBoZXg7XG4gICAgICB0aGlzLmhhbmRsZUNoYW5nZShcbiAgICAgICAge1xuICAgICAgICAgIGhleCxcbiAgICAgICAgICBzb3VyY2U6ICdoZXgnLFxuICAgICAgICB9LFxuICAgICAgICAkZXZlbnQsXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5ATmdNb2R1bGUoe1xuICBkZWNsYXJhdGlvbnM6IFtcbiAgICBTa2V0Y2hDb21wb25lbnQsXG4gICAgU2tldGNoRmllbGRzQ29tcG9uZW50LFxuICAgIFNrZXRjaFByZXNldENvbG9yc0NvbXBvbmVudCxcbiAgXSxcbiAgZXhwb3J0czogW1xuICAgIFNrZXRjaENvbXBvbmVudCxcbiAgICBTa2V0Y2hGaWVsZHNDb21wb25lbnQsXG4gICAgU2tldGNoUHJlc2V0Q29sb3JzQ29tcG9uZW50LFxuICBdLFxuICBpbXBvcnRzOiBbXG4gICAgQ29tbW9uTW9kdWxlLFxuICAgIEFscGhhTW9kdWxlLFxuICAgIENoZWNrYm9hcmRNb2R1bGUsXG4gICAgRWRpdGFibGVJbnB1dE1vZHVsZSxcbiAgICBIdWVNb2R1bGUsXG4gICAgU2F0dXJhdGlvbk1vZHVsZSxcbiAgICBTd2F0Y2hNb2R1bGUsXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIENvbG9yU2tldGNoTW9kdWxlIHt9XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxNQXdGYSxxQkFBcUI7SUE5RWxDO1FBa0ZXLGlCQUFZLEdBQUcsS0FBSyxDQUFDO1FBQ3BCLGFBQVEsR0FBRyxJQUFJLFlBQVksRUFBTyxDQUFDO1FBQzdDLFVBQUssR0FBNEI7WUFDL0IsS0FBSyxFQUFFLE1BQU07WUFDYixPQUFPLEVBQUUsYUFBYTtZQUN0QixNQUFNLEVBQUUsTUFBTTtZQUNkLFNBQVMsRUFBRSxZQUFZO1lBQ3ZCLFNBQVMsRUFBRSxzQkFBc0I7WUFDakMsUUFBUSxFQUFFLE1BQU07U0FDakIsQ0FBQztRQUNGLFVBQUssR0FBNEI7WUFDL0IsT0FBTyxFQUFFLE9BQU87WUFDaEIsU0FBUyxFQUFFLFFBQVE7WUFDbkIsUUFBUSxFQUFFLE1BQU07WUFDaEIsS0FBSyxFQUFFLE1BQU07WUFDYixVQUFVLEVBQUUsS0FBSztZQUNqQixhQUFhLEVBQUUsS0FBSztZQUNwQixhQUFhLEVBQUUsWUFBWTtTQUM1QixDQUFDO0tBd0RIOzs7OztJQXREQyxLQUFLLENBQUMsS0FBSztRQUNULE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUMxQjs7Ozs7SUFDRCxZQUFZLENBQUMsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFO1FBQzNCLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNaLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDeEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUM7b0JBQ2pCLElBQUksRUFBRTt3QkFDSixHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUc7d0JBQ2IsTUFBTSxFQUFFLEtBQUs7cUJBQ2Q7b0JBQ0QsTUFBTTtpQkFDUCxDQUFDLENBQUM7YUFDSjtTQUNGO2FBQU0sSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsRUFBRTtZQUNyQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQztnQkFDakIsSUFBSSxFQUFFO29CQUNKLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDdkIsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUN2QixDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ3ZCLE1BQU0sRUFBRSxLQUFLO2lCQUNkO2dCQUNELE1BQU07YUFDUCxDQUFDLENBQUM7U0FDSjthQUFNLElBQUksSUFBSSxDQUFDLENBQUMsRUFBRTtZQUNqQixJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUNkLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ1o7aUJBQU0sSUFBSSxJQUFJLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFBRTtnQkFDdkIsSUFBSSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7YUFDZDtZQUNELElBQUksQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDO1lBRWQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUM7Z0JBQ2pCLElBQUksRUFBRTtvQkFDSixDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUNiLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ2IsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDYixDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUc7b0JBQ2pDLE1BQU0sRUFBRSxLQUFLO2lCQUNkO2dCQUNELE1BQU07YUFDUCxDQUFDLENBQUM7U0FDSjthQUFNLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEVBQUU7WUFDckMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUM7Z0JBQ2pCLElBQUksRUFBRTtvQkFDSixDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ3ZCLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7b0JBQzNDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7b0JBQzNDLE1BQU0sRUFBRSxLQUFLO2lCQUNkO2dCQUNELE1BQU07YUFDUCxDQUFDLENBQUM7U0FDSjtLQUNGOzs7WUEzSkYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxxQkFBcUI7Z0JBQy9CLFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbURUO2dCQXNCRCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtnQkFDL0MsbUJBQW1CLEVBQUUsS0FBSzt5QkFyQnhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FrQkQ7YUFJRjs7O2tCQUVFLEtBQUs7a0JBQ0wsS0FBSztrQkFDTCxLQUFLOzJCQUNMLEtBQUs7dUJBQ0wsTUFBTTs7Ozs7OztBQzdGVCxNQThDYSwyQkFBMkI7SUFwQ3hDO1FBc0NZLFlBQU8sR0FBRyxJQUFJLFlBQVksRUFBTyxDQUFDO1FBQ2xDLGtCQUFhLEdBQUcsSUFBSSxZQUFZLEVBQU8sQ0FBQztRQUNsRCxnQkFBVyxHQUFHO1lBQ1osWUFBWSxFQUFFLEtBQUs7WUFDbkIsU0FBUyxFQUFFLGlDQUFpQztTQUM3QyxDQUFDO0tBaUJIOzs7OztJQWZDLFdBQVcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUU7UUFDekIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztLQUNwQzs7Ozs7SUFDRCxjQUFjLENBQUMsR0FBbUI7UUFDaEMsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUU7WUFDM0IsT0FBTyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQztTQUN2QjtRQUNELE9BQU8sR0FBRyxDQUFDO0tBQ1o7Ozs7O0lBQ0QsVUFBVSxDQUFDLEdBQW1COztjQUN0QixDQUFDLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUM7UUFDbEMsT0FBTztZQUNMLFNBQVMsRUFBRSw0Q0FBNEMsQ0FBQyxDQUFDLEtBQUssRUFBRTtTQUNqRSxDQUFDO0tBQ0g7OztZQTNERixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLDRCQUE0QjtnQkFDdEMsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7O0dBYVQ7Z0JBa0JELGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO2dCQUMvQyxtQkFBbUIsRUFBRSxLQUFLO3lCQWpCeEI7Ozs7Ozs7Ozs7Ozs7O0dBY0Q7YUFJRjs7O3FCQUVFLEtBQUs7c0JBQ0wsTUFBTTs0QkFDTixNQUFNOzs7Ozs7O0FDakRULE1BMEhhLGVBQWdCLFNBQVEsU0FBUztJQXdCNUM7UUFDRSxLQUFLLEVBQUUsQ0FBQzs7OztRQXZCRCxpQkFBWSxHQUFHLEtBQUssQ0FBQzs7OztRQUVyQixpQkFBWSxHQUFHO1lBQ3RCLFNBQVM7WUFDVCxTQUFTO1lBQ1QsU0FBUztZQUNULFNBQVM7WUFDVCxTQUFTO1lBQ1QsU0FBUztZQUNULFNBQVM7WUFDVCxTQUFTO1lBQ1QsU0FBUztZQUNULFNBQVM7WUFDVCxTQUFTO1lBQ1QsU0FBUztZQUNULFNBQVM7WUFDVCxTQUFTO1lBQ1QsU0FBUztTQUNWLENBQUM7Ozs7UUFFTyxVQUFLLEdBQUcsR0FBRyxDQUFDO0tBSXBCOzs7O0lBQ0QsZ0JBQWdCO1FBQ2QsSUFBSSxDQUFDLGdCQUFnQixHQUFHLFFBQVEsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQztLQUM1Rjs7Ozs7SUFDRCxpQkFBaUIsQ0FBQyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUU7UUFDaEMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7S0FDakM7Ozs7O0lBQ0QsaUJBQWlCLENBQUMsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFO1FBQy9CLElBQUksVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFOztZQUVuQixJQUFJLENBQUMsWUFBWSxDQUNmO2dCQUNFLEdBQUc7Z0JBQ0gsTUFBTSxFQUFFLEtBQUs7YUFDZCxFQUNELE1BQU0sQ0FDUCxDQUFDO1NBQ0g7S0FDRjs7O1lBakpGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsY0FBYztnQkFDeEIsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0EwQ1Q7Z0JBc0RELGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO2dCQUMvQyxtQkFBbUIsRUFBRSxLQUFLO3lCQXJEeEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0REO2FBSUY7Ozs7OzJCQUdFLEtBQUs7MkJBRUwsS0FBSztvQkFrQkwsS0FBSzs7TUE4Q0ssaUJBQWlCOzs7WUFyQjdCLFFBQVEsU0FBQztnQkFDUixZQUFZLEVBQUU7b0JBQ1osZUFBZTtvQkFDZixxQkFBcUI7b0JBQ3JCLDJCQUEyQjtpQkFDNUI7Z0JBQ0QsT0FBTyxFQUFFO29CQUNQLGVBQWU7b0JBQ2YscUJBQXFCO29CQUNyQiwyQkFBMkI7aUJBQzVCO2dCQUNELE9BQU8sRUFBRTtvQkFDUCxZQUFZO29CQUNaLFdBQVc7b0JBQ1gsZ0JBQWdCO29CQUNoQixtQkFBbUI7b0JBQ25CLFNBQVM7b0JBQ1QsZ0JBQWdCO29CQUNoQixZQUFZO2lCQUNiO2FBQ0Y7Ozs7Ozs7Ozs7In0=