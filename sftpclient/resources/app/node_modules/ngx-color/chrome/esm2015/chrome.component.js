/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { CommonModule } from '@angular/common';
import { ChangeDetectionStrategy, Component, Input, NgModule, } from '@angular/core';
import { AlphaModule, CheckboardModule, ColorWrap, EditableInputModule, HueModule, SaturationModule, } from 'ngx-color';
import { ChromeFieldsComponent } from './chrome-fields.component';
export class ChromeComponent extends ColorWrap {
    constructor() {
        super();
        /**
         * Remove alpha slider and options from picker
         */
        this.disableAlpha = false;
        this.circle = {
            width: '12px',
            height: '12px',
            borderRadius: '6px',
            boxShadow: 'rgb(255, 255, 255) 0px 0px 0px 1px inset',
            transform: 'translate(-6px, -8px)',
        };
        this.pointer = {
            width: '12px',
            height: '12px',
            borderRadius: '6px',
            transform: 'translate(-6px, -2px)',
            backgroundColor: 'rgb(248, 248, 248)',
            boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)',
        };
    }
    /**
     * @return {?}
     */
    afterValidChange() {
        this.activeBackground = `rgba(${this.rgb.r}, ${this.rgb.g}, ${this.rgb.b}, ${this.rgb.a})`;
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    handleValueChange({ data, $event }) {
        this.handleChange(data, $event);
    }
}
ChromeComponent.decorators = [
    { type: Component, args: [{
                selector: 'color-chrome',
                template: `
  <div class="chrome-picker {{ className }}">
    <div class="saturation">
      <color-saturation
        [hsl]="hsl"
        [hsv]="hsv"
        [circle]="circle"
        (onChange)="handleValueChange($event)"
      ></color-saturation>
    </div>
    <div class="chrome-body">
      <div class="chrome-controls">
        <div class="chrome-color">
          <div class="chrome-swatch">
            <div class="chrome-active"
              [style.background]="activeBackground"
            ></div>
            <color-checkboard></color-checkboard>
          </div>
        </div>
        <div class="chrome-toggles">
          <div class="chrome-hue">
            <color-hue
              [radius]="2"
              [hsl]="hsl"
              [pointer]="pointer"
              (onChange)="handleValueChange($event)"
            ></color-hue>
          </div>
          <div class="chrome-alpha" *ngIf="!disableAlpha">
            <color-alpha
              [radius]="2" [rgb]="rgb" [hsl]="hsl"
              [pointer]="pointer" (onChange)="handleValueChange($event)"
            ></color-alpha>
          </div>
        </div>
      </div>
      <color-chrome-fields
        [rgb]="rgb" [hsl]="hsl" [hex]="hex"
        [disableAlpha]="disableAlpha"
        (onChange)="handleValueChange($event)"
      ></color-chrome-fields>
    </div>
  </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                styles: [`
      .chrome-picker {
        background: #fff;
        border-radius: 2px;
        box-shadow: 0 0 2px rgba(0, 0, 0, 0.3), 0 4px 8px rgba(0, 0, 0, 0.3);
        box-sizing: initial;
        width: 225px;
        font-family: 'Menlo';
      }
      .chrome-controls {
        display: flex;
      }
      .chrome-color {
        width: 42px;
      }
      .chrome-body {
        padding: 14px 14px 12px;
      }
      .chrome-active {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        border-radius: 20px;
        box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.1);
        z-index: 2;
      }
      .chrome-swatch {
        width: 28px;
        height: 28px;
        border-radius: 15px;
        position: relative;
        overflow: hidden;
      }
      .saturation {
        width: 100%;
        padding-bottom: 55%;
        position: relative;
        border-radius: 2px 2px 0 0;
        overflow: hidden;
      }
      .chrome-toggles {
        flex: 1;
      }
      .chrome-hue {
        height: 10px;
        position: relative;
        margin-bottom: 8px;
      }
      .chrome-alpha {
        height: 10px;
        position: relative;
      }
    `]
            }] }
];
/** @nocollapse */
ChromeComponent.ctorParameters = () => [];
ChromeComponent.propDecorators = {
    disableAlpha: [{ type: Input }]
};
if (false) {
    /**
     * Remove alpha slider and options from picker
     * @type {?}
     */
    ChromeComponent.prototype.disableAlpha;
    /** @type {?} */
    ChromeComponent.prototype.circle;
    /** @type {?} */
    ChromeComponent.prototype.pointer;
    /** @type {?} */
    ChromeComponent.prototype.activeBackground;
}
export class ColorChromeModule {
}
ColorChromeModule.decorators = [
    { type: NgModule, args: [{
                declarations: [ChromeComponent, ChromeFieldsComponent],
                exports: [ChromeComponent, ChromeFieldsComponent],
                imports: [
                    CommonModule,
                    AlphaModule,
                    CheckboardModule,
                    EditableInputModule,
                    HueModule,
                    SaturationModule,
                ],
            },] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hyb21lLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1jb2xvci9jaHJvbWUvIiwic291cmNlcyI6WyJjaHJvbWUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0MsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsS0FBSyxFQUNMLFFBQVEsR0FDVCxNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQ0wsV0FBVyxFQUNYLGdCQUFnQixFQUNoQixTQUFTLEVBQ1QsbUJBQW1CLEVBQ25CLFNBQVMsRUFDVCxnQkFBZ0IsR0FDakIsTUFBTSxXQUFXLENBQUM7QUFDbkIsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUE2R2xFLE1BQU0sT0FBTyxlQUFnQixTQUFRLFNBQVM7SUFvQjVDO1FBQ0UsS0FBSyxFQUFFLENBQUM7Ozs7UUFuQkQsaUJBQVksR0FBRyxLQUFLLENBQUM7UUFDOUIsV0FBTSxHQUE4QjtZQUNsQyxLQUFLLEVBQUUsTUFBTTtZQUNiLE1BQU0sRUFBRSxNQUFNO1lBQ2QsWUFBWSxFQUFFLEtBQUs7WUFDbkIsU0FBUyxFQUFFLDBDQUEwQztZQUNyRCxTQUFTLEVBQUUsdUJBQXVCO1NBQ25DLENBQUM7UUFDRixZQUFPLEdBQThCO1lBQ25DLEtBQUssRUFBRSxNQUFNO1lBQ2IsTUFBTSxFQUFFLE1BQU07WUFDZCxZQUFZLEVBQUUsS0FBSztZQUNuQixTQUFTLEVBQUUsdUJBQXVCO1lBQ2xDLGVBQWUsRUFBRSxvQkFBb0I7WUFDckMsU0FBUyxFQUFFLGlDQUFpQztTQUM3QyxDQUFDO0lBS0YsQ0FBQzs7OztJQUVELGdCQUFnQjtRQUNkLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxRQUFRLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUN2RCxJQUFJLENBQUMsR0FBRyxDQUFDLENBQ1gsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDO0lBQ3JCLENBQUM7Ozs7O0lBQ0QsaUJBQWlCLENBQUMsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFO1FBQ2hDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ2xDLENBQUM7OztZQTFJRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGNBQWM7Z0JBQ3hCLFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E0Q1Q7Z0JBMERELGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO2dCQUMvQyxtQkFBbUIsRUFBRSxLQUFLO3lCQXpEeEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXNEQzthQUlKOzs7OzsyQkFHRSxLQUFLOzs7Ozs7O0lBQU4sdUNBQThCOztJQUM5QixpQ0FNRTs7SUFDRixrQ0FPRTs7SUFDRiwyQ0FBeUI7O0FBNEIzQixNQUFNLE9BQU8saUJBQWlCOzs7WUFaN0IsUUFBUSxTQUFDO2dCQUNSLFlBQVksRUFBRSxDQUFDLGVBQWUsRUFBRSxxQkFBcUIsQ0FBQztnQkFDdEQsT0FBTyxFQUFFLENBQUMsZUFBZSxFQUFFLHFCQUFxQixDQUFDO2dCQUNqRCxPQUFPLEVBQUU7b0JBQ1AsWUFBWTtvQkFDWixXQUFXO29CQUNYLGdCQUFnQjtvQkFDaEIsbUJBQW1CO29CQUNuQixTQUFTO29CQUNULGdCQUFnQjtpQkFDakI7YUFDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBJbnB1dCxcbiAgTmdNb2R1bGUsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQge1xuICBBbHBoYU1vZHVsZSxcbiAgQ2hlY2tib2FyZE1vZHVsZSxcbiAgQ29sb3JXcmFwLFxuICBFZGl0YWJsZUlucHV0TW9kdWxlLFxuICBIdWVNb2R1bGUsXG4gIFNhdHVyYXRpb25Nb2R1bGUsXG59IGZyb20gJ25neC1jb2xvcic7XG5pbXBvcnQgeyBDaHJvbWVGaWVsZHNDb21wb25lbnQgfSBmcm9tICcuL2Nocm9tZS1maWVsZHMuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY29sb3ItY2hyb21lJyxcbiAgdGVtcGxhdGU6IGBcbiAgPGRpdiBjbGFzcz1cImNocm9tZS1waWNrZXIge3sgY2xhc3NOYW1lIH19XCI+XG4gICAgPGRpdiBjbGFzcz1cInNhdHVyYXRpb25cIj5cbiAgICAgIDxjb2xvci1zYXR1cmF0aW9uXG4gICAgICAgIFtoc2xdPVwiaHNsXCJcbiAgICAgICAgW2hzdl09XCJoc3ZcIlxuICAgICAgICBbY2lyY2xlXT1cImNpcmNsZVwiXG4gICAgICAgIChvbkNoYW5nZSk9XCJoYW5kbGVWYWx1ZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgID48L2NvbG9yLXNhdHVyYXRpb24+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImNocm9tZS1ib2R5XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2hyb21lLWNvbnRyb2xzXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjaHJvbWUtY29sb3JcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2hyb21lLXN3YXRjaFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNocm9tZS1hY3RpdmVcIlxuICAgICAgICAgICAgICBbc3R5bGUuYmFja2dyb3VuZF09XCJhY3RpdmVCYWNrZ3JvdW5kXCJcbiAgICAgICAgICAgID48L2Rpdj5cbiAgICAgICAgICAgIDxjb2xvci1jaGVja2JvYXJkPjwvY29sb3ItY2hlY2tib2FyZD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjaHJvbWUtdG9nZ2xlc1wiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaHJvbWUtaHVlXCI+XG4gICAgICAgICAgICA8Y29sb3ItaHVlXG4gICAgICAgICAgICAgIFtyYWRpdXNdPVwiMlwiXG4gICAgICAgICAgICAgIFtoc2xdPVwiaHNsXCJcbiAgICAgICAgICAgICAgW3BvaW50ZXJdPVwicG9pbnRlclwiXG4gICAgICAgICAgICAgIChvbkNoYW5nZSk9XCJoYW5kbGVWYWx1ZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgID48L2NvbG9yLWh1ZT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2hyb21lLWFscGhhXCIgKm5nSWY9XCIhZGlzYWJsZUFscGhhXCI+XG4gICAgICAgICAgICA8Y29sb3ItYWxwaGFcbiAgICAgICAgICAgICAgW3JhZGl1c109XCIyXCIgW3JnYl09XCJyZ2JcIiBbaHNsXT1cImhzbFwiXG4gICAgICAgICAgICAgIFtwb2ludGVyXT1cInBvaW50ZXJcIiAob25DaGFuZ2UpPVwiaGFuZGxlVmFsdWVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICA+PC9jb2xvci1hbHBoYT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxjb2xvci1jaHJvbWUtZmllbGRzXG4gICAgICAgIFtyZ2JdPVwicmdiXCIgW2hzbF09XCJoc2xcIiBbaGV4XT1cImhleFwiXG4gICAgICAgIFtkaXNhYmxlQWxwaGFdPVwiZGlzYWJsZUFscGhhXCJcbiAgICAgICAgKG9uQ2hhbmdlKT1cImhhbmRsZVZhbHVlQ2hhbmdlKCRldmVudClcIlxuICAgICAgPjwvY29sb3ItY2hyb21lLWZpZWxkcz5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4gIGAsXG4gIHN0eWxlczogW1xuICAgIGBcbiAgICAgIC5jaHJvbWUtcGlja2VyIHtcbiAgICAgICAgYmFja2dyb3VuZDogI2ZmZjtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICAgICAgICBib3gtc2hhZG93OiAwIDAgMnB4IHJnYmEoMCwgMCwgMCwgMC4zKSwgMCA0cHggOHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICAgICAgYm94LXNpemluZzogaW5pdGlhbDtcbiAgICAgICAgd2lkdGg6IDIyNXB4O1xuICAgICAgICBmb250LWZhbWlseTogJ01lbmxvJztcbiAgICAgIH1cbiAgICAgIC5jaHJvbWUtY29udHJvbHMge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgfVxuICAgICAgLmNocm9tZS1jb2xvciB7XG4gICAgICAgIHdpZHRoOiA0MnB4O1xuICAgICAgfVxuICAgICAgLmNocm9tZS1ib2R5IHtcbiAgICAgICAgcGFkZGluZzogMTRweCAxNHB4IDEycHg7XG4gICAgICB9XG4gICAgICAuY2hyb21lLWFjdGl2ZSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBib3R0b206IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAyMHB4O1xuICAgICAgICBib3gtc2hhZG93OiBpbnNldCAwIDAgMCAxcHggcmdiYSgwLCAwLCAwLCAwLjEpO1xuICAgICAgICB6LWluZGV4OiAyO1xuICAgICAgfVxuICAgICAgLmNocm9tZS1zd2F0Y2gge1xuICAgICAgICB3aWR0aDogMjhweDtcbiAgICAgICAgaGVpZ2h0OiAyOHB4O1xuICAgICAgICBib3JkZXItcmFkaXVzOiAxNXB4O1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICB9XG4gICAgICAuc2F0dXJhdGlvbiB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBwYWRkaW5nLWJvdHRvbTogNTUlO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweCAycHggMCAwO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgfVxuICAgICAgLmNocm9tZS10b2dnbGVzIHtcbiAgICAgICAgZmxleDogMTtcbiAgICAgIH1cbiAgICAgIC5jaHJvbWUtaHVlIHtcbiAgICAgICAgaGVpZ2h0OiAxMHB4O1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDhweDtcbiAgICAgIH1cbiAgICAgIC5jaHJvbWUtYWxwaGEge1xuICAgICAgICBoZWlnaHQ6IDEwcHg7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIH1cbiAgICBgLFxuICBdLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG59KVxuZXhwb3J0IGNsYXNzIENocm9tZUNvbXBvbmVudCBleHRlbmRzIENvbG9yV3JhcCB7XG4gIC8qKiBSZW1vdmUgYWxwaGEgc2xpZGVyIGFuZCBvcHRpb25zIGZyb20gcGlja2VyICovXG4gIEBJbnB1dCgpIGRpc2FibGVBbHBoYSA9IGZhbHNlO1xuICBjaXJjbGU6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gICAgd2lkdGg6ICcxMnB4JyxcbiAgICBoZWlnaHQ6ICcxMnB4JyxcbiAgICBib3JkZXJSYWRpdXM6ICc2cHgnLFxuICAgIGJveFNoYWRvdzogJ3JnYigyNTUsIDI1NSwgMjU1KSAwcHggMHB4IDBweCAxcHggaW5zZXQnLFxuICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgtNnB4LCAtOHB4KScsXG4gIH07XG4gIHBvaW50ZXI6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gICAgd2lkdGg6ICcxMnB4JyxcbiAgICBoZWlnaHQ6ICcxMnB4JyxcbiAgICBib3JkZXJSYWRpdXM6ICc2cHgnLFxuICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgtNnB4LCAtMnB4KScsXG4gICAgYmFja2dyb3VuZENvbG9yOiAncmdiKDI0OCwgMjQ4LCAyNDgpJyxcbiAgICBib3hTaGFkb3c6ICcwIDFweCA0cHggMCByZ2JhKDAsIDAsIDAsIDAuMzcpJyxcbiAgfTtcbiAgYWN0aXZlQmFja2dyb3VuZDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBhZnRlclZhbGlkQ2hhbmdlKCkge1xuICAgIHRoaXMuYWN0aXZlQmFja2dyb3VuZCA9IGByZ2JhKCR7dGhpcy5yZ2Iucn0sICR7dGhpcy5yZ2IuZ30sICR7XG4gICAgICB0aGlzLnJnYi5iXG4gICAgfSwgJHt0aGlzLnJnYi5hfSlgO1xuICB9XG4gIGhhbmRsZVZhbHVlQ2hhbmdlKHsgZGF0YSwgJGV2ZW50IH0pIHtcbiAgICB0aGlzLmhhbmRsZUNoYW5nZShkYXRhLCAkZXZlbnQpO1xuICB9XG59XG5cbkBOZ01vZHVsZSh7XG4gIGRlY2xhcmF0aW9uczogW0Nocm9tZUNvbXBvbmVudCwgQ2hyb21lRmllbGRzQ29tcG9uZW50XSxcbiAgZXhwb3J0czogW0Nocm9tZUNvbXBvbmVudCwgQ2hyb21lRmllbGRzQ29tcG9uZW50XSxcbiAgaW1wb3J0czogW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBBbHBoYU1vZHVsZSxcbiAgICBDaGVja2JvYXJkTW9kdWxlLFxuICAgIEVkaXRhYmxlSW5wdXRNb2R1bGUsXG4gICAgSHVlTW9kdWxlLFxuICAgIFNhdHVyYXRpb25Nb2R1bGUsXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIENvbG9yQ2hyb21lTW9kdWxlIHt9XG4iXX0=