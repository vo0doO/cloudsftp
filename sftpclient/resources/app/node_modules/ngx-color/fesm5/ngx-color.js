import { CommonModule } from '@angular/common';
import { ChangeDetectionStrategy, Component, Input, NgModule, Directive, ElementRef, HostListener, Output, EventEmitter } from '@angular/core';
import { Subject, fromEvent } from 'rxjs';
import { distinctUntilChanged, debounceTime } from 'rxjs/operators';
import * as _tinycolor from 'tinycolor2';
import { __assign } from 'tslib';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var checkboardCache = {};
/**
 * @param {?} c1
 * @param {?} c2
 * @param {?} size
 * @return {?}
 */
function render(c1, c2, size) {
    if (typeof document === 'undefined') {
        return null;
    }
    /** @type {?} */
    var canvas = document.createElement('canvas');
    canvas.width = size * 2;
    canvas.height = size * 2;
    /** @type {?} */
    var ctx = canvas.getContext('2d');
    if (!ctx) {
        return null;
    } // If no context can be found, return early.
    ctx.fillStyle = c1;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = c2;
    ctx.fillRect(0, 0, size, size);
    ctx.translate(size, size);
    ctx.fillRect(0, 0, size, size);
    return canvas.toDataURL();
}
/**
 * @param {?} c1
 * @param {?} c2
 * @param {?} size
 * @return {?}
 */
function getCheckerboard(c1, c2, size) {
    /** @type {?} */
    var key = c1 + "-" + c2 + "-" + size;
    if (checkboardCache[key]) {
        return checkboardCache[key];
    }
    /** @type {?} */
    var checkboard = render(c1, c2, size);
    if (!checkboard) {
        return null;
    }
    checkboardCache[key] = checkboard;
    return checkboard;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var CheckboardComponent = /** @class */ (function () {
    function CheckboardComponent() {
        this.white = 'transparent';
        this.size = 8;
        this.grey = 'rgba(0,0,0,.08)';
    }
    /**
     * @return {?}
     */
    CheckboardComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var background = getCheckerboard(this.white, this.grey, this.size);
        this.gridStyles = {
            borderRadius: this.borderRadius,
            boxShadow: this.boxShadow,
            background: "url(" + background + ") center left",
        };
    };
    CheckboardComponent.decorators = [
        { type: Component, args: [{
                    selector: 'color-checkboard',
                    template: "<div class=\"grid\" [ngStyle]=\"gridStyles\"></div>",
                    preserveWhitespaces: false,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: ["\n  .grid {\n    top: 0px;\n    right: 0px;\n    bottom: 0px;\n    left: 0px;\n    position: absolute;\n  }\n  "]
                }] }
    ];
    CheckboardComponent.propDecorators = {
        white: [{ type: Input }],
        size: [{ type: Input }],
        grey: [{ type: Input }],
        boxShadow: [{ type: Input }],
        borderRadius: [{ type: Input }]
    };
    return CheckboardComponent;
}());
var CheckboardModule = /** @class */ (function () {
    function CheckboardModule() {
    }
    CheckboardModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [CheckboardComponent],
                    exports: [CheckboardComponent],
                    imports: [CommonModule],
                },] }
    ];
    return CheckboardModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var CoordinatesDirective = /** @class */ (function () {
    function CoordinatesDirective(el) {
        this.el = el;
        this.coordinatesChange = new Subject();
        this.mousechange = new Subject();
        this.mouseListening = false;
    }
    /**
     * @param {?} $event
     * @param {?} x
     * @param {?} y
     * @param {?=} isTouch
     * @return {?}
     */
    CoordinatesDirective.prototype.mousemove = /**
     * @param {?} $event
     * @param {?} x
     * @param {?} y
     * @param {?=} isTouch
     * @return {?}
     */
    function ($event, x, y, isTouch) {
        if (isTouch === void 0) { isTouch = false; }
        if (this.mouseListening) {
            $event.preventDefault();
            this.mousechange.next({ $event: $event, x: x, y: y, isTouch: isTouch });
        }
    };
    /**
     * @return {?}
     */
    CoordinatesDirective.prototype.mouseup = /**
     * @return {?}
     */
    function () {
        this.mouseListening = false;
    };
    /**
     * @param {?} $event
     * @param {?} x
     * @param {?} y
     * @param {?=} isTouch
     * @return {?}
     */
    CoordinatesDirective.prototype.mousedown = /**
     * @param {?} $event
     * @param {?} x
     * @param {?} y
     * @param {?=} isTouch
     * @return {?}
     */
    function ($event, x, y, isTouch) {
        if (isTouch === void 0) { isTouch = false; }
        $event.preventDefault();
        this.mouseListening = true;
        this.mousechange.next({ $event: $event, x: x, y: y, isTouch: isTouch });
    };
    /**
     * @return {?}
     */
    CoordinatesDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.sub = this.mousechange
            .pipe(
        // limit times it is updated for the same area
        distinctUntilChanged(function (p, q) { return p.x === q.x && p.y === q.y; }))
            .subscribe(function (n) { return _this.handleChange(n.x, n.y, n.$event, n.isTouch); });
    };
    /**
     * @return {?}
     */
    CoordinatesDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.sub.unsubscribe();
    };
    /**
     * @param {?} x
     * @param {?} y
     * @param {?} $event
     * @param {?} isTouch
     * @return {?}
     */
    CoordinatesDirective.prototype.handleChange = /**
     * @param {?} x
     * @param {?} y
     * @param {?} $event
     * @param {?} isTouch
     * @return {?}
     */
    function (x, y, $event, isTouch) {
        /** @type {?} */
        var containerWidth = this.el.nativeElement.clientWidth;
        /** @type {?} */
        var containerHeight = this.el.nativeElement.clientHeight;
        /** @type {?} */
        var left = x -
            (this.el.nativeElement.getBoundingClientRect().left + window.pageXOffset);
        /** @type {?} */
        var top = y - this.el.nativeElement.getBoundingClientRect().top;
        if (!isTouch) {
            top = top - window.pageYOffset;
        }
        this.coordinatesChange.next({
            x: x,
            y: y,
            top: top,
            left: left,
            containerWidth: containerWidth,
            containerHeight: containerHeight,
            $event: $event,
        });
    };
    CoordinatesDirective.decorators = [
        { type: Directive, args: [{ selector: '[ngx-color-coordinates]' },] }
    ];
    /** @nocollapse */
    CoordinatesDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    CoordinatesDirective.propDecorators = {
        coordinatesChange: [{ type: Output }],
        mousemove: [{ type: HostListener, args: ['window:mousemove', ['$event', '$event.pageX', '$event.pageY'],] }, { type: HostListener, args: ['window:touchmove', [
                        '$event',
                        '$event.touches[0].clientX',
                        '$event.touches[0].clientY',
                        'true',
                    ],] }],
        mouseup: [{ type: HostListener, args: ['window:mouseup',] }, { type: HostListener, args: ['window:touchend',] }],
        mousedown: [{ type: HostListener, args: ['mousedown', ['$event', '$event.pageX', '$event.pageY'],] }, { type: HostListener, args: ['touchstart', [
                        '$event',
                        '$event.touches[0].clientX',
                        '$event.touches[0].clientY',
                        'true',
                    ],] }]
    };
    return CoordinatesDirective;
}());
var CoordinatesModule = /** @class */ (function () {
    function CoordinatesModule() {
    }
    CoordinatesModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [CoordinatesDirective],
                    exports: [CoordinatesDirective],
                },] }
    ];
    return CoordinatesModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var AlphaComponent = /** @class */ (function () {
    function AlphaComponent() {
        this.direction = 'horizontal';
        this.onChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    AlphaComponent.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        if (this.direction === 'vertical') {
            this.pointerLeft = 0;
            this.pointerTop = this.rgb.a * 100;
            this.gradient = {
                background: "linear-gradient(to bottom, rgba(" + this.rgb.r + "," + this.rgb.g + "," + this.rgb.b + ", 0) 0%,\n          rgba(" + this.rgb.r + "," + this.rgb.g + "," + this.rgb.b + ", 1) 100%)",
            };
        }
        else {
            this.gradient = {
                background: "linear-gradient(to right, rgba(" + this.rgb.r + "," + this.rgb.g + "," + this.rgb.b + ", 0) 0%,\n          rgba(" + this.rgb.r + "," + this.rgb.g + "," + this.rgb.b + ", 1) 100%)",
            };
            this.pointerLeft = this.rgb.a * 100;
        }
    };
    /**
     * @param {?} __0
     * @return {?}
     */
    AlphaComponent.prototype.handleChange = /**
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var top = _a.top, left = _a.left, containerHeight = _a.containerHeight, containerWidth = _a.containerWidth, $event = _a.$event;
        /** @type {?} */
        var data;
        if (this.direction === 'vertical') {
            /** @type {?} */
            var a = void 0;
            if (top < 0) {
                a = 0;
            }
            else if (top > containerHeight) {
                a = 1;
            }
            else {
                a = Math.round(top * 100 / containerHeight) / 100;
            }
            if (this.hsl.a !== a) {
                data = {
                    h: this.hsl.h,
                    s: this.hsl.s,
                    l: this.hsl.l,
                    a: a,
                    source: 'rgb',
                };
            }
        }
        else {
            /** @type {?} */
            var a = void 0;
            if (left < 0) {
                a = 0;
            }
            else if (left > containerWidth) {
                a = 1;
            }
            else {
                a = Math.round(left * 100 / containerWidth) / 100;
            }
            if (this.hsl.a !== a) {
                data = {
                    h: this.hsl.h,
                    s: this.hsl.s,
                    l: this.hsl.l,
                    a: a,
                    source: 'rgb',
                };
            }
        }
        if (!data) {
            return null;
        }
        this.onChange.emit({ data: data, $event: $event });
    };
    AlphaComponent.decorators = [
        { type: Component, args: [{
                    selector: 'color-alpha',
                    template: "\n  <div class=\"alpha\" [style.border-radius]=\"radius\">\n    <div class=\"alpha-checkboard\">\n      <color-checkboard></color-checkboard>\n    </div>\n    <div class=\"alpha-gradient\" [ngStyle]=\"gradient\" [style.box-shadow]=\"shadow\" [style.border-radius]=\"radius\"></div>\n    <div ngx-color-coordinates (coordinatesChange)=\"handleChange($event)\" class=\"alpha-container color-alpha-{{direction}}\">\n      <div class=\"alpha-pointer\" [style.left.%]=\"pointerLeft\" [style.top.%]=\"pointerTop\">\n        <div class=\"alpha-slider\" [ngStyle]=\"pointer\"></div>\n      </div>\n    </div>\n  </div>\n  ",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    styles: ["\n    .alpha {\n      position: absolute;\n      top: 0;\n      bottom: 0;\n      left: 0;\n      right: 0;\n    }\n    .alpha-checkboard {\n      position: absolute;\n      top: 0;\n      bottom: 0;\n      left: 0;\n      right: 0;\n      overflow: hidden;\n    }\n    .alpha-gradient {\n      position: absolute;\n      top: 0;\n      bottom: 0;\n      left: 0;\n      right: 0;\n    }\n    .alpha-container {\n      position: relative;\n      height: 100%;\n      margin: 0 3px;\n    }\n    .alpha-pointer {\n      position: absolute;\n    }\n    .alpha-slider {\n      width: 4px;\n      border-radius: 1px;\n      height: 8px;\n      box-shadow: 0 0 2px rgba(0, 0, 0, .6);\n      background: #fff;\n      margin-top: 1px;\n      transform: translateX(-2px);\n    },\n  "]
                }] }
    ];
    AlphaComponent.propDecorators = {
        hsl: [{ type: Input }],
        rgb: [{ type: Input }],
        pointer: [{ type: Input }],
        shadow: [{ type: Input }],
        radius: [{ type: Input }],
        direction: [{ type: Input }],
        onChange: [{ type: Output }]
    };
    return AlphaComponent;
}());
var AlphaModule = /** @class */ (function () {
    function AlphaModule() {
    }
    AlphaModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [AlphaComponent],
                    exports: [AlphaComponent],
                    imports: [CommonModule, CheckboardModule, CoordinatesModule],
                },] }
    ];
    return AlphaModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var tinycolor = _tinycolor;
/**
 * @param {?} data
 * @return {?}
 */
function simpleCheckForValidColor(data) {
    /** @type {?} */
    var keysToCheck = ['r', 'g', 'b', 'a', 'h', 's', 'l', 'v'];
    /** @type {?} */
    var checked = 0;
    /** @type {?} */
    var passed = 0;
    keysToCheck.forEach(function (letter) {
        if (!data[letter]) {
            return;
        }
        checked += 1;
        if (!isNaN(data[letter])) {
            passed += 1;
        }
        if (letter === 's' || letter === 'l') {
            /** @type {?} */
            var percentPatt = /^\d+%$/;
            if (percentPatt.test(data[letter])) {
                passed += 1;
            }
        }
    });
    return checked === passed ? data : false;
}
/**
 * @param {?} data
 * @param {?=} oldHue
 * @return {?}
 */
function toState(data, oldHue) {
    /** @type {?} */
    var color = data.hex ? tinycolor(data.hex) : tinycolor(data);
    /** @type {?} */
    var hsl = color.toHsl();
    /** @type {?} */
    var hsv = color.toHsv();
    /** @type {?} */
    var rgb = color.toRgb();
    /** @type {?} */
    var hex = color.toHex();
    if (hsl.s === 0) {
        hsl.h = oldHue || 0;
        hsv.h = oldHue || 0;
    }
    /** @type {?} */
    var transparent = hex === '000000' && rgb.a === 0;
    return {
        hsl: hsl,
        hex: transparent ? 'transparent' : "#" + hex,
        rgb: rgb,
        hsv: hsv,
        oldHue: data.h || oldHue || hsl.h,
        source: data.source,
    };
}
/**
 * @param {?} hex
 * @return {?}
 */
function isValidHex(hex) {
    return tinycolor(hex).isValid();
}
/**
 * @param {?} data
 * @return {?}
 */
function getContrastingColor(data) {
    if (!data) {
        return '#fff';
    }
    /** @type {?} */
    var col = toState(data);
    if (col.hex === 'transparent') {
        return 'rgba(0,0,0,0.4)';
    }
    /** @type {?} */
    var yiq = (col.rgb.r * 299 + col.rgb.g * 587 + col.rgb.b * 114) / 1000;
    return yiq >= 128 ? '#000' : '#fff';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ColorWrap = /** @class */ (function () {
    function ColorWrap() {
        this.className = '';
        this.color = {
            h: 250,
            s: 0.5,
            l: 0.2,
            a: 1,
        };
        this.onChange = new EventEmitter();
        this.onChangeComplete = new EventEmitter();
        this.onSwatchHover = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ColorWrap.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.changes = this.onChange.pipe(debounceTime(100), distinctUntilChanged())
            .subscribe(function (x) { return _this.onChangeComplete.emit(x); });
        this.setState(toState(this.color, 0));
        this.currentColor = this.hex;
    };
    /**
     * @return {?}
     */
    ColorWrap.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        this.setState(toState(this.color, this.oldHue));
    };
    /**
     * @return {?}
     */
    ColorWrap.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.changes.unsubscribe();
    };
    /**
     * @param {?} data
     * @return {?}
     */
    ColorWrap.prototype.setState = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        this.oldHue = data.oldHue;
        this.hsl = data.hsl;
        this.hsv = data.hsv;
        this.rgb = data.rgb;
        this.hex = data.hex;
        this.source = data.source;
        this.afterValidChange();
    };
    /**
     * @param {?} data
     * @param {?} $event
     * @return {?}
     */
    ColorWrap.prototype.handleChange = /**
     * @param {?} data
     * @param {?} $event
     * @return {?}
     */
    function (data, $event) {
        /** @type {?} */
        var isValidColor = simpleCheckForValidColor(data);
        if (isValidColor) {
            /** @type {?} */
            var color = toState(data, data.h || this.oldHue);
            this.setState(color);
            this.onChange.emit({ color: color, $event: $event });
            this.afterValidChange();
        }
    };
    /** hook for components after a complete change */
    /**
     * hook for components after a complete change
     * @return {?}
     */
    ColorWrap.prototype.afterValidChange = /**
     * hook for components after a complete change
     * @return {?}
     */
    function () { };
    /**
     * @param {?} data
     * @param {?} $event
     * @return {?}
     */
    ColorWrap.prototype.handleSwatchHover = /**
     * @param {?} data
     * @param {?} $event
     * @return {?}
     */
    function (data, $event) {
        /** @type {?} */
        var isValidColor = simpleCheckForValidColor(data);
        if (isValidColor) {
            /** @type {?} */
            var color = toState(data, data.h || this.oldHue);
            this.setState(color);
            this.onSwatchHover.emit({ color: color, $event: $event });
        }
    };
    ColorWrap.decorators = [
        { type: Component, args: [{
                    // create seletor base for test override property
                    selector: 'color-wrap',
                    template: ""
                }] }
    ];
    ColorWrap.propDecorators = {
        className: [{ type: Input }],
        color: [{ type: Input }],
        onChange: [{ type: Output }],
        onChangeComplete: [{ type: Output }],
        onSwatchHover: [{ type: Output }]
    };
    return ColorWrap;
}());
var ColorWrapModule = /** @class */ (function () {
    function ColorWrapModule() {
    }
    ColorWrapModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [ColorWrap],
                    exports: [ColorWrap],
                    imports: [CommonModule],
                },] }
    ];
    return ColorWrapModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var EditableInputComponent = /** @class */ (function () {
    function EditableInputComponent() {
        this.placeholder = '';
        this.onChange = new EventEmitter();
        this.focus = false;
    }
    /**
     * @return {?}
     */
    EditableInputComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.wrapStyle = this.style && this.style.wrap ? this.style.wrap : {};
        this.inputStyle = this.style && this.style.input ? this.style.input : {};
        this.labelStyle = this.style && this.style.label ? this.style.label : {};
        if (this.dragLabel) {
            this.labelStyle.cursor = 'ew-resize';
        }
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    EditableInputComponent.prototype.handleFocus = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        this.focus = true;
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    EditableInputComponent.prototype.handleFocusOut = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        this.focus = false;
        this.currentValue = this.blurValue;
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    EditableInputComponent.prototype.handleKeydown = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        var _a, _b;
        // In case `e.target.value` is a percentage remove the `%` character
        // and update accordingly with a percentage
        // https://github.com/casesandberg/react-color/issues/383
        /** @type {?} */
        var stringValue = String($event.target.value);
        /** @type {?} */
        var isPercentage = stringValue.indexOf('%') > -1;
        /** @type {?} */
        var number = Number(stringValue.replace(/%/g, ''));
        if (!isNaN(number)) {
            /** @type {?} */
            var amount = this.arrowOffset || 1;
            // Up
            if ($event.keyCode === 38) {
                if (this.label) {
                    this.onChange.emit({
                        data: (_a = {}, _a[this.label] = number + amount, _a),
                        $event: $event,
                    });
                }
                else {
                    this.onChange.emit({ data: number + amount, $event: $event });
                }
                if (isPercentage) {
                    this.currentValue = number + amount + "%";
                }
                else {
                    this.currentValue = number + amount;
                }
            }
            // Down
            if ($event.keyCode === 40) {
                if (this.label) {
                    this.onChange.emit({
                        data: (_b = {}, _b[this.label] = number - amount, _b),
                        $event: $event,
                    });
                }
                else {
                    this.onChange.emit({ data: number - amount, $event: $event });
                }
                if (isPercentage) {
                    this.currentValue = number - amount + "%";
                }
                else {
                    this.currentValue = number - amount;
                }
            }
        }
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    EditableInputComponent.prototype.handleKeyup = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        var _a;
        if ($event.keyCode === 40 || $event.keyCode === 38) {
            return;
        }
        if (this.label) {
            this.onChange.emit({
                data: (_a = {}, _a[this.label] = $event.target.value, _a),
                $event: $event,
            });
        }
        else {
            this.onChange.emit({ data: $event.target.value, $event: $event });
        }
    };
    /**
     * @return {?}
     */
    EditableInputComponent.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        if (!this.focus) {
            this.currentValue = String(this.value).toUpperCase();
            this.blurValue = String(this.value).toUpperCase();
        }
        else {
            this.blurValue = String(this.value).toUpperCase();
        }
    };
    /**
     * @return {?}
     */
    EditableInputComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.unsubscribe();
    };
    /**
     * @return {?}
     */
    EditableInputComponent.prototype.subscribe = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.mousemove = fromEvent(document, 'mousemove').subscribe(function (ev) {
            return _this.handleDrag(ev);
        });
        this.mouseup = fromEvent(document, 'mouseup').subscribe(function () {
            return _this.unsubscribe();
        });
    };
    /**
     * @return {?}
     */
    EditableInputComponent.prototype.unsubscribe = /**
     * @return {?}
     */
    function () {
        if (this.mousemove) {
            this.mousemove.unsubscribe();
        }
        if (this.mouseup) {
            this.mouseup.unsubscribe();
        }
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    EditableInputComponent.prototype.handleMousedown = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        if (this.dragLabel) {
            $event.preventDefault();
            this.handleDrag($event);
            this.subscribe();
        }
    };
    /**
     * @param {?} $event
     * @return {?}
     */
    EditableInputComponent.prototype.handleDrag = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        var _a;
        if (this.dragLabel) {
            /** @type {?} */
            var newValue = Math.round(this.value + $event.movementX);
            if (newValue >= 0 && newValue <= this.dragMax) {
                this.onChange.emit({ data: (_a = {}, _a[this.label] = newValue, _a), $event: $event });
            }
        }
    };
    EditableInputComponent.decorators = [
        { type: Component, args: [{
                    selector: 'color-editable-input',
                    template: "\n  <div class=\"wrap\" [ngStyle]=\"wrapStyle\">\n    <input [ngStyle]=\"inputStyle\" spellCheck=\"false\"\n      [value]=\"currentValue\" [placeholder]=\"placeholder\"\n      (keydown)=\"handleKeydown($event)\" (keyup)=\"handleKeyup($event)\"\n      (focus)=\"handleFocus($event)\" (focusout)=\"handleFocusOut($event)\" />\n    <span *ngIf=\"label\" [ngStyle]=\"labelStyle\" (mousedown)=\"handleMousedown($event)\">\n      {{ label }}\n    </span>\n  </div>\n  ",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: ["\n    :host {\n      display: flex;\n    }\n    .wrap {\n      position: relative;\n    }\n  "]
                }] }
    ];
    EditableInputComponent.propDecorators = {
        style: [{ type: Input }],
        label: [{ type: Input }],
        value: [{ type: Input }],
        arrowOffset: [{ type: Input }],
        dragLabel: [{ type: Input }],
        dragMax: [{ type: Input }],
        placeholder: [{ type: Input }],
        onChange: [{ type: Output }]
    };
    return EditableInputComponent;
}());
var EditableInputModule = /** @class */ (function () {
    function EditableInputModule() {
    }
    EditableInputModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [EditableInputComponent],
                    exports: [EditableInputComponent],
                    imports: [CommonModule],
                },] }
    ];
    return EditableInputModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var HueComponent = /** @class */ (function () {
    function HueComponent() {
        this.hidePointer = false;
        this.direction = 'horizontal';
        this.onChange = new EventEmitter();
        this.left = '0px';
        this.top = '';
    }
    /**
     * @return {?}
     */
    HueComponent.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        if (this.direction === 'horizontal') {
            this.left = this.hsl.h * 100 / 360 + "%";
        }
        else {
            this.top = -(this.hsl.h * 100 / 360) + 100 + "%";
        }
    };
    /**
     * @param {?} __0
     * @return {?}
     */
    HueComponent.prototype.handleChange = /**
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var top = _a.top, left = _a.left, containerHeight = _a.containerHeight, containerWidth = _a.containerWidth, $event = _a.$event;
        /** @type {?} */
        var data;
        if (this.direction === 'vertical') {
            /** @type {?} */
            var h = void 0;
            if (top < 0) {
                h = 359;
            }
            else if (top > containerHeight) {
                h = 0;
            }
            else {
                /** @type {?} */
                var percent = -(top * 100 / containerHeight) + 100;
                h = 360 * percent / 100;
            }
            if (this.hsl.h !== h) {
                data = {
                    h: h,
                    s: this.hsl.s,
                    l: this.hsl.l,
                    a: this.hsl.a,
                    source: 'rgb',
                };
            }
        }
        else {
            /** @type {?} */
            var h = void 0;
            if (left < 0) {
                h = 0;
            }
            else if (left > containerWidth) {
                h = 359;
            }
            else {
                /** @type {?} */
                var percent = left * 100 / containerWidth;
                h = 360 * percent / 100;
            }
            if (this.hsl.h !== h) {
                data = {
                    h: h,
                    s: this.hsl.s,
                    l: this.hsl.l,
                    a: this.hsl.a,
                    source: 'rgb',
                };
            }
        }
        if (!data) {
            return null;
        }
        this.onChange.emit({ data: data, $event: $event });
    };
    HueComponent.decorators = [
        { type: Component, args: [{
                    selector: 'color-hue',
                    template: "\n  <div class=\"color-hue color-hue-{{direction}}\" [style.border-radius.px]=\"radius\" [style.box-shadow]=\"shadow\">\n    <div ngx-color-coordinates (coordinatesChange)=\"handleChange($event)\" class=\"color-hue-container\">\n      <div class=\"color-hue-pointer\" [style.left]=\"left\" [style.top]=\"top\" *ngIf=\"!hidePointer\">\n        <div class=\"color-hue-slider\" [ngStyle]=\"pointer\"></div>\n      </div>\n    </div>\n  </div>\n  ",
                    preserveWhitespaces: false,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: ["\n    .color-hue {\n      position: absolute;\n      top: 0;\n      bottom: 0;\n      left: 0;\n      right: 0;\n    }\n    .color-hue-container {\n      margin: 0 2px;\n      position: relative;\n      height: 100%;\n    }\n    .color-hue-pointer {\n      position: absolute;\n    }\n    .color-hue-slider {\n      margin-top: 1px;\n      width: 4px;\n      border-radius: 1px;\n      height: 8px;\n      box-shadow: 0 0 2px rgba(0, 0, 0, .6);\n      background: #fff;\n      transform: translateX(-2px);\n    }\n    .color-hue-horizontal {\n      background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0\n        33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n    }\n    .color-hue-vertical {\n      background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%,\n        #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n    }\n  "]
                }] }
    ];
    HueComponent.propDecorators = {
        hsl: [{ type: Input }],
        pointer: [{ type: Input }],
        radius: [{ type: Input }],
        shadow: [{ type: Input }],
        hidePointer: [{ type: Input }],
        direction: [{ type: Input }],
        onChange: [{ type: Output }]
    };
    return HueComponent;
}());
var HueModule = /** @class */ (function () {
    function HueModule() {
    }
    HueModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [HueComponent],
                    exports: [HueComponent],
                    imports: [CommonModule, CoordinatesModule],
                },] }
    ];
    return HueModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var RaisedComponent = /** @class */ (function () {
    function RaisedComponent() {
        this.zDepth = 1;
        this.radius = 1;
        this.background = '#fff';
    }
    RaisedComponent.decorators = [
        { type: Component, args: [{
                    selector: 'color-raised',
                    template: "\n  <div class=\"raised-wrap\">\n    <div class=\"raised-bg zDepth-{{zDepth}}\" [style.background]=\"background\"></div>\n    <div class=\"raised-content\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n  ",
                    preserveWhitespaces: false,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: ["\n    .raised-wrap {\n      position: relative;\n      display: inline-block;\n    }\n    .raised-bg {\n      position: absolute;\n      top: 0px;\n      right: 0px;\n      bottom: 0px;\n      left: 0px;\n    }\n    .raised-content {\n      position: relative;\n    }\n    .zDepth-0 {\n      box-shadow: none;\n    }\n    .zDepth-1 {\n      box-shadow: 0 2px 10px rgba(0,0,0,.12), 0 2px 5px rgba(0,0,0,.16);\n    }\n    .zDepth-2 {\n      box-shadow: 0 6px 20px rgba(0,0,0,.19), 0 8px 17px rgba(0,0,0,.2);\n    }\n    .zDepth-3 {\n      box-shadow: 0 17px 50px rgba(0,0,0,.19), 0 12px 15px rgba(0,0,0,.24);\n    }\n    .zDepth-4 {\n      box-shadow: 0 25px 55px rgba(0,0,0,.21), 0 16px 28px rgba(0,0,0,.22);\n    }\n    .zDepth-5 {\n      box-shadow: 0 40px 77px rgba(0,0,0,.22), 0 27px 24px rgba(0,0,0,.2);\n    }\n  "]
                }] }
    ];
    RaisedComponent.propDecorators = {
        zDepth: [{ type: Input }],
        radius: [{ type: Input }],
        background: [{ type: Input }]
    };
    return RaisedComponent;
}());
var RaisedModule = /** @class */ (function () {
    function RaisedModule() {
    }
    RaisedModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [RaisedComponent],
                    exports: [RaisedComponent],
                    imports: [CommonModule],
                },] }
    ];
    return RaisedModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var SaturationComponent = /** @class */ (function () {
    function SaturationComponent() {
        this.onChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    SaturationComponent.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        this.background = "hsl(" + this.hsl.h + ", 100%, 50%)";
        this.pointerTop = -(this.hsv.v * 100) + 1 + 100 + '%';
        this.pointerLeft = this.hsv.s * 100 + '%';
    };
    /**
     * @param {?} __0
     * @return {?}
     */
    SaturationComponent.prototype.handleChange = /**
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var top = _a.top, left = _a.left, containerHeight = _a.containerHeight, containerWidth = _a.containerWidth, $event = _a.$event;
        if (left < 0) {
            left = 0;
        }
        else if (left > containerWidth) {
            left = containerWidth;
        }
        else if (top < 0) {
            top = 0;
        }
        else if (top > containerHeight) {
            top = containerHeight;
        }
        /** @type {?} */
        var saturation = left / containerWidth;
        /** @type {?} */
        var bright = -(top / containerHeight) + 1;
        bright = bright > 0 ? bright : 0;
        bright = bright > 1 ? 1 : bright;
        /** @type {?} */
        var data = {
            h: this.hsl.h,
            s: saturation,
            v: bright,
            a: this.hsl.a,
            source: 'hsva',
        };
        this.onChange.emit({ data: data, $event: $event });
    };
    SaturationComponent.decorators = [
        { type: Component, args: [{
                    selector: 'color-saturation',
                    template: "\n  <div class=\"color-saturation\" ngx-color-coordinates (coordinatesChange)=\"handleChange($event)\" [style.background]=\"background\">\n    <div class=\"saturation-white\">\n      <div class=\"saturation-black\"></div>\n      <div class=\"saturation-pointer\" [ngStyle]=\"pointer\" [style.top]=\"pointerTop\" [style.left]=\"pointerLeft\">\n        <div class=\"saturation-circle\" [ngStyle]=\"circle\"></div>\n      </div>\n    </div>\n  </div>\n  ",
                    preserveWhitespaces: false,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: ["\n    .saturation-white {\n      background: linear-gradient(to right, #fff, rgba(255,255,255,0));\n      position: absolute;\n      top: 0;\n      bottom: 0;\n      left: 0;\n      right: 0;\n    }\n    .saturation-black {\n      background: linear-gradient(to top, #000, rgba(0,0,0,0));\n      position: absolute;\n      top: 0;\n      bottom: 0;\n      left: 0;\n      right: 0;\n    }\n    .color-saturation {\n      position: absolute;\n      top: 0;\n      bottom: 0;\n      left: 0;\n      right: 0;\n    }\n    .saturation-pointer {\n      position: absolute;\n      cursor: default;\n    }\n    .saturation-circle {\n      width: 4px;\n      height: 4px;\n      box-shadow: 0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3), 0 0 1px 2px rgba(0,0,0,.4);\n      border-radius: 50%;\n      cursor: hand;\n      transform: translate(-2px, -4px);\n    }\n  "]
                }] }
    ];
    SaturationComponent.propDecorators = {
        hsl: [{ type: Input }],
        hsv: [{ type: Input }],
        radius: [{ type: Input }],
        pointer: [{ type: Input }],
        circle: [{ type: Input }],
        onChange: [{ type: Output }]
    };
    return SaturationComponent;
}());
var SaturationModule = /** @class */ (function () {
    function SaturationModule() {
    }
    SaturationModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [SaturationComponent],
                    exports: [SaturationComponent],
                    imports: [CommonModule, CoordinatesModule],
                },] }
    ];
    return SaturationModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var SwatchComponent = /** @class */ (function () {
    function SwatchComponent() {
        this.style = {};
        this.focusStyle = {};
        this.onClick = new EventEmitter();
        this.onHover = new EventEmitter();
        this.divStyles = {};
        this.focusStyles = {};
        this.inFocus = false;
    }
    /**
     * @return {?}
     */
    SwatchComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.divStyles = __assign({ background: this.color, height: '100%', width: '100%', cursor: 'pointer', position: 'relative', outline: 'none' }, this.style);
        this.focusStyles = __assign({}, this.divStyles, this.focusStyle);
    };
    /**
     * @return {?}
     */
    SwatchComponent.prototype.activeStyles = /**
     * @return {?}
     */
    function () {
        return this.focus || this.inFocus ? this.focusStyles : this.divStyles;
    };
    /**
     * @return {?}
     */
    SwatchComponent.prototype.handleFocusOut = /**
     * @return {?}
     */
    function () {
        this.inFocus = false;
    };
    /**
     * @return {?}
     */
    SwatchComponent.prototype.handleFocus = /**
     * @return {?}
     */
    function () {
        this.inFocus = true;
    };
    /**
     * @param {?} hex
     * @param {?} $event
     * @return {?}
     */
    SwatchComponent.prototype.handleHover = /**
     * @param {?} hex
     * @param {?} $event
     * @return {?}
     */
    function (hex, $event) {
        this.onHover.emit({ hex: hex, $event: $event });
    };
    /**
     * @param {?} hex
     * @param {?} $event
     * @return {?}
     */
    SwatchComponent.prototype.handleClick = /**
     * @param {?} hex
     * @param {?} $event
     * @return {?}
     */
    function (hex, $event) {
        this.onClick.emit({ hex: hex, $event: $event });
    };
    SwatchComponent.decorators = [
        { type: Component, args: [{
                    selector: 'color-swatch',
                    template: "\n  <div class=\"swatch\"\n    [ngStyle]=\"activeStyles()\" [attr.title]=\"color\"\n    (click)=\"handleClick(color, $event)\"\n    (keydown.enter)=\"handleClick(color, $event)\"\n    (focus)=\"handleFocus()\"\n    (focusout)=\"handleFocusOut()\"\n    (mouseover)=\"handleHover(color, $event)\"\n    tabindex=\"0\"\n  >\n    <ng-content></ng-content>\n    <color-checkboard\n      *ngIf=\"color === 'transparent'\"\n      boxShadow=\"inset 0 0 0 1px rgba(0,0,0,0.1)\"\n    ></color-checkboard>\n  </div>\n  ",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false
                }] }
    ];
    SwatchComponent.propDecorators = {
        color: [{ type: Input }],
        style: [{ type: Input }],
        focusStyle: [{ type: Input }],
        focus: [{ type: Input }],
        onClick: [{ type: Output }],
        onHover: [{ type: Output }]
    };
    return SwatchComponent;
}());
var SwatchModule = /** @class */ (function () {
    function SwatchModule() {
    }
    SwatchModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [SwatchComponent],
                    exports: [SwatchComponent],
                    imports: [CommonModule, CheckboardModule],
                },] }
    ];
    return SwatchModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { AlphaComponent, AlphaModule, CheckboardComponent, CheckboardModule, ColorWrap, ColorWrapModule, EditableInputComponent, EditableInputModule, HueComponent, HueModule, RaisedComponent, RaisedModule, SaturationComponent, SaturationModule, SwatchComponent, SwatchModule, CoordinatesDirective, CoordinatesModule, render, getCheckerboard, simpleCheckForValidColor, toState, isValidHex, getContrastingColor };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWNvbG9yLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9uZ3gtY29sb3IvaGVscGVycy9jaGVja2JvYXJkLnRzIiwibmc6Ly9uZ3gtY29sb3IvY2hlY2tib2FyZC5jb21wb25lbnQudHMiLCJuZzovL25neC1jb2xvci9jb29yZGluYXRlcy5kaXJlY3RpdmUudHMiLCJuZzovL25neC1jb2xvci9hbHBoYS5jb21wb25lbnQudHMiLCJuZzovL25neC1jb2xvci9oZWxwZXJzL2NvbG9yLnRzIiwibmc6Ly9uZ3gtY29sb3IvY29sb3Itd3JhcC5jb21wb25lbnQudHMiLCJuZzovL25neC1jb2xvci9lZGl0YWJsZS1pbnB1dC5jb21wb25lbnQudHMiLCJuZzovL25neC1jb2xvci9odWUuY29tcG9uZW50LnRzIiwibmc6Ly9uZ3gtY29sb3IvcmFpc2VkLmNvbXBvbmVudC50cyIsIm5nOi8vbmd4LWNvbG9yL3NhdHVyYXRpb24uY29tcG9uZW50LnRzIiwibmc6Ly9uZ3gtY29sb3Ivc3dhdGNoLmNvbXBvbmVudC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjaGVja2JvYXJkQ2FjaGU6IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9ID0ge307XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIoYzE6IHN0cmluZywgYzI6IHN0cmluZywgc2l6ZTogbnVtYmVyKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIGNhbnZhcy53aWR0aCA9IHNpemUgKiAyO1xuICBjYW52YXMuaGVpZ2h0ID0gc2l6ZSAqIDI7XG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBpZiAoIWN0eCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIElmIG5vIGNvbnRleHQgY2FuIGJlIGZvdW5kLCByZXR1cm4gZWFybHkuXG4gIGN0eC5maWxsU3R5bGUgPSBjMTtcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGN0eC5maWxsU3R5bGUgPSBjMjtcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIHNpemUsIHNpemUpO1xuICBjdHgudHJhbnNsYXRlKHNpemUsIHNpemUpO1xuICBjdHguZmlsbFJlY3QoMCwgMCwgc2l6ZSwgc2l6ZSk7XG4gIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGVja2VyYm9hcmQoYzE6IHN0cmluZywgYzI6IHN0cmluZywgc2l6ZTogbnVtYmVyKSB7XG4gIGNvbnN0IGtleSA9IGAke2MxfS0ke2MyfS0ke3NpemV9YDtcbiAgaWYgKGNoZWNrYm9hcmRDYWNoZVtrZXldKSB7XG4gICAgcmV0dXJuIGNoZWNrYm9hcmRDYWNoZVtrZXldO1xuICB9XG4gIGNvbnN0IGNoZWNrYm9hcmQgPSByZW5kZXIoYzEsIGMyLCBzaXplKTtcbiAgaWYgKCFjaGVja2JvYXJkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY2hlY2tib2FyZENhY2hlW2tleV0gPSBjaGVja2JvYXJkO1xuICByZXR1cm4gY2hlY2tib2FyZDtcbn1cbiIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBJbnB1dCxcbiAgTmdNb2R1bGUsXG4gIE9uSW5pdCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IGdldENoZWNrZXJib2FyZCB9IGZyb20gJy4vaGVscGVycy9jaGVja2JvYXJkJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY29sb3ItY2hlY2tib2FyZCcsXG4gIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cImdyaWRcIiBbbmdTdHlsZV09XCJncmlkU3R5bGVzXCI+PC9kaXY+YCxcbiAgc3R5bGVzOiBbXG4gICAgYFxuICAuZ3JpZCB7XG4gICAgdG9wOiAwcHg7XG4gICAgcmlnaHQ6IDBweDtcbiAgICBib3R0b206IDBweDtcbiAgICBsZWZ0OiAwcHg7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICB9XG4gIGAsXG4gIF0sXG4gIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgQ2hlY2tib2FyZENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIEBJbnB1dCgpIHdoaXRlID0gJ3RyYW5zcGFyZW50JztcbiAgQElucHV0KCkgc2l6ZSA9IDg7XG4gIEBJbnB1dCgpIGdyZXkgPSAncmdiYSgwLDAsMCwuMDgpJztcbiAgQElucHV0KCkgYm94U2hhZG93OiBzdHJpbmc7XG4gIEBJbnB1dCgpIGJvcmRlclJhZGl1czogc3RyaW5nO1xuICBncmlkU3R5bGVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG4gIG5nT25Jbml0KCkge1xuICAgIGNvbnN0IGJhY2tncm91bmQgPSBnZXRDaGVja2VyYm9hcmQodGhpcy53aGl0ZSwgdGhpcy5ncmV5LCB0aGlzLnNpemUpO1xuICAgIHRoaXMuZ3JpZFN0eWxlcyA9IHtcbiAgICAgIGJvcmRlclJhZGl1czogdGhpcy5ib3JkZXJSYWRpdXMsXG4gICAgICBib3hTaGFkb3c6IHRoaXMuYm94U2hhZG93LFxuICAgICAgYmFja2dyb3VuZDogYHVybCgke2JhY2tncm91bmR9KSBjZW50ZXIgbGVmdGAsXG4gICAgfTtcbiAgfVxufVxuXG5ATmdNb2R1bGUoe1xuICBkZWNsYXJhdGlvbnM6IFtDaGVja2JvYXJkQ29tcG9uZW50XSxcbiAgZXhwb3J0czogW0NoZWNrYm9hcmRDb21wb25lbnRdLFxuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2hlY2tib2FyZE1vZHVsZSB7fVxuIiwiaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBIb3N0TGlzdGVuZXIsXG4gIE5nTW9kdWxlLFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgU3ViamVjdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW25neC1jb2xvci1jb29yZGluYXRlc10nIH0pXG5leHBvcnQgY2xhc3MgQ29vcmRpbmF0ZXNEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gIEBPdXRwdXQoKVxuICBjb29yZGluYXRlc0NoYW5nZSA9IG5ldyBTdWJqZWN0PHtcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xuICAgIHRvcDogbnVtYmVyO1xuICAgIGxlZnQ6IG51bWJlcjtcbiAgICBjb250YWluZXJXaWR0aDogbnVtYmVyO1xuICAgIGNvbnRhaW5lckhlaWdodDogbnVtYmVyO1xuICAgICRldmVudDogYW55O1xuICB9PigpO1xuICBwcml2YXRlIG1vdXNlY2hhbmdlID0gbmV3IFN1YmplY3Q8e1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG4gICAgJGV2ZW50OiBhbnk7XG4gICAgaXNUb3VjaDogYm9vbGVhbjtcbiAgfT4oKTtcblxuICBwcml2YXRlIG1vdXNlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgc3ViOiBTdWJzY3JpcHRpb247XG4gIEBIb3N0TGlzdGVuZXIoJ3dpbmRvdzptb3VzZW1vdmUnLCBbJyRldmVudCcsICckZXZlbnQucGFnZVgnLCAnJGV2ZW50LnBhZ2VZJ10pXG4gIEBIb3N0TGlzdGVuZXIoJ3dpbmRvdzp0b3VjaG1vdmUnLCBbXG4gICAgJyRldmVudCcsXG4gICAgJyRldmVudC50b3VjaGVzWzBdLmNsaWVudFgnLFxuICAgICckZXZlbnQudG91Y2hlc1swXS5jbGllbnRZJyxcbiAgICAndHJ1ZScsXG4gIF0pXG4gIG1vdXNlbW92ZSgkZXZlbnQ6IEV2ZW50LCB4OiBudW1iZXIsIHk6IG51bWJlciwgaXNUb3VjaCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMubW91c2VMaXN0ZW5pbmcpIHtcbiAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5tb3VzZWNoYW5nZS5uZXh0KHsgJGV2ZW50LCB4LCB5LCBpc1RvdWNoIH0pO1xuICAgIH1cbiAgfVxuICBASG9zdExpc3RlbmVyKCd3aW5kb3c6bW91c2V1cCcpXG4gIEBIb3N0TGlzdGVuZXIoJ3dpbmRvdzp0b3VjaGVuZCcpXG4gIG1vdXNldXAoKSB7XG4gICAgdGhpcy5tb3VzZUxpc3RlbmluZyA9IGZhbHNlO1xuICB9XG4gIEBIb3N0TGlzdGVuZXIoJ21vdXNlZG93bicsIFsnJGV2ZW50JywgJyRldmVudC5wYWdlWCcsICckZXZlbnQucGFnZVknXSlcbiAgQEhvc3RMaXN0ZW5lcigndG91Y2hzdGFydCcsIFtcbiAgICAnJGV2ZW50JyxcbiAgICAnJGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCcsXG4gICAgJyRldmVudC50b3VjaGVzWzBdLmNsaWVudFknLFxuICAgICd0cnVlJyxcbiAgXSlcbiAgbW91c2Vkb3duKCRldmVudDogRXZlbnQsIHg6IG51bWJlciwgeTogbnVtYmVyLCBpc1RvdWNoID0gZmFsc2UpIHtcbiAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLm1vdXNlTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICB0aGlzLm1vdXNlY2hhbmdlLm5leHQoeyAkZXZlbnQsIHgsIHksIGlzVG91Y2ggfSk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsOiBFbGVtZW50UmVmKSB7fVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuc3ViID0gdGhpcy5tb3VzZWNoYW5nZVxuICAgICAgLnBpcGUoXG4gICAgICAgIC8vIGxpbWl0IHRpbWVzIGl0IGlzIHVwZGF0ZWQgZm9yIHRoZSBzYW1lIGFyZWFcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKHAsIHEpID0+IHAueCA9PT0gcS54ICYmIHAueSA9PT0gcS55KSxcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUobiA9PiB0aGlzLmhhbmRsZUNoYW5nZShuLngsIG4ueSwgbi4kZXZlbnQsIG4uaXNUb3VjaCkpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWIudW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIGhhbmRsZUNoYW5nZSh4OiBudW1iZXIsIHk6IG51bWJlciwgJGV2ZW50OiBFdmVudCwgaXNUb3VjaDogYm9vbGVhbikge1xuICAgIGNvbnN0IGNvbnRhaW5lcldpZHRoID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIGNvbnN0IGNvbnRhaW5lckhlaWdodCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgY29uc3QgbGVmdCA9XG4gICAgICB4IC1cbiAgICAgICh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCk7XG4gICAgbGV0IHRvcCA9IHkgLSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuXG4gICAgaWYgKCFpc1RvdWNoKSB7XG4gICAgICB0b3AgPSB0b3AgLSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgfVxuICAgIHRoaXMuY29vcmRpbmF0ZXNDaGFuZ2UubmV4dCh7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICBjb250YWluZXJXaWR0aCxcbiAgICAgIGNvbnRhaW5lckhlaWdodCxcbiAgICAgICRldmVudCxcbiAgICB9KTtcbiAgfVxufVxuXG5ATmdNb2R1bGUoe1xuICBkZWNsYXJhdGlvbnM6IFtDb29yZGluYXRlc0RpcmVjdGl2ZV0sXG4gIGV4cG9ydHM6IFtDb29yZGluYXRlc0RpcmVjdGl2ZV0sXG59KVxuZXhwb3J0IGNsYXNzIENvb3JkaW5hdGVzTW9kdWxlIHt9XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgTmdNb2R1bGUsXG4gIE9uQ2hhbmdlcyxcbiAgT3V0cHV0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2hlY2tib2FyZE1vZHVsZSB9IGZyb20gJy4vY2hlY2tib2FyZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29vcmRpbmF0ZXNNb2R1bGUgfSBmcm9tICcuL2Nvb3JkaW5hdGVzLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBIU0xBLCBSR0JBIH0gZnJvbSAnLi9oZWxwZXJzL2NvbG9yLmludGVyZmFjZXMnO1xuXG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2NvbG9yLWFscGhhJyxcbiAgdGVtcGxhdGU6IGBcbiAgPGRpdiBjbGFzcz1cImFscGhhXCIgW3N0eWxlLmJvcmRlci1yYWRpdXNdPVwicmFkaXVzXCI+XG4gICAgPGRpdiBjbGFzcz1cImFscGhhLWNoZWNrYm9hcmRcIj5cbiAgICAgIDxjb2xvci1jaGVja2JvYXJkPjwvY29sb3ItY2hlY2tib2FyZD5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiYWxwaGEtZ3JhZGllbnRcIiBbbmdTdHlsZV09XCJncmFkaWVudFwiIFtzdHlsZS5ib3gtc2hhZG93XT1cInNoYWRvd1wiIFtzdHlsZS5ib3JkZXItcmFkaXVzXT1cInJhZGl1c1wiPjwvZGl2PlxuICAgIDxkaXYgbmd4LWNvbG9yLWNvb3JkaW5hdGVzIChjb29yZGluYXRlc0NoYW5nZSk9XCJoYW5kbGVDaGFuZ2UoJGV2ZW50KVwiIGNsYXNzPVwiYWxwaGEtY29udGFpbmVyIGNvbG9yLWFscGhhLXt7ZGlyZWN0aW9ufX1cIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJhbHBoYS1wb2ludGVyXCIgW3N0eWxlLmxlZnQuJV09XCJwb2ludGVyTGVmdFwiIFtzdHlsZS50b3AuJV09XCJwb2ludGVyVG9wXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJhbHBoYS1zbGlkZXJcIiBbbmdTdHlsZV09XCJwb2ludGVyXCI+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4gIGAsXG4gIHN0eWxlczogW1xuICAgIGBcbiAgICAuYWxwaGEge1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgdG9wOiAwO1xuICAgICAgYm90dG9tOiAwO1xuICAgICAgbGVmdDogMDtcbiAgICAgIHJpZ2h0OiAwO1xuICAgIH1cbiAgICAuYWxwaGEtY2hlY2tib2FyZCB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB0b3A6IDA7XG4gICAgICBib3R0b206IDA7XG4gICAgICBsZWZ0OiAwO1xuICAgICAgcmlnaHQ6IDA7XG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIH1cbiAgICAuYWxwaGEtZ3JhZGllbnQge1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgdG9wOiAwO1xuICAgICAgYm90dG9tOiAwO1xuICAgICAgbGVmdDogMDtcbiAgICAgIHJpZ2h0OiAwO1xuICAgIH1cbiAgICAuYWxwaGEtY29udGFpbmVyIHtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgIG1hcmdpbjogMCAzcHg7XG4gICAgfVxuICAgIC5hbHBoYS1wb2ludGVyIHtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB9XG4gICAgLmFscGhhLXNsaWRlciB7XG4gICAgICB3aWR0aDogNHB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogMXB4O1xuICAgICAgaGVpZ2h0OiA4cHg7XG4gICAgICBib3gtc2hhZG93OiAwIDAgMnB4IHJnYmEoMCwgMCwgMCwgLjYpO1xuICAgICAgYmFja2dyb3VuZDogI2ZmZjtcbiAgICAgIG1hcmdpbi10b3A6IDFweDtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMnB4KTtcbiAgICB9LFxuICBgLFxuICBdLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG59KVxuZXhwb3J0IGNsYXNzIEFscGhhQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgaHNsOiBIU0xBO1xuICBASW5wdXQoKSByZ2I6IFJHQkE7XG4gIEBJbnB1dCgpIHBvaW50ZXI6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG4gIEBJbnB1dCgpIHNoYWRvdzogc3RyaW5nO1xuICBASW5wdXQoKSByYWRpdXM6IHN0cmluZztcbiAgQElucHV0KCkgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcgfCAndmVydGljYWwnID0gJ2hvcml6b250YWwnO1xuICBAT3V0cHV0KCkgb25DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgZ3JhZGllbnQ6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG4gIHBvaW50ZXJMZWZ0OiBudW1iZXI7XG4gIHBvaW50ZXJUb3A6IG51bWJlcjtcblxuICBuZ09uQ2hhbmdlcygpIHtcbiAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgIHRoaXMucG9pbnRlckxlZnQgPSAwO1xuICAgICAgdGhpcy5wb2ludGVyVG9wID0gdGhpcy5yZ2IuYSAqIDEwMDtcbiAgICAgIHRoaXMuZ3JhZGllbnQgPSB7XG4gICAgICAgIGJhY2tncm91bmQ6IGBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCByZ2JhKCR7dGhpcy5yZ2Iucn0sJHtcbiAgICAgICAgICB0aGlzLnJnYi5nXG4gICAgICAgIH0sJHt0aGlzLnJnYi5ifSwgMCkgMCUsXG4gICAgICAgICAgcmdiYSgke3RoaXMucmdiLnJ9LCR7dGhpcy5yZ2IuZ30sJHt0aGlzLnJnYi5ifSwgMSkgMTAwJSlgLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ncmFkaWVudCA9IHtcbiAgICAgICAgYmFja2dyb3VuZDogYGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgcmdiYSgke3RoaXMucmdiLnJ9LCR7XG4gICAgICAgICAgdGhpcy5yZ2IuZ1xuICAgICAgICB9LCR7dGhpcy5yZ2IuYn0sIDApIDAlLFxuICAgICAgICAgIHJnYmEoJHt0aGlzLnJnYi5yfSwke3RoaXMucmdiLmd9LCR7dGhpcy5yZ2IuYn0sIDEpIDEwMCUpYCxcbiAgICAgIH07XG4gICAgICB0aGlzLnBvaW50ZXJMZWZ0ID0gdGhpcy5yZ2IuYSAqIDEwMDtcbiAgICB9XG4gIH1cbiAgaGFuZGxlQ2hhbmdlKHsgdG9wLCBsZWZ0LCBjb250YWluZXJIZWlnaHQsIGNvbnRhaW5lcldpZHRoLCAkZXZlbnQgfSkge1xuICAgIGxldCBkYXRhO1xuICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgbGV0IGE7XG4gICAgICBpZiAodG9wIDwgMCkge1xuICAgICAgICBhID0gMDtcbiAgICAgIH0gZWxzZSBpZiAodG9wID4gY29udGFpbmVySGVpZ2h0KSB7XG4gICAgICAgIGEgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYSA9IE1hdGgucm91bmQodG9wICogMTAwIC8gY29udGFpbmVySGVpZ2h0KSAvIDEwMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaHNsLmEgIT09IGEpIHtcbiAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICBoOiB0aGlzLmhzbC5oLFxuICAgICAgICAgIHM6IHRoaXMuaHNsLnMsXG4gICAgICAgICAgbDogdGhpcy5oc2wubCxcbiAgICAgICAgICBhLFxuICAgICAgICAgIHNvdXJjZTogJ3JnYicsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBhO1xuICAgICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICAgIGEgPSAwO1xuICAgICAgfSBlbHNlIGlmIChsZWZ0ID4gY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgYSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhID0gTWF0aC5yb3VuZChsZWZ0ICogMTAwIC8gY29udGFpbmVyV2lkdGgpIC8gMTAwO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5oc2wuYSAhPT0gYSkge1xuICAgICAgICBkYXRhID0ge1xuICAgICAgICAgIGg6IHRoaXMuaHNsLmgsXG4gICAgICAgICAgczogdGhpcy5oc2wucyxcbiAgICAgICAgICBsOiB0aGlzLmhzbC5sLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgc291cmNlOiAncmdiJyxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5vbkNoYW5nZS5lbWl0KHsgZGF0YSwgJGV2ZW50IH0pO1xuICB9XG59XG5cbkBOZ01vZHVsZSh7XG4gIGRlY2xhcmF0aW9uczogW0FscGhhQ29tcG9uZW50XSxcbiAgZXhwb3J0czogW0FscGhhQ29tcG9uZW50XSxcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2hlY2tib2FyZE1vZHVsZSwgQ29vcmRpbmF0ZXNNb2R1bGVdLFxufSlcbmV4cG9ydCBjbGFzcyBBbHBoYU1vZHVsZSB7fVxuIiwiaW1wb3J0ICogYXMgX3Rpbnljb2xvciBmcm9tICd0aW55Y29sb3IyJztcblxuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuL2NvbG9yLmludGVyZmFjZXMnO1xuXG5jb25zdCB0aW55Y29sb3IgPSBfdGlueWNvbG9yO1xuXG5leHBvcnQgZnVuY3Rpb24gc2ltcGxlQ2hlY2tGb3JWYWxpZENvbG9yKGRhdGEpIHtcbiAgY29uc3Qga2V5c1RvQ2hlY2sgPSBbJ3InLCAnZycsICdiJywgJ2EnLCAnaCcsICdzJywgJ2wnLCAndiddO1xuICBsZXQgY2hlY2tlZCA9IDA7XG4gIGxldCBwYXNzZWQgPSAwO1xuICBrZXlzVG9DaGVjay5mb3JFYWNoKGxldHRlciA9PiB7XG4gICAgaWYgKCFkYXRhW2xldHRlcl0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2hlY2tlZCArPSAxO1xuICAgIGlmICghaXNOYU4oZGF0YVtsZXR0ZXJdKSkge1xuICAgICAgcGFzc2VkICs9IDE7XG4gICAgfVxuICAgIGlmIChsZXR0ZXIgPT09ICdzJyB8fCBsZXR0ZXIgPT09ICdsJykge1xuICAgICAgY29uc3QgcGVyY2VudFBhdHQgPSAvXlxcZCslJC87XG4gICAgICBpZiAocGVyY2VudFBhdHQudGVzdChkYXRhW2xldHRlcl0pKSB7XG4gICAgICAgIHBhc3NlZCArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjaGVja2VkID09PSBwYXNzZWQgPyBkYXRhIDogZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1N0YXRlKGRhdGEsIG9sZEh1ZT86IG51bWJlcik6IENvbG9yIHtcbiAgY29uc3QgY29sb3IgPSBkYXRhLmhleCA/IHRpbnljb2xvcihkYXRhLmhleCkgOiB0aW55Y29sb3IoZGF0YSk7XG4gIGNvbnN0IGhzbCA9IGNvbG9yLnRvSHNsKCk7XG4gIGNvbnN0IGhzdiA9IGNvbG9yLnRvSHN2KCk7XG4gIGNvbnN0IHJnYiA9IGNvbG9yLnRvUmdiKCk7XG4gIGNvbnN0IGhleCA9IGNvbG9yLnRvSGV4KCk7XG4gIGlmIChoc2wucyA9PT0gMCkge1xuICAgIGhzbC5oID0gb2xkSHVlIHx8IDA7XG4gICAgaHN2LmggPSBvbGRIdWUgfHwgMDtcbiAgfVxuICBjb25zdCB0cmFuc3BhcmVudCA9IGhleCA9PT0gJzAwMDAwMCcgJiYgcmdiLmEgPT09IDA7XG5cbiAgcmV0dXJuIHtcbiAgICBoc2wsXG4gICAgaGV4OiB0cmFuc3BhcmVudCA/ICd0cmFuc3BhcmVudCcgOiBgIyR7aGV4fWAsXG4gICAgcmdiLFxuICAgIGhzdixcbiAgICBvbGRIdWU6IGRhdGEuaCB8fCBvbGRIdWUgfHwgaHNsLmgsXG4gICAgc291cmNlOiBkYXRhLnNvdXJjZSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRIZXgoaGV4OiBzdHJpbmcpIHtcbiAgcmV0dXJuIHRpbnljb2xvcihoZXgpLmlzVmFsaWQoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRyYXN0aW5nQ29sb3IoZGF0YSkge1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm4gJyNmZmYnO1xuICB9XG4gIGNvbnN0IGNvbCA9IHRvU3RhdGUoZGF0YSk7XG4gIGlmIChjb2wuaGV4ID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgcmV0dXJuICdyZ2JhKDAsMCwwLDAuNCknO1xuICB9XG4gIGNvbnN0IHlpcSA9IChjb2wucmdiLnIgKiAyOTkgKyBjb2wucmdiLmcgKiA1ODcgKyBjb2wucmdiLmIgKiAxMTQpIC8gMTAwMDtcbiAgcmV0dXJuIHlpcSA+PSAxMjggPyAnIzAwMCcgOiAnI2ZmZic7XG59XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBOZ01vZHVsZSxcbiAgT25DaGFuZ2VzLFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUsICBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgc2ltcGxlQ2hlY2tGb3JWYWxpZENvbG9yLCB0b1N0YXRlIH0gZnJvbSAnLi9oZWxwZXJzL2NvbG9yJztcbmltcG9ydCB7IENvbG9yLCBIU0xBLCBIU1ZBLCBSR0JBIH0gZnJvbSAnLi9oZWxwZXJzL2NvbG9yLmludGVyZmFjZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbG9yRXZlbnQge1xuICAkZXZlbnQ6IEV2ZW50O1xuICBjb2xvcjogQ29sb3I7XG59XG5cbkBDb21wb25lbnQoe1xuICAvLyBjcmVhdGUgc2VsZXRvciBiYXNlIGZvciB0ZXN0IG92ZXJyaWRlIHByb3BlcnR5XG4gIHNlbGVjdG9yOiAnY29sb3Itd3JhcCcsXG4gIHRlbXBsYXRlOiBgYCxcbn0pXG5leHBvcnQgY2xhc3MgQ29sb3JXcmFwIGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gIEBJbnB1dCgpIGNsYXNzTmFtZSA9ICcnO1xuICBASW5wdXQoKSBjb2xvcjogSFNMQSA9IHtcbiAgICBoOiAyNTAsXG4gICAgczogMC41LFxuICAgIGw6IDAuMixcbiAgICBhOiAxLFxuICB9O1xuICBAT3V0cHV0KCkgb25DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPENvbG9yRXZlbnQ+KCk7XG4gIEBPdXRwdXQoKSBvbkNoYW5nZUNvbXBsZXRlID0gbmV3IEV2ZW50RW1pdHRlcjxDb2xvckV2ZW50PigpO1xuICBAT3V0cHV0KCkgb25Td2F0Y2hIb3ZlciA9IG5ldyBFdmVudEVtaXR0ZXI8Q29sb3JFdmVudD4oKTtcbiAgb2xkSHVlOiBudW1iZXI7XG4gIGhzbDogSFNMQTtcbiAgaHN2OiBIU1ZBO1xuICByZ2I6IFJHQkE7XG4gIGhleDogc3RyaW5nO1xuICBzb3VyY2U6IHN0cmluZztcbiAgY3VycmVudENvbG9yOiBzdHJpbmc7XG4gIGNoYW5nZXM6IFN1YnNjcmlwdGlvbjtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLmNoYW5nZXMgPSB0aGlzLm9uQ2hhbmdlLnBpcGUoXG4gICAgICAgIGRlYm91bmNlVGltZSgxMDApLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSh4ID0+IHRoaXMub25DaGFuZ2VDb21wbGV0ZS5lbWl0KHgpKTtcbiAgICB0aGlzLnNldFN0YXRlKHRvU3RhdGUodGhpcy5jb2xvciwgMCkpO1xuICAgIHRoaXMuY3VycmVudENvbG9yID0gdGhpcy5oZXg7XG4gIH1cbiAgbmdPbkNoYW5nZXMoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh0b1N0YXRlKHRoaXMuY29sb3IsIHRoaXMub2xkSHVlKSk7XG4gIH1cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5jaGFuZ2VzLnVuc3Vic2NyaWJlKCk7XG4gIH1cbiAgc2V0U3RhdGUoZGF0YSkge1xuICAgIHRoaXMub2xkSHVlID0gZGF0YS5vbGRIdWU7XG4gICAgdGhpcy5oc2wgPSBkYXRhLmhzbDtcbiAgICB0aGlzLmhzdiA9IGRhdGEuaHN2O1xuICAgIHRoaXMucmdiID0gZGF0YS5yZ2I7XG4gICAgdGhpcy5oZXggPSBkYXRhLmhleDtcbiAgICB0aGlzLnNvdXJjZSA9IGRhdGEuc291cmNlO1xuICAgIHRoaXMuYWZ0ZXJWYWxpZENoYW5nZSgpO1xuICB9XG4gIGhhbmRsZUNoYW5nZShkYXRhLCAkZXZlbnQpIHtcbiAgICBjb25zdCBpc1ZhbGlkQ29sb3IgPSBzaW1wbGVDaGVja0ZvclZhbGlkQ29sb3IoZGF0YSk7XG4gICAgaWYgKGlzVmFsaWRDb2xvcikge1xuICAgICAgY29uc3QgY29sb3IgPSB0b1N0YXRlKGRhdGEsIGRhdGEuaCB8fCB0aGlzLm9sZEh1ZSk7XG4gICAgICB0aGlzLnNldFN0YXRlKGNvbG9yKTtcbiAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7IGNvbG9yLCAkZXZlbnQgfSk7XG4gICAgICB0aGlzLmFmdGVyVmFsaWRDaGFuZ2UoKTtcbiAgICB9XG4gIH1cbiAgLyoqIGhvb2sgZm9yIGNvbXBvbmVudHMgYWZ0ZXIgYSBjb21wbGV0ZSBjaGFuZ2UgKi9cbiAgYWZ0ZXJWYWxpZENoYW5nZSgpIHt9XG5cbiAgaGFuZGxlU3dhdGNoSG92ZXIoZGF0YSwgJGV2ZW50KSB7XG4gICAgY29uc3QgaXNWYWxpZENvbG9yID0gc2ltcGxlQ2hlY2tGb3JWYWxpZENvbG9yKGRhdGEpO1xuICAgIGlmIChpc1ZhbGlkQ29sb3IpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gdG9TdGF0ZShkYXRhLCBkYXRhLmggfHwgdGhpcy5vbGRIdWUpO1xuICAgICAgdGhpcy5zZXRTdGF0ZShjb2xvcik7XG4gICAgICB0aGlzLm9uU3dhdGNoSG92ZXIuZW1pdCh7IGNvbG9yLCAkZXZlbnQgfSk7XG4gICAgfVxuICB9XG59XG5cbkBOZ01vZHVsZSh7XG4gIGRlY2xhcmF0aW9uczogW0NvbG9yV3JhcF0sXG4gIGV4cG9ydHM6IFtDb2xvcldyYXBdLFxuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ29sb3JXcmFwTW9kdWxlIHt9XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgTmdNb2R1bGUsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE91dHB1dCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IGZyb21FdmVudCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2NvbG9yLWVkaXRhYmxlLWlucHV0JyxcbiAgdGVtcGxhdGU6IGBcbiAgPGRpdiBjbGFzcz1cIndyYXBcIiBbbmdTdHlsZV09XCJ3cmFwU3R5bGVcIj5cbiAgICA8aW5wdXQgW25nU3R5bGVdPVwiaW5wdXRTdHlsZVwiIHNwZWxsQ2hlY2s9XCJmYWxzZVwiXG4gICAgICBbdmFsdWVdPVwiY3VycmVudFZhbHVlXCIgW3BsYWNlaG9sZGVyXT1cInBsYWNlaG9sZGVyXCJcbiAgICAgIChrZXlkb3duKT1cImhhbmRsZUtleWRvd24oJGV2ZW50KVwiIChrZXl1cCk9XCJoYW5kbGVLZXl1cCgkZXZlbnQpXCJcbiAgICAgIChmb2N1cyk9XCJoYW5kbGVGb2N1cygkZXZlbnQpXCIgKGZvY3Vzb3V0KT1cImhhbmRsZUZvY3VzT3V0KCRldmVudClcIiAvPlxuICAgIDxzcGFuICpuZ0lmPVwibGFiZWxcIiBbbmdTdHlsZV09XCJsYWJlbFN0eWxlXCIgKG1vdXNlZG93bik9XCJoYW5kbGVNb3VzZWRvd24oJGV2ZW50KVwiPlxuICAgICAge3sgbGFiZWwgfX1cbiAgICA8L3NwYW4+XG4gIDwvZGl2PlxuICBgLFxuICBzdHlsZXM6IFtcbiAgICBgXG4gICAgOmhvc3Qge1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICB9XG4gICAgLndyYXAge1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIH1cbiAgYCxcbiAgXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIEVkaXRhYmxlSW5wdXRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcbiAgQElucHV0KCkgc3R5bGU6IHtcbiAgICB3cmFwOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICAgIGlucHV0OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICAgIGxhYmVsOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICB9O1xuICBASW5wdXQoKSBsYWJlbDogc3RyaW5nO1xuICBASW5wdXQoKSB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyO1xuICBASW5wdXQoKSBhcnJvd09mZnNldDogbnVtYmVyO1xuICBASW5wdXQoKSBkcmFnTGFiZWw6IGJvb2xlYW47XG4gIEBJbnB1dCgpIGRyYWdNYXg6IG51bWJlcjtcbiAgQElucHV0KCkgcGxhY2Vob2xkZXIgPSAnJztcbiAgQE91dHB1dCgpIG9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBjdXJyZW50VmFsdWU6IHN0cmluZyB8IG51bWJlcjtcbiAgYmx1clZhbHVlOiBzdHJpbmc7XG4gIHdyYXBTdHlsZTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgaW5wdXRTdHlsZTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgbGFiZWxTdHlsZTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgZm9jdXMgPSBmYWxzZTtcbiAgbW91c2Vtb3ZlOiBTdWJzY3JpcHRpb247XG4gIG1vdXNldXA6IFN1YnNjcmlwdGlvbjtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLndyYXBTdHlsZSA9IHRoaXMuc3R5bGUgJiYgdGhpcy5zdHlsZS53cmFwID8gdGhpcy5zdHlsZS53cmFwIDoge307XG4gICAgdGhpcy5pbnB1dFN0eWxlID0gdGhpcy5zdHlsZSAmJiB0aGlzLnN0eWxlLmlucHV0ID8gdGhpcy5zdHlsZS5pbnB1dCA6IHt9O1xuICAgIHRoaXMubGFiZWxTdHlsZSA9IHRoaXMuc3R5bGUgJiYgdGhpcy5zdHlsZS5sYWJlbCA/IHRoaXMuc3R5bGUubGFiZWwgOiB7fTtcbiAgICBpZiAodGhpcy5kcmFnTGFiZWwpIHtcbiAgICAgIHRoaXMubGFiZWxTdHlsZS5jdXJzb3IgPSAnZXctcmVzaXplJztcbiAgICB9XG4gIH1cbiAgaGFuZGxlRm9jdXMoJGV2ZW50KSB7XG4gICAgdGhpcy5mb2N1cyA9IHRydWU7XG4gIH1cbiAgaGFuZGxlRm9jdXNPdXQoJGV2ZW50KSB7XG4gICAgdGhpcy5mb2N1cyA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudFZhbHVlID0gdGhpcy5ibHVyVmFsdWU7XG4gIH1cbiAgaGFuZGxlS2V5ZG93bigkZXZlbnQpIHtcbiAgICAvLyBJbiBjYXNlIGBlLnRhcmdldC52YWx1ZWAgaXMgYSBwZXJjZW50YWdlIHJlbW92ZSB0aGUgYCVgIGNoYXJhY3RlclxuICAgIC8vIGFuZCB1cGRhdGUgYWNjb3JkaW5nbHkgd2l0aCBhIHBlcmNlbnRhZ2VcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2FzZXNhbmRiZXJnL3JlYWN0LWNvbG9yL2lzc3Vlcy8zODNcbiAgICBjb25zdCBzdHJpbmdWYWx1ZSA9IFN0cmluZygkZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICBjb25zdCBpc1BlcmNlbnRhZ2UgPSBzdHJpbmdWYWx1ZS5pbmRleE9mKCclJykgPiAtMTtcbiAgICBjb25zdCBudW1iZXIgPSBOdW1iZXIoc3RyaW5nVmFsdWUucmVwbGFjZSgvJS9nLCAnJykpO1xuICAgIGlmICghaXNOYU4obnVtYmVyKSkge1xuICAgICAgY29uc3QgYW1vdW50ID0gdGhpcy5hcnJvd09mZnNldCB8fCAxO1xuXG4gICAgICAvLyBVcFxuICAgICAgaWYgKCRldmVudC5rZXlDb2RlID09PSAzOCkge1xuICAgICAgICBpZiAodGhpcy5sYWJlbCkge1xuICAgICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7XG4gICAgICAgICAgICBkYXRhOiB7IFt0aGlzLmxhYmVsXTogbnVtYmVyICsgYW1vdW50IH0sXG4gICAgICAgICAgICAkZXZlbnQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkNoYW5nZS5lbWl0KHsgZGF0YTogbnVtYmVyICsgYW1vdW50LCAkZXZlbnQgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQZXJjZW50YWdlKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBgJHtudW1iZXIgKyBhbW91bnR9JWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBudW1iZXIgKyBhbW91bnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRG93blxuICAgICAgaWYgKCRldmVudC5rZXlDb2RlID09PSA0MCkge1xuICAgICAgICBpZiAodGhpcy5sYWJlbCkge1xuICAgICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7XG4gICAgICAgICAgICBkYXRhOiB7IFt0aGlzLmxhYmVsXTogbnVtYmVyIC0gYW1vdW50IH0sXG4gICAgICAgICAgICAkZXZlbnQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkNoYW5nZS5lbWl0KHsgZGF0YTogbnVtYmVyIC0gYW1vdW50LCAkZXZlbnQgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQZXJjZW50YWdlKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBgJHtudW1iZXIgLSBhbW91bnR9JWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBudW1iZXIgLSBhbW91bnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFuZGxlS2V5dXAoJGV2ZW50KSB7XG4gICAgaWYgKCRldmVudC5rZXlDb2RlID09PSA0MCB8fCAkZXZlbnQua2V5Q29kZSA9PT0gMzgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubGFiZWwpIHtcbiAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7XG4gICAgICAgIGRhdGE6IHsgW3RoaXMubGFiZWxdOiAkZXZlbnQudGFyZ2V0LnZhbHVlIH0sXG4gICAgICAgICRldmVudCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoeyBkYXRhOiAkZXZlbnQudGFyZ2V0LnZhbHVlLCAkZXZlbnQgfSk7XG4gICAgfVxuICB9XG4gIG5nT25DaGFuZ2VzKCkge1xuICAgIGlmICghdGhpcy5mb2N1cykge1xuICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBTdHJpbmcodGhpcy52YWx1ZSkudG9VcHBlckNhc2UoKTtcbiAgICAgIHRoaXMuYmx1clZhbHVlID0gU3RyaW5nKHRoaXMudmFsdWUpLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmx1clZhbHVlID0gU3RyaW5nKHRoaXMudmFsdWUpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICB9XG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgfVxuICBzdWJzY3JpYmUoKSB7XG4gICAgdGhpcy5tb3VzZW1vdmUgPSBmcm9tRXZlbnQoZG9jdW1lbnQsICdtb3VzZW1vdmUnKS5zdWJzY3JpYmUoKGV2OiBFdmVudCkgPT5cbiAgICAgIHRoaXMuaGFuZGxlRHJhZyhldiksXG4gICAgKTtcbiAgICB0aGlzLm1vdXNldXAgPSBmcm9tRXZlbnQoZG9jdW1lbnQsICdtb3VzZXVwJykuc3Vic2NyaWJlKCgpID0+XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlKCksXG4gICAgKTtcbiAgfVxuICB1bnN1YnNjcmliZSgpIHtcbiAgICBpZiAodGhpcy5tb3VzZW1vdmUpIHtcbiAgICAgIHRoaXMubW91c2Vtb3ZlLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1vdXNldXApIHtcbiAgICAgIHRoaXMubW91c2V1cC51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVNb3VzZWRvd24oJGV2ZW50OiBFdmVudCkge1xuICAgIGlmICh0aGlzLmRyYWdMYWJlbCkge1xuICAgICAgJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLmhhbmRsZURyYWcoJGV2ZW50KTtcbiAgICAgIHRoaXMuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG4gIGhhbmRsZURyYWcoJGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZHJhZ0xhYmVsKSB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IE1hdGgucm91bmQodGhpcy52YWx1ZSArICRldmVudC5tb3ZlbWVudFgpO1xuICAgICAgaWYgKG5ld1ZhbHVlID49IDAgJiYgbmV3VmFsdWUgPD0gdGhpcy5kcmFnTWF4KSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7IGRhdGE6IHsgW3RoaXMubGFiZWxdOiBuZXdWYWx1ZSB9LCAkZXZlbnQgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbkBOZ01vZHVsZSh7XG4gIGRlY2xhcmF0aW9uczogW0VkaXRhYmxlSW5wdXRDb21wb25lbnRdLFxuICBleHBvcnRzOiBbRWRpdGFibGVJbnB1dENvbXBvbmVudF0sXG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxufSlcbmV4cG9ydCBjbGFzcyBFZGl0YWJsZUlucHV0TW9kdWxlIHt9XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgTmdNb2R1bGUsXG4gIE9uQ2hhbmdlcyxcbiAgT3V0cHV0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ29vcmRpbmF0ZXNNb2R1bGUgfSBmcm9tICcuL2Nvb3JkaW5hdGVzLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBIU0xBLCBIU0xBc291cmNlIH0gZnJvbSAnLi9oZWxwZXJzL2NvbG9yLmludGVyZmFjZXMnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjb2xvci1odWUnLFxuICB0ZW1wbGF0ZTogYFxuICA8ZGl2IGNsYXNzPVwiY29sb3ItaHVlIGNvbG9yLWh1ZS17e2RpcmVjdGlvbn19XCIgW3N0eWxlLmJvcmRlci1yYWRpdXMucHhdPVwicmFkaXVzXCIgW3N0eWxlLmJveC1zaGFkb3ddPVwic2hhZG93XCI+XG4gICAgPGRpdiBuZ3gtY29sb3ItY29vcmRpbmF0ZXMgKGNvb3JkaW5hdGVzQ2hhbmdlKT1cImhhbmRsZUNoYW5nZSgkZXZlbnQpXCIgY2xhc3M9XCJjb2xvci1odWUtY29udGFpbmVyXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY29sb3ItaHVlLXBvaW50ZXJcIiBbc3R5bGUubGVmdF09XCJsZWZ0XCIgW3N0eWxlLnRvcF09XCJ0b3BcIiAqbmdJZj1cIiFoaWRlUG9pbnRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29sb3ItaHVlLXNsaWRlclwiIFtuZ1N0eWxlXT1cInBvaW50ZXJcIj48L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbiAgYCxcbiAgc3R5bGVzOiBbXG4gICAgYFxuICAgIC5jb2xvci1odWUge1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgdG9wOiAwO1xuICAgICAgYm90dG9tOiAwO1xuICAgICAgbGVmdDogMDtcbiAgICAgIHJpZ2h0OiAwO1xuICAgIH1cbiAgICAuY29sb3ItaHVlLWNvbnRhaW5lciB7XG4gICAgICBtYXJnaW46IDAgMnB4O1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cbiAgICAuY29sb3ItaHVlLXBvaW50ZXIge1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIH1cbiAgICAuY29sb3ItaHVlLXNsaWRlciB7XG4gICAgICBtYXJnaW4tdG9wOiAxcHg7XG4gICAgICB3aWR0aDogNHB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogMXB4O1xuICAgICAgaGVpZ2h0OiA4cHg7XG4gICAgICBib3gtc2hhZG93OiAwIDAgMnB4IHJnYmEoMCwgMCwgMCwgLjYpO1xuICAgICAgYmFja2dyb3VuZDogI2ZmZjtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMnB4KTtcbiAgICB9XG4gICAgLmNvbG9yLWh1ZS1ob3Jpem9udGFsIHtcbiAgICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgI2YwMCAwJSwgI2ZmMCAxNyUsICMwZjBcbiAgICAgICAgMzMlLCAjMGZmIDUwJSwgIzAwZiA2NyUsICNmMGYgODMlLCAjZjAwIDEwMCUpO1xuICAgIH1cbiAgICAuY29sb3ItaHVlLXZlcnRpY2FsIHtcbiAgICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byB0b3AsICNmMDAgMCUsICNmZjAgMTclLCAjMGYwIDMzJSxcbiAgICAgICAgIzBmZiA1MCUsICMwMGYgNjclLCAjZjBmIDgzJSwgI2YwMCAxMDAlKTtcbiAgICB9XG4gIGAsXG4gIF0sXG4gIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgSHVlQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgaHNsOiBIU0xBO1xuICBASW5wdXQoKSBwb2ludGVyOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICBASW5wdXQoKSByYWRpdXM6IG51bWJlcjtcbiAgQElucHV0KCkgc2hhZG93OiBzdHJpbmc7XG4gIEBJbnB1dCgpIGhpZGVQb2ludGVyID0gZmFsc2U7XG4gIEBJbnB1dCgpIGRpcmVjdGlvbjogJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJyA9ICdob3Jpem9udGFsJztcbiAgQE91dHB1dCgpIG9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjx7IGRhdGE6IEhTTEFzb3VyY2U7ICRldmVudDogRXZlbnQgfT4oKTtcbiAgbGVmdCA9ICcwcHgnO1xuICB0b3AgPSAnJztcblxuICBuZ09uQ2hhbmdlcygpIHtcbiAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgdGhpcy5sZWZ0ID0gYCR7dGhpcy5oc2wuaCAqIDEwMCAvIDM2MH0lYDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50b3AgPSBgJHstKHRoaXMuaHNsLmggKiAxMDAgLyAzNjApICsgMTAwfSVgO1xuICAgIH1cbiAgfVxuICBoYW5kbGVDaGFuZ2UoeyB0b3AsIGxlZnQsIGNvbnRhaW5lckhlaWdodCwgY29udGFpbmVyV2lkdGgsICRldmVudCB9KSB7XG4gICAgbGV0IGRhdGE6IEhTTEFzb3VyY2U7XG4gICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICBsZXQgaDtcbiAgICAgIGlmICh0b3AgPCAwKSB7XG4gICAgICAgIGggPSAzNTk7XG4gICAgICB9IGVsc2UgaWYgKHRvcCA+IGNvbnRhaW5lckhlaWdodCkge1xuICAgICAgICBoID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBlcmNlbnQgPSAtKHRvcCAqIDEwMCAvIGNvbnRhaW5lckhlaWdodCkgKyAxMDA7XG4gICAgICAgIGggPSAzNjAgKiBwZXJjZW50IC8gMTAwO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5oc2wuaCAhPT0gaCkge1xuICAgICAgICBkYXRhID0ge1xuICAgICAgICAgIGgsXG4gICAgICAgICAgczogdGhpcy5oc2wucyxcbiAgICAgICAgICBsOiB0aGlzLmhzbC5sLFxuICAgICAgICAgIGE6IHRoaXMuaHNsLmEsXG4gICAgICAgICAgc291cmNlOiAncmdiJyxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGg7XG4gICAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgICAgaCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGxlZnQgPiBjb250YWluZXJXaWR0aCkge1xuICAgICAgICBoID0gMzU5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcGVyY2VudCA9IGxlZnQgKiAxMDAgLyBjb250YWluZXJXaWR0aDtcbiAgICAgICAgaCA9IDM2MCAqIHBlcmNlbnQgLyAxMDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhzbC5oICE9PSBoKSB7XG4gICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgaCxcbiAgICAgICAgICBzOiB0aGlzLmhzbC5zLFxuICAgICAgICAgIGw6IHRoaXMuaHNsLmwsXG4gICAgICAgICAgYTogdGhpcy5oc2wuYSxcbiAgICAgICAgICBzb3VyY2U6ICdyZ2InLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoeyBkYXRhLCAkZXZlbnQgfSk7XG4gIH1cbn1cblxuQE5nTW9kdWxlKHtcbiAgZGVjbGFyYXRpb25zOiBbSHVlQ29tcG9uZW50XSxcbiAgZXhwb3J0czogW0h1ZUNvbXBvbmVudF0sXG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENvb3JkaW5hdGVzTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgSHVlTW9kdWxlIHt9XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgSW5wdXQsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2NvbG9yLXJhaXNlZCcsXG4gIHRlbXBsYXRlOiBgXG4gIDxkaXYgY2xhc3M9XCJyYWlzZWQtd3JhcFwiPlxuICAgIDxkaXYgY2xhc3M9XCJyYWlzZWQtYmcgekRlcHRoLXt7ekRlcHRofX1cIiBbc3R5bGUuYmFja2dyb3VuZF09XCJiYWNrZ3JvdW5kXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInJhaXNlZC1jb250ZW50XCI+XG4gICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuICBgLFxuICBzdHlsZXM6IFtgXG4gICAgLnJhaXNlZC13cmFwIHtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICB9XG4gICAgLnJhaXNlZC1iZyB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB0b3A6IDBweDtcbiAgICAgIHJpZ2h0OiAwcHg7XG4gICAgICBib3R0b206IDBweDtcbiAgICAgIGxlZnQ6IDBweDtcbiAgICB9XG4gICAgLnJhaXNlZC1jb250ZW50IHtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB9XG4gICAgLnpEZXB0aC0wIHtcbiAgICAgIGJveC1zaGFkb3c6IG5vbmU7XG4gICAgfVxuICAgIC56RGVwdGgtMSB7XG4gICAgICBib3gtc2hhZG93OiAwIDJweCAxMHB4IHJnYmEoMCwwLDAsLjEyKSwgMCAycHggNXB4IHJnYmEoMCwwLDAsLjE2KTtcbiAgICB9XG4gICAgLnpEZXB0aC0yIHtcbiAgICAgIGJveC1zaGFkb3c6IDAgNnB4IDIwcHggcmdiYSgwLDAsMCwuMTkpLCAwIDhweCAxN3B4IHJnYmEoMCwwLDAsLjIpO1xuICAgIH1cbiAgICAuekRlcHRoLTMge1xuICAgICAgYm94LXNoYWRvdzogMCAxN3B4IDUwcHggcmdiYSgwLDAsMCwuMTkpLCAwIDEycHggMTVweCByZ2JhKDAsMCwwLC4yNCk7XG4gICAgfVxuICAgIC56RGVwdGgtNCB7XG4gICAgICBib3gtc2hhZG93OiAwIDI1cHggNTVweCByZ2JhKDAsMCwwLC4yMSksIDAgMTZweCAyOHB4IHJnYmEoMCwwLDAsLjIyKTtcbiAgICB9XG4gICAgLnpEZXB0aC01IHtcbiAgICAgIGJveC1zaGFkb3c6IDAgNDBweCA3N3B4IHJnYmEoMCwwLDAsLjIyKSwgMCAyN3B4IDI0cHggcmdiYSgwLDAsMCwuMik7XG4gICAgfVxuICBgXSxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBSYWlzZWRDb21wb25lbnQge1xuICBASW5wdXQoKSB6RGVwdGg6IDAgfCAxIHwgMiB8IDMgfCA0IHwgNSAgPSAxO1xuICBASW5wdXQoKSByYWRpdXMgPSAxO1xuICBASW5wdXQoKSBiYWNrZ3JvdW5kID0gJyNmZmYnO1xufVxuXG5ATmdNb2R1bGUoe1xuICBkZWNsYXJhdGlvbnM6IFtSYWlzZWRDb21wb25lbnRdLFxuICBleHBvcnRzOiBbUmFpc2VkQ29tcG9uZW50XSxcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXG59KVxuZXhwb3J0IGNsYXNzIFJhaXNlZE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBOZ01vZHVsZSxcbiAgT25DaGFuZ2VzLFxuICBPdXRwdXQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5cbmltcG9ydCB7IENvb3JkaW5hdGVzTW9kdWxlIH0gZnJvbSAnLi9jb29yZGluYXRlcy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSFNMQSwgSFNWQSwgSFNWQXNvdXJjZSB9IGZyb20gJy4vaGVscGVycy9jb2xvci5pbnRlcmZhY2VzJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY29sb3Itc2F0dXJhdGlvbicsXG4gIHRlbXBsYXRlOiBgXG4gIDxkaXYgY2xhc3M9XCJjb2xvci1zYXR1cmF0aW9uXCIgbmd4LWNvbG9yLWNvb3JkaW5hdGVzIChjb29yZGluYXRlc0NoYW5nZSk9XCJoYW5kbGVDaGFuZ2UoJGV2ZW50KVwiIFtzdHlsZS5iYWNrZ3JvdW5kXT1cImJhY2tncm91bmRcIj5cbiAgICA8ZGl2IGNsYXNzPVwic2F0dXJhdGlvbi13aGl0ZVwiPlxuICAgICAgPGRpdiBjbGFzcz1cInNhdHVyYXRpb24tYmxhY2tcIj48L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJzYXR1cmF0aW9uLXBvaW50ZXJcIiBbbmdTdHlsZV09XCJwb2ludGVyXCIgW3N0eWxlLnRvcF09XCJwb2ludGVyVG9wXCIgW3N0eWxlLmxlZnRdPVwicG9pbnRlckxlZnRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNhdHVyYXRpb24tY2lyY2xlXCIgW25nU3R5bGVdPVwiY2lyY2xlXCI+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4gIGAsXG4gIHN0eWxlczogW1xuICAgIGBcbiAgICAuc2F0dXJhdGlvbi13aGl0ZSB7XG4gICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsICNmZmYsIHJnYmEoMjU1LDI1NSwyNTUsMCkpO1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgdG9wOiAwO1xuICAgICAgYm90dG9tOiAwO1xuICAgICAgbGVmdDogMDtcbiAgICAgIHJpZ2h0OiAwO1xuICAgIH1cbiAgICAuc2F0dXJhdGlvbi1ibGFjayB7XG4gICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gdG9wLCAjMDAwLCByZ2JhKDAsMCwwLDApKTtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHRvcDogMDtcbiAgICAgIGJvdHRvbTogMDtcbiAgICAgIGxlZnQ6IDA7XG4gICAgICByaWdodDogMDtcbiAgICB9XG4gICAgLmNvbG9yLXNhdHVyYXRpb24ge1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgdG9wOiAwO1xuICAgICAgYm90dG9tOiAwO1xuICAgICAgbGVmdDogMDtcbiAgICAgIHJpZ2h0OiAwO1xuICAgIH1cbiAgICAuc2F0dXJhdGlvbi1wb2ludGVyIHtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGN1cnNvcjogZGVmYXVsdDtcbiAgICB9XG4gICAgLnNhdHVyYXRpb24tY2lyY2xlIHtcbiAgICAgIHdpZHRoOiA0cHg7XG4gICAgICBoZWlnaHQ6IDRweDtcbiAgICAgIGJveC1zaGFkb3c6IDAgMCAwIDEuNXB4ICNmZmYsIGluc2V0IDAgMCAxcHggMXB4IHJnYmEoMCwwLDAsLjMpLCAwIDAgMXB4IDJweCByZ2JhKDAsMCwwLC40KTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgIGN1cnNvcjogaGFuZDtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC0ycHgsIC00cHgpO1xuICAgIH1cbiAgYCxcbiAgXSxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBTYXR1cmF0aW9uQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgaHNsOiBIU0xBO1xuICBASW5wdXQoKSBoc3Y6IEhTVkE7XG4gIEBJbnB1dCgpIHJhZGl1czogbnVtYmVyO1xuICBASW5wdXQoKSBwb2ludGVyOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICBASW5wdXQoKSBjaXJjbGU6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG4gIEBPdXRwdXQoKSBvbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8eyBkYXRhOiBIU1ZBc291cmNlOyAkZXZlbnQ6IEV2ZW50IH0+KCk7XG4gIGJhY2tncm91bmQ6IHN0cmluZztcbiAgcG9pbnRlclRvcDogc3RyaW5nO1xuICBwb2ludGVyTGVmdDogc3RyaW5nO1xuXG4gIG5nT25DaGFuZ2VzKCkge1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IGBoc2woJHt0aGlzLmhzbC5ofSwgMTAwJSwgNTAlKWA7XG4gICAgdGhpcy5wb2ludGVyVG9wID0gLSh0aGlzLmhzdi52ICogMTAwKSArIDEgKyAxMDAgKyAnJSc7XG4gICAgdGhpcy5wb2ludGVyTGVmdCA9IHRoaXMuaHN2LnMgKiAxMDAgKyAnJSc7XG4gIH1cbiAgaGFuZGxlQ2hhbmdlKHsgdG9wLCBsZWZ0LCBjb250YWluZXJIZWlnaHQsIGNvbnRhaW5lcldpZHRoLCAkZXZlbnQgfSkge1xuICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgbGVmdCA9IDA7XG4gICAgfSBlbHNlIGlmIChsZWZ0ID4gY29udGFpbmVyV2lkdGgpIHtcbiAgICAgIGxlZnQgPSBjb250YWluZXJXaWR0aDtcbiAgICB9IGVsc2UgaWYgKHRvcCA8IDApIHtcbiAgICAgIHRvcCA9IDA7XG4gICAgfSBlbHNlIGlmICh0b3AgPiBjb250YWluZXJIZWlnaHQpIHtcbiAgICAgIHRvcCA9IGNvbnRhaW5lckhlaWdodDtcbiAgICB9XG5cbiAgICBjb25zdCBzYXR1cmF0aW9uID0gbGVmdCAvIGNvbnRhaW5lcldpZHRoO1xuICAgIGxldCBicmlnaHQgPSAtKHRvcCAvIGNvbnRhaW5lckhlaWdodCkgKyAxO1xuICAgIGJyaWdodCA9IGJyaWdodCA+IDAgPyBicmlnaHQgOiAwO1xuICAgIGJyaWdodCA9IGJyaWdodCA+IDEgPyAxIDogYnJpZ2h0O1xuXG4gICAgY29uc3QgZGF0YTogSFNWQXNvdXJjZSA9IHtcbiAgICAgIGg6IHRoaXMuaHNsLmgsXG4gICAgICBzOiBzYXR1cmF0aW9uLFxuICAgICAgdjogYnJpZ2h0LFxuICAgICAgYTogdGhpcy5oc2wuYSxcbiAgICAgIHNvdXJjZTogJ2hzdmEnLFxuICAgIH07XG4gICAgdGhpcy5vbkNoYW5nZS5lbWl0KHsgZGF0YSwgJGV2ZW50IH0pO1xuICB9XG59XG5cbkBOZ01vZHVsZSh7XG4gIGRlY2xhcmF0aW9uczogW1NhdHVyYXRpb25Db21wb25lbnRdLFxuICBleHBvcnRzOiBbU2F0dXJhdGlvbkNvbXBvbmVudF0sXG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENvb3JkaW5hdGVzTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgU2F0dXJhdGlvbk1vZHVsZSB7fVxuIiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE5nTW9kdWxlLFxuICBPbkluaXQsXG4gIE91dHB1dCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENoZWNrYm9hcmRNb2R1bGUgfSBmcm9tICcuL2NoZWNrYm9hcmQuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY29sb3Itc3dhdGNoJyxcbiAgdGVtcGxhdGU6IGBcbiAgPGRpdiBjbGFzcz1cInN3YXRjaFwiXG4gICAgW25nU3R5bGVdPVwiYWN0aXZlU3R5bGVzKClcIiBbYXR0ci50aXRsZV09XCJjb2xvclwiXG4gICAgKGNsaWNrKT1cImhhbmRsZUNsaWNrKGNvbG9yLCAkZXZlbnQpXCJcbiAgICAoa2V5ZG93bi5lbnRlcik9XCJoYW5kbGVDbGljayhjb2xvciwgJGV2ZW50KVwiXG4gICAgKGZvY3VzKT1cImhhbmRsZUZvY3VzKClcIlxuICAgIChmb2N1c291dCk9XCJoYW5kbGVGb2N1c091dCgpXCJcbiAgICAobW91c2VvdmVyKT1cImhhbmRsZUhvdmVyKGNvbG9yLCAkZXZlbnQpXCJcbiAgICB0YWJpbmRleD1cIjBcIlxuICA+XG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDxjb2xvci1jaGVja2JvYXJkXG4gICAgICAqbmdJZj1cImNvbG9yID09PSAndHJhbnNwYXJlbnQnXCJcbiAgICAgIGJveFNoYWRvdz1cImluc2V0IDAgMCAwIDFweCByZ2JhKDAsMCwwLDAuMSlcIlxuICAgID48L2NvbG9yLWNoZWNrYm9hcmQ+XG4gIDwvZGl2PlxuICBgLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG59KVxuZXhwb3J0IGNsYXNzIFN3YXRjaENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIEBJbnB1dCgpIGNvbG9yO1xuICBASW5wdXQoKSBzdHlsZTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuICBASW5wdXQoKSBmb2N1c1N0eWxlOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gIEBJbnB1dCgpIGZvY3VzOiBib29sZWFuO1xuICBAT3V0cHV0KCkgb25DbGljayA9IG5ldyBFdmVudEVtaXR0ZXI8eyBoZXg6IHN0cmluZywgJGV2ZW50OiBFdmVudH0+KCk7XG4gIEBPdXRwdXQoKSBvbkhvdmVyID0gbmV3IEV2ZW50RW1pdHRlcjx7IGhleDogc3RyaW5nLCAkZXZlbnQ6IEV2ZW50fT4oKTtcbiAgZGl2U3R5bGVzOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSA9IHt9O1xuICBmb2N1c1N0eWxlczoge1trZXk6IHN0cmluZ106IHN0cmluZ30gPSB7fTtcbiAgaW5Gb2N1cyA9IGZhbHNlO1xuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuZGl2U3R5bGVzID0ge1xuICAgICAgYmFja2dyb3VuZDogdGhpcy5jb2xvcixcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgICAuLi50aGlzLnN0eWxlLFxuICAgIH07XG4gICAgdGhpcy5mb2N1c1N0eWxlcyA9IHtcbiAgICAgIC4uLnRoaXMuZGl2U3R5bGVzLFxuICAgICAgLi4udGhpcy5mb2N1c1N0eWxlLFxuICAgIH07XG4gIH1cbiAgYWN0aXZlU3R5bGVzKCkge1xuICAgIHJldHVybiB0aGlzLmZvY3VzIHx8IHRoaXMuaW5Gb2N1cyA/IHRoaXMuZm9jdXNTdHlsZXMgOiB0aGlzLmRpdlN0eWxlcztcbiAgfVxuICBoYW5kbGVGb2N1c091dCgpIHtcbiAgICB0aGlzLmluRm9jdXMgPSBmYWxzZTtcbiAgfVxuICBoYW5kbGVGb2N1cygpIHtcbiAgICB0aGlzLmluRm9jdXMgPSB0cnVlO1xuICB9XG4gIGhhbmRsZUhvdmVyKGhleCwgJGV2ZW50KSB7XG4gICAgdGhpcy5vbkhvdmVyLmVtaXQoeyBoZXgsICRldmVudCB9KTtcbiAgfVxuICBoYW5kbGVDbGljayhoZXgsICRldmVudCkge1xuICAgIHRoaXMub25DbGljay5lbWl0KHsgaGV4LCAkZXZlbnQgfSk7XG4gIH1cbn1cblxuQE5nTW9kdWxlKHtcbiAgZGVjbGFyYXRpb25zOiBbU3dhdGNoQ29tcG9uZW50XSxcbiAgZXhwb3J0czogW1N3YXRjaENvbXBvbmVudF0sXG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENoZWNrYm9hcmRNb2R1bGVdLFxufSlcbmV4cG9ydCBjbGFzcyBTd2F0Y2hNb2R1bGUge31cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFBTSxlQUFlLEdBQTRCLEVBQUU7Ozs7Ozs7QUFFbkQsU0FBZ0IsTUFBTSxDQUFDLEVBQVUsRUFBRSxFQUFVLEVBQUUsSUFBWTtJQUN6RCxJQUFJLE9BQU8sUUFBUSxLQUFLLFdBQVcsRUFBRTtRQUNuQyxPQUFPLElBQUksQ0FBQztLQUNiOztRQUNLLE1BQU0sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQztJQUMvQyxNQUFNLENBQUMsS0FBSyxHQUFHLElBQUksR0FBRyxDQUFDLENBQUM7SUFDeEIsTUFBTSxDQUFDLE1BQU0sR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDOztRQUNuQixHQUFHLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7SUFDbkMsSUFBSSxDQUFDLEdBQUcsRUFBRTtRQUNSLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFDRCxHQUFHLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztJQUNuQixHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDaEQsR0FBRyxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7SUFDbkIsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUMvQixHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUMxQixHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQy9CLE9BQU8sTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDO0NBQzNCOzs7Ozs7O0FBRUQsU0FBZ0IsZUFBZSxDQUFDLEVBQVUsRUFBRSxFQUFVLEVBQUUsSUFBWTs7UUFDNUQsR0FBRyxHQUFNLEVBQUUsU0FBSSxFQUFFLFNBQUksSUFBTTtJQUNqQyxJQUFJLGVBQWUsQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUN4QixPQUFPLGVBQWUsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUM3Qjs7UUFDSyxVQUFVLEdBQUcsTUFBTSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsSUFBSSxDQUFDO0lBQ3ZDLElBQUksQ0FBQyxVQUFVLEVBQUU7UUFDZixPQUFPLElBQUksQ0FBQztLQUNiO0lBQ0QsZUFBZSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFVBQVUsQ0FBQztJQUNsQyxPQUFPLFVBQVUsQ0FBQztDQUNuQjs7Ozs7O0FDakNEO0lBV0E7UUFrQlcsVUFBSyxHQUFHLGFBQWEsQ0FBQztRQUN0QixTQUFJLEdBQUcsQ0FBQyxDQUFDO1FBQ1QsU0FBSSxHQUFHLGlCQUFpQixDQUFDO0tBYW5DOzs7O0lBUkMsc0NBQVE7OztJQUFSOztZQUNRLFVBQVUsR0FBRyxlQUFlLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDcEUsSUFBSSxDQUFDLFVBQVUsR0FBRztZQUNoQixZQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVk7WUFDL0IsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTO1lBQ3pCLFVBQVUsRUFBRSxTQUFPLFVBQVUsa0JBQWU7U0FDN0MsQ0FBQztLQUNIOztnQkFoQ0YsU0FBUyxTQUFDO29CQUNULFFBQVEsRUFBRSxrQkFBa0I7b0JBQzVCLFFBQVEsRUFBRSxxREFBaUQ7b0JBWTNELG1CQUFtQixFQUFFLEtBQUs7b0JBQzFCLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNOzZCQVg3QyxpSEFRRDtpQkFJRjs7O3dCQUVFLEtBQUs7dUJBQ0wsS0FBSzt1QkFDTCxLQUFLOzRCQUNMLEtBQUs7K0JBQ0wsS0FBSzs7SUFXUiwwQkFBQztDQWpDRCxJQWlDQzs7SUFFRDtLQUtnQzs7Z0JBTC9CLFFBQVEsU0FBQztvQkFDUixZQUFZLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQztvQkFDbkMsT0FBTyxFQUFFLENBQUMsbUJBQW1CLENBQUM7b0JBQzlCLE9BQU8sRUFBRSxDQUFDLFlBQVksQ0FBQztpQkFDeEI7O0lBQzhCLHVCQUFDO0NBTGhDOzs7Ozs7QUM5Q0E7SUFpRUUsOEJBQW9CLEVBQWM7UUFBZCxPQUFFLEdBQUYsRUFBRSxDQUFZO1FBakRsQyxzQkFBaUIsR0FBRyxJQUFJLE9BQU8sRUFRM0IsQ0FBQztRQUNHLGdCQUFXLEdBQUcsSUFBSSxPQUFPLEVBSzdCLENBQUM7UUFFRyxtQkFBYyxHQUFHLEtBQUssQ0FBQztLQWlDTzs7Ozs7Ozs7SUF4QnRDLHdDQUFTOzs7Ozs7O0lBUFQsVUFPVSxNQUFhLEVBQUUsQ0FBUyxFQUFFLENBQVMsRUFBRSxPQUFlO1FBQWYsd0JBQUEsRUFBQSxlQUFlO1FBQzVELElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUN2QixNQUFNLENBQUMsY0FBYyxFQUFFLENBQUM7WUFDeEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLFFBQUEsRUFBRSxDQUFDLEdBQUEsRUFBRSxDQUFDLEdBQUEsRUFBRSxPQUFPLFNBQUEsRUFBRSxDQUFDLENBQUM7U0FDbEQ7S0FDRjs7OztJQUdELHNDQUFPOzs7SUFGUDtRQUdFLElBQUksQ0FBQyxjQUFjLEdBQUcsS0FBSyxDQUFDO0tBQzdCOzs7Ozs7OztJQVFELHdDQUFTOzs7Ozs7O0lBUFQsVUFPVSxNQUFhLEVBQUUsQ0FBUyxFQUFFLENBQVMsRUFBRSxPQUFlO1FBQWYsd0JBQUEsRUFBQSxlQUFlO1FBQzVELE1BQU0sQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUN4QixJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQztRQUMzQixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFLE1BQU0sUUFBQSxFQUFFLENBQUMsR0FBQSxFQUFFLENBQUMsR0FBQSxFQUFFLE9BQU8sU0FBQSxFQUFFLENBQUMsQ0FBQztLQUNsRDs7OztJQUlELHVDQUFROzs7SUFBUjtRQUFBLGlCQU9DO1FBTkMsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsV0FBVzthQUN4QixJQUFJOztRQUVILG9CQUFvQixDQUFDLFVBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSyxPQUFBLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUEsQ0FBQyxDQUMzRDthQUNBLFNBQVMsQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLEtBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFBLENBQUMsQ0FBQztLQUNyRTs7OztJQUVELDBDQUFXOzs7SUFBWDtRQUNFLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxFQUFFLENBQUM7S0FDeEI7Ozs7Ozs7O0lBRUQsMkNBQVk7Ozs7Ozs7SUFBWixVQUFhLENBQVMsRUFBRSxDQUFTLEVBQUUsTUFBYSxFQUFFLE9BQWdCOztZQUMxRCxjQUFjLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsV0FBVzs7WUFDbEQsZUFBZSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLFlBQVk7O1lBQ3BELElBQUksR0FDUixDQUFDO2FBQ0EsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQzs7WUFDdkUsR0FBRyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLEdBQUc7UUFFL0QsSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNaLEdBQUcsR0FBRyxHQUFHLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQztTQUNoQztRQUNELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUM7WUFDMUIsQ0FBQyxHQUFBO1lBQ0QsQ0FBQyxHQUFBO1lBQ0QsR0FBRyxLQUFBO1lBQ0gsSUFBSSxNQUFBO1lBQ0osY0FBYyxnQkFBQTtZQUNkLGVBQWUsaUJBQUE7WUFDZixNQUFNLFFBQUE7U0FDUCxDQUFDLENBQUM7S0FDSjs7Z0JBdkZGLFNBQVMsU0FBQyxFQUFFLFFBQVEsRUFBRSx5QkFBeUIsRUFBRTs7OztnQkFYaEQsVUFBVTs7O29DQWFULE1BQU07NEJBbUJOLFlBQVksU0FBQyxrQkFBa0IsRUFBRSxDQUFDLFFBQVEsRUFBRSxjQUFjLEVBQUUsY0FBYyxDQUFDLGNBQzNFLFlBQVksU0FBQyxrQkFBa0IsRUFBRTt3QkFDaEMsUUFBUTt3QkFDUiwyQkFBMkI7d0JBQzNCLDJCQUEyQjt3QkFDM0IsTUFBTTtxQkFDUDswQkFPQSxZQUFZLFNBQUMsZ0JBQWdCLGNBQzdCLFlBQVksU0FBQyxpQkFBaUI7NEJBSTlCLFlBQVksU0FBQyxXQUFXLEVBQUUsQ0FBQyxRQUFRLEVBQUUsY0FBYyxFQUFFLGNBQWMsQ0FBQyxjQUNwRSxZQUFZLFNBQUMsWUFBWSxFQUFFO3dCQUMxQixRQUFRO3dCQUNSLDJCQUEyQjt3QkFDM0IsMkJBQTJCO3dCQUMzQixNQUFNO3FCQUNQOztJQTJDSCwyQkFBQztDQXhGRCxJQXdGQzs7SUFFRDtLQUlpQzs7Z0JBSmhDLFFBQVEsU0FBQztvQkFDUixZQUFZLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQztvQkFDcEMsT0FBTyxFQUFFLENBQUMsb0JBQW9CLENBQUM7aUJBQ2hDOztJQUMrQix3QkFBQztDQUpqQzs7Ozs7O0FDdkdBO0lBZ0JBO1FBbUVXLGNBQVMsR0FBOEIsWUFBWSxDQUFDO1FBQ25ELGFBQVEsR0FBRyxJQUFJLFlBQVksRUFBTyxDQUFDO0tBdUU5Qzs7OztJQWxFQyxvQ0FBVzs7O0lBQVg7UUFDRSxJQUFJLElBQUksQ0FBQyxTQUFTLEtBQUssVUFBVSxFQUFFO1lBQ2pDLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDO1lBQ3JCLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO1lBQ25DLElBQUksQ0FBQyxRQUFRLEdBQUc7Z0JBQ2QsVUFBVSxFQUFFLHFDQUFtQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsU0FDdkQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQ1IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLGlDQUNMLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxTQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxTQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxlQUFZO2FBQzVELENBQUM7U0FDSDthQUFNO1lBQ0wsSUFBSSxDQUFDLFFBQVEsR0FBRztnQkFDZCxVQUFVLEVBQUUsb0NBQWtDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxTQUN0RCxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsU0FDUixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsaUNBQ0wsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLGVBQVk7YUFDNUQsQ0FBQztZQUNGLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO1NBQ3JDO0tBQ0Y7Ozs7O0lBQ0QscUNBQVk7Ozs7SUFBWixVQUFhLEVBQXNEO1lBQXBELFlBQUcsRUFBRSxjQUFJLEVBQUUsb0NBQWUsRUFBRSxrQ0FBYyxFQUFFLGtCQUFNOztZQUMzRCxJQUFJO1FBQ1IsSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLFVBQVUsRUFBRTs7Z0JBQzdCLENBQUMsU0FBQTtZQUNMLElBQUksR0FBRyxHQUFHLENBQUMsRUFBRTtnQkFDWCxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ1A7aUJBQU0sSUFBSSxHQUFHLEdBQUcsZUFBZSxFQUFFO2dCQUNoQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ1A7aUJBQU07Z0JBQ0wsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxlQUFlLENBQUMsR0FBRyxHQUFHLENBQUM7YUFDbkQ7WUFFRCxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDcEIsSUFBSSxHQUFHO29CQUNMLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ2IsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDYixDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUNiLENBQUMsR0FBQTtvQkFDRCxNQUFNLEVBQUUsS0FBSztpQkFDZCxDQUFDO2FBQ0g7U0FDRjthQUFNOztnQkFDRCxDQUFDLFNBQUE7WUFDTCxJQUFJLElBQUksR0FBRyxDQUFDLEVBQUU7Z0JBQ1osQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNQO2lCQUFNLElBQUksSUFBSSxHQUFHLGNBQWMsRUFBRTtnQkFDaEMsQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNQO2lCQUFNO2dCQUNMLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsY0FBYyxDQUFDLEdBQUcsR0FBRyxDQUFDO2FBQ25EO1lBRUQsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQ3BCLElBQUksR0FBRztvQkFDTCxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUNiLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ2IsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDYixDQUFDLEdBQUE7b0JBQ0QsTUFBTSxFQUFFLEtBQUs7aUJBQ2QsQ0FBQzthQUNIO1NBQ0Y7UUFDRCxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1QsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUNELElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxNQUFBLEVBQUUsTUFBTSxRQUFBLEVBQUUsQ0FBQyxDQUFDO0tBQ3RDOztnQkExSUYsU0FBUyxTQUFDO29CQUNULFFBQVEsRUFBRSxhQUFhO29CQUN2QixRQUFRLEVBQUUsd21CQVlUO29CQTRDRCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtvQkFDL0MsbUJBQW1CLEVBQUUsS0FBSzs2QkEzQ3hCLHd3QkF3Q0Q7aUJBSUY7OztzQkFFRSxLQUFLO3NCQUNMLEtBQUs7MEJBQ0wsS0FBSzt5QkFDTCxLQUFLO3lCQUNMLEtBQUs7NEJBQ0wsS0FBSzsyQkFDTCxNQUFNOztJQXVFVCxxQkFBQztDQTNJRCxJQTJJQzs7SUFFRDtLQUsyQjs7Z0JBTDFCLFFBQVEsU0FBQztvQkFDUixZQUFZLEVBQUUsQ0FBQyxjQUFjLENBQUM7b0JBQzlCLE9BQU8sRUFBRSxDQUFDLGNBQWMsQ0FBQztvQkFDekIsT0FBTyxFQUFFLENBQUMsWUFBWSxFQUFFLGdCQUFnQixFQUFFLGlCQUFpQixDQUFDO2lCQUM3RDs7SUFDeUIsa0JBQUM7Q0FMM0I7Ozs7OztBQzdKQTtJQUlNLFNBQVMsR0FBRyxVQUFVOzs7OztBQUU1QixTQUFnQix3QkFBd0IsQ0FBQyxJQUFJOztRQUNyQyxXQUFXLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDOztRQUN4RCxPQUFPLEdBQUcsQ0FBQzs7UUFDWCxNQUFNLEdBQUcsQ0FBQztJQUNkLFdBQVcsQ0FBQyxPQUFPLENBQUMsVUFBQSxNQUFNO1FBQ3hCLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDakIsT0FBTztTQUNSO1FBQ0QsT0FBTyxJQUFJLENBQUMsQ0FBQztRQUNiLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUU7WUFDeEIsTUFBTSxJQUFJLENBQUMsQ0FBQztTQUNiO1FBQ0QsSUFBSSxNQUFNLEtBQUssR0FBRyxJQUFJLE1BQU0sS0FBSyxHQUFHLEVBQUU7O2dCQUM5QixXQUFXLEdBQUcsUUFBUTtZQUM1QixJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUU7Z0JBQ2xDLE1BQU0sSUFBSSxDQUFDLENBQUM7YUFDYjtTQUNGO0tBQ0YsQ0FBQyxDQUFDO0lBQ0gsT0FBTyxPQUFPLEtBQUssTUFBTSxHQUFHLElBQUksR0FBRyxLQUFLLENBQUM7Q0FDMUM7Ozs7OztBQUVELFNBQWdCLE9BQU8sQ0FBQyxJQUFJLEVBQUUsTUFBZTs7UUFDckMsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDOztRQUN4RCxHQUFHLEdBQUcsS0FBSyxDQUFDLEtBQUssRUFBRTs7UUFDbkIsR0FBRyxHQUFHLEtBQUssQ0FBQyxLQUFLLEVBQUU7O1FBQ25CLEdBQUcsR0FBRyxLQUFLLENBQUMsS0FBSyxFQUFFOztRQUNuQixHQUFHLEdBQUcsS0FBSyxDQUFDLEtBQUssRUFBRTtJQUN6QixJQUFJLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ2YsR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLElBQUksQ0FBQyxDQUFDO1FBQ3BCLEdBQUcsQ0FBQyxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUMsQ0FBQztLQUNyQjs7UUFDSyxXQUFXLEdBQUcsR0FBRyxLQUFLLFFBQVEsSUFBSSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUM7SUFFbkQsT0FBTztRQUNMLEdBQUcsS0FBQTtRQUNILEdBQUcsRUFBRSxXQUFXLEdBQUcsYUFBYSxHQUFHLE1BQUksR0FBSztRQUM1QyxHQUFHLEtBQUE7UUFDSCxHQUFHLEtBQUE7UUFDSCxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUMsSUFBSSxNQUFNLElBQUksR0FBRyxDQUFDLENBQUM7UUFDakMsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO0tBQ3BCLENBQUM7Q0FDSDs7Ozs7QUFFRCxTQUFnQixVQUFVLENBQUMsR0FBVztJQUNwQyxPQUFPLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztDQUNqQzs7Ozs7QUFFRCxTQUFnQixtQkFBbUIsQ0FBQyxJQUFJO0lBQ3RDLElBQUksQ0FBQyxJQUFJLEVBQUU7UUFDVCxPQUFPLE1BQU0sQ0FBQztLQUNmOztRQUNLLEdBQUcsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDO0lBQ3pCLElBQUksR0FBRyxDQUFDLEdBQUcsS0FBSyxhQUFhLEVBQUU7UUFDN0IsT0FBTyxpQkFBaUIsQ0FBQztLQUMxQjs7UUFDSyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsSUFBSSxJQUFJO0lBQ3hFLE9BQU8sR0FBRyxJQUFJLEdBQUcsR0FBRyxNQUFNLEdBQUcsTUFBTSxDQUFDO0NBQ3JDOzs7Ozs7QUNoRUQ7SUF1QkE7UUFNVyxjQUFTLEdBQUcsRUFBRSxDQUFDO1FBQ2YsVUFBSyxHQUFTO1lBQ3JCLENBQUMsRUFBRSxHQUFHO1lBQ04sQ0FBQyxFQUFFLEdBQUc7WUFDTixDQUFDLEVBQUUsR0FBRztZQUNOLENBQUMsRUFBRSxDQUFDO1NBQ0wsQ0FBQztRQUNRLGFBQVEsR0FBRyxJQUFJLFlBQVksRUFBYyxDQUFDO1FBQzFDLHFCQUFnQixHQUFHLElBQUksWUFBWSxFQUFjLENBQUM7UUFDbEQsa0JBQWEsR0FBRyxJQUFJLFlBQVksRUFBYyxDQUFDO0tBc0QxRDs7OztJQTVDQyw0QkFBUTs7O0lBQVI7UUFBQSxpQkFRQztRQVBDLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQzdCLFlBQVksQ0FBQyxHQUFHLENBQUMsRUFDakIsb0JBQW9CLEVBQUUsQ0FDdkI7YUFDQSxTQUFTLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxLQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFBLENBQUMsQ0FBQztRQUNqRCxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEMsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO0tBQzlCOzs7O0lBQ0QsK0JBQVc7OztJQUFYO1FBQ0UsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztLQUNqRDs7OztJQUNELCtCQUFXOzs7SUFBWDtRQUNFLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUM7S0FDNUI7Ozs7O0lBQ0QsNEJBQVE7Ozs7SUFBUixVQUFTLElBQUk7UUFDWCxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDMUIsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNwQixJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7UUFDcEIsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUMxQixJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztLQUN6Qjs7Ozs7O0lBQ0QsZ0NBQVk7Ozs7O0lBQVosVUFBYSxJQUFJLEVBQUUsTUFBTTs7WUFDakIsWUFBWSxHQUFHLHdCQUF3QixDQUFDLElBQUksQ0FBQztRQUNuRCxJQUFJLFlBQVksRUFBRTs7Z0JBQ1YsS0FBSyxHQUFHLE9BQU8sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDO1lBQ2xELElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDckIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLE9BQUEsRUFBRSxNQUFNLFFBQUEsRUFBRSxDQUFDLENBQUM7WUFDdEMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7U0FDekI7S0FDRjs7Ozs7O0lBRUQsb0NBQWdCOzs7O0lBQWhCLGVBQXFCOzs7Ozs7SUFFckIscUNBQWlCOzs7OztJQUFqQixVQUFrQixJQUFJLEVBQUUsTUFBTTs7WUFDdEIsWUFBWSxHQUFHLHdCQUF3QixDQUFDLElBQUksQ0FBQztRQUNuRCxJQUFJLFlBQVksRUFBRTs7Z0JBQ1YsS0FBSyxHQUFHLE9BQU8sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDO1lBQ2xELElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDckIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLE9BQUEsRUFBRSxNQUFNLFFBQUEsRUFBRSxDQUFDLENBQUM7U0FDNUM7S0FDRjs7Z0JBcEVGLFNBQVMsU0FBQzs7b0JBRVQsUUFBUSxFQUFFLFlBQVk7b0JBQ3RCLFFBQVEsRUFBRSxFQUFFO2lCQUNiOzs7NEJBRUUsS0FBSzt3QkFDTCxLQUFLOzJCQU1MLE1BQU07bUNBQ04sTUFBTTtnQ0FDTixNQUFNOztJQXNEVCxnQkFBQztDQXJFRCxJQXFFQzs7SUFFRDtLQUsrQjs7Z0JBTDlCLFFBQVEsU0FBQztvQkFDUixZQUFZLEVBQUUsQ0FBQyxTQUFTLENBQUM7b0JBQ3pCLE9BQU8sRUFBRSxDQUFDLFNBQVMsQ0FBQztvQkFDcEIsT0FBTyxFQUFFLENBQUMsWUFBWSxDQUFDO2lCQUN4Qjs7SUFDNkIsc0JBQUM7Q0FML0I7Ozs7OztBQzlGQTtJQWVBO1FBb0NXLGdCQUFXLEdBQUcsRUFBRSxDQUFDO1FBQ2hCLGFBQVEsR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBTXhDLFVBQUssR0FBRyxLQUFLLENBQUM7S0F5SGY7Ozs7SUFySEMseUNBQVE7OztJQUFSO1FBQ0UsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUN0RSxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO1FBQ3pFLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUM7UUFDekUsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2xCLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxHQUFHLFdBQVcsQ0FBQztTQUN0QztLQUNGOzs7OztJQUNELDRDQUFXOzs7O0lBQVgsVUFBWSxNQUFNO1FBQ2hCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO0tBQ25COzs7OztJQUNELCtDQUFjOzs7O0lBQWQsVUFBZSxNQUFNO1FBQ25CLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztLQUNwQzs7Ozs7SUFDRCw4Q0FBYTs7OztJQUFiLFVBQWMsTUFBTTs7Ozs7O1lBSVosV0FBVyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQzs7WUFDekMsWUFBWSxHQUFHLFdBQVcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDOztZQUM1QyxNQUFNLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3BELElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUU7O2dCQUNaLE1BQU0sR0FBRyxJQUFJLENBQUMsV0FBVyxJQUFJLENBQUM7O1lBR3BDLElBQUksTUFBTSxDQUFDLE9BQU8sS0FBSyxFQUFFLEVBQUU7Z0JBQ3pCLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtvQkFDZCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQzt3QkFDakIsSUFBSSxZQUFJLEdBQUMsSUFBSSxDQUFDLEtBQUssSUFBRyxNQUFNLEdBQUcsTUFBTSxLQUFFO3dCQUN2QyxNQUFNLFFBQUE7cUJBQ1AsQ0FBQyxDQUFDO2lCQUNKO3FCQUFNO29CQUNMLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLE1BQU0sR0FBRyxNQUFNLEVBQUUsTUFBTSxRQUFBLEVBQUUsQ0FBQyxDQUFDO2lCQUN2RDtnQkFFRCxJQUFJLFlBQVksRUFBRTtvQkFDaEIsSUFBSSxDQUFDLFlBQVksR0FBTSxNQUFNLEdBQUcsTUFBTSxNQUFHLENBQUM7aUJBQzNDO3FCQUFNO29CQUNMLElBQUksQ0FBQyxZQUFZLEdBQUcsTUFBTSxHQUFHLE1BQU0sQ0FBQztpQkFDckM7YUFDRjs7WUFHRCxJQUFJLE1BQU0sQ0FBQyxPQUFPLEtBQUssRUFBRSxFQUFFO2dCQUN6QixJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7b0JBQ2QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUM7d0JBQ2pCLElBQUksWUFBSSxHQUFDLElBQUksQ0FBQyxLQUFLLElBQUcsTUFBTSxHQUFHLE1BQU0sS0FBRTt3QkFDdkMsTUFBTSxRQUFBO3FCQUNQLENBQUMsQ0FBQztpQkFDSjtxQkFBTTtvQkFDTCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksRUFBRSxNQUFNLEdBQUcsTUFBTSxFQUFFLE1BQU0sUUFBQSxFQUFFLENBQUMsQ0FBQztpQkFDdkQ7Z0JBRUQsSUFBSSxZQUFZLEVBQUU7b0JBQ2hCLElBQUksQ0FBQyxZQUFZLEdBQU0sTUFBTSxHQUFHLE1BQU0sTUFBRyxDQUFDO2lCQUMzQztxQkFBTTtvQkFDTCxJQUFJLENBQUMsWUFBWSxHQUFHLE1BQU0sR0FBRyxNQUFNLENBQUM7aUJBQ3JDO2FBQ0Y7U0FDRjtLQUNGOzs7OztJQUNELDRDQUFXOzs7O0lBQVgsVUFBWSxNQUFNOztRQUNoQixJQUFJLE1BQU0sQ0FBQyxPQUFPLEtBQUssRUFBRSxJQUFJLE1BQU0sQ0FBQyxPQUFPLEtBQUssRUFBRSxFQUFFO1lBQ2xELE9BQU87U0FDUjtRQUNELElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNkLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO2dCQUNqQixJQUFJLFlBQUksR0FBQyxJQUFJLENBQUMsS0FBSyxJQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxLQUFFO2dCQUMzQyxNQUFNLFFBQUE7YUFDUCxDQUFDLENBQUM7U0FDSjthQUFNO1lBQ0wsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsTUFBTSxRQUFBLEVBQUUsQ0FBQyxDQUFDO1NBQzNEO0tBQ0Y7Ozs7SUFDRCw0Q0FBVzs7O0lBQVg7UUFDRSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNmLElBQUksQ0FBQyxZQUFZLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNyRCxJQUFJLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDbkQ7YUFBTTtZQUNMLElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUNuRDtLQUNGOzs7O0lBQ0QsNENBQVc7OztJQUFYO1FBQ0UsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0tBQ3BCOzs7O0lBQ0QsMENBQVM7OztJQUFUO1FBQUEsaUJBT0M7UUFOQyxJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLENBQUMsU0FBUyxDQUFDLFVBQUMsRUFBUztZQUNwRSxPQUFBLEtBQUksQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDO1NBQUEsQ0FDcEIsQ0FBQztRQUNGLElBQUksQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQyxTQUFTLENBQUM7WUFDdEQsT0FBQSxLQUFJLENBQUMsV0FBVyxFQUFFO1NBQUEsQ0FDbkIsQ0FBQztLQUNIOzs7O0lBQ0QsNENBQVc7OztJQUFYO1FBQ0UsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2xCLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDOUI7UUFDRCxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDaEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUM1QjtLQUNGOzs7OztJQUNELGdEQUFlOzs7O0lBQWYsVUFBZ0IsTUFBYTtRQUMzQixJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDbEIsTUFBTSxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQ3hCLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDeEIsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1NBQ2xCO0tBQ0Y7Ozs7O0lBQ0QsMkNBQVU7Ozs7SUFBVixVQUFXLE1BQU07O1FBQ2YsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFOztnQkFDWixRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7WUFDMUQsSUFBSSxRQUFRLElBQUksQ0FBQyxJQUFJLFFBQVEsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO2dCQUM3QyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksWUFBSSxHQUFDLElBQUksQ0FBQyxLQUFLLElBQUcsUUFBUSxLQUFFLEVBQUUsTUFBTSxRQUFBLEVBQUUsQ0FBQyxDQUFDO2FBQ2xFO1NBQ0Y7S0FDRjs7Z0JBbktGLFNBQVMsU0FBQztvQkFDVCxRQUFRLEVBQUUsc0JBQXNCO29CQUNoQyxRQUFRLEVBQUUsZ2RBVVQ7b0JBV0QsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07NkJBVDdDLCtGQU9EO2lCQUdGOzs7d0JBRUUsS0FBSzt3QkFLTCxLQUFLO3dCQUNMLEtBQUs7OEJBQ0wsS0FBSzs0QkFDTCxLQUFLOzBCQUNMLEtBQUs7OEJBQ0wsS0FBSzsyQkFDTCxNQUFNOztJQStIVCw2QkFBQztDQXBLRCxJQW9LQzs7SUFFRDtLQUttQzs7Z0JBTGxDLFFBQVEsU0FBQztvQkFDUixZQUFZLEVBQUUsQ0FBQyxzQkFBc0IsQ0FBQztvQkFDdEMsT0FBTyxFQUFFLENBQUMsc0JBQXNCLENBQUM7b0JBQ2pDLE9BQU8sRUFBRSxDQUFDLFlBQVksQ0FBQztpQkFDeEI7O0lBQ2lDLDBCQUFDO0NBTG5DOzs7Ozs7QUNyTEE7SUFjQTtRQXVEVyxnQkFBVyxHQUFHLEtBQUssQ0FBQztRQUNwQixjQUFTLEdBQThCLFlBQVksQ0FBQztRQUNuRCxhQUFRLEdBQUcsSUFBSSxZQUFZLEVBQXVDLENBQUM7UUFDN0UsU0FBSSxHQUFHLEtBQUssQ0FBQztRQUNiLFFBQUcsR0FBRyxFQUFFLENBQUM7S0F5RFY7Ozs7SUF2REMsa0NBQVc7OztJQUFYO1FBQ0UsSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLFlBQVksRUFBRTtZQUNuQyxJQUFJLENBQUMsSUFBSSxHQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLE1BQUcsQ0FBQztTQUMxQzthQUFNO1lBQ0wsSUFBSSxDQUFDLEdBQUcsR0FBTSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLE1BQUcsQ0FBQztTQUNsRDtLQUNGOzs7OztJQUNELG1DQUFZOzs7O0lBQVosVUFBYSxFQUFzRDtZQUFwRCxZQUFHLEVBQUUsY0FBSSxFQUFFLG9DQUFlLEVBQUUsa0NBQWMsRUFBRSxrQkFBTTs7WUFDM0QsSUFBZ0I7UUFDcEIsSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLFVBQVUsRUFBRTs7Z0JBQzdCLENBQUMsU0FBQTtZQUNMLElBQUksR0FBRyxHQUFHLENBQUMsRUFBRTtnQkFDWCxDQUFDLEdBQUcsR0FBRyxDQUFDO2FBQ1Q7aUJBQU0sSUFBSSxHQUFHLEdBQUcsZUFBZSxFQUFFO2dCQUNoQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ1A7aUJBQU07O29CQUNDLE9BQU8sR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEdBQUcsZUFBZSxDQUFDLEdBQUcsR0FBRztnQkFDcEQsQ0FBQyxHQUFHLEdBQUcsR0FBRyxPQUFPLEdBQUcsR0FBRyxDQUFDO2FBQ3pCO1lBRUQsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQ3BCLElBQUksR0FBRztvQkFDTCxDQUFDLEdBQUE7b0JBQ0QsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDYixDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUNiLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ2IsTUFBTSxFQUFFLEtBQUs7aUJBQ2QsQ0FBQzthQUNIO1NBQ0Y7YUFBTTs7Z0JBQ0QsQ0FBQyxTQUFBO1lBQ0wsSUFBSSxJQUFJLEdBQUcsQ0FBQyxFQUFFO2dCQUNaLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDUDtpQkFBTSxJQUFJLElBQUksR0FBRyxjQUFjLEVBQUU7Z0JBQ2hDLENBQUMsR0FBRyxHQUFHLENBQUM7YUFDVDtpQkFBTTs7b0JBQ0MsT0FBTyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsY0FBYztnQkFDM0MsQ0FBQyxHQUFHLEdBQUcsR0FBRyxPQUFPLEdBQUcsR0FBRyxDQUFDO2FBQ3pCO1lBRUQsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQ3BCLElBQUksR0FBRztvQkFDTCxDQUFDLEdBQUE7b0JBQ0QsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDYixDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUNiLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ2IsTUFBTSxFQUFFLEtBQUs7aUJBQ2QsQ0FBQzthQUNIO1NBQ0Y7UUFDRCxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1QsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUNELElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxNQUFBLEVBQUUsTUFBTSxRQUFBLEVBQUUsQ0FBQyxDQUFDO0tBQ3RDOztnQkFuSEYsU0FBUyxTQUFDO29CQUNULFFBQVEsRUFBRSxXQUFXO29CQUNyQixRQUFRLEVBQUUsNmJBUVQ7b0JBcUNELG1CQUFtQixFQUFFLEtBQUs7b0JBQzFCLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNOzZCQXBDN0MsbzBCQWlDRDtpQkFJRjs7O3NCQUVFLEtBQUs7MEJBQ0wsS0FBSzt5QkFDTCxLQUFLO3lCQUNMLEtBQUs7OEJBQ0wsS0FBSzs0QkFDTCxLQUFLOzJCQUNMLE1BQU07O0lBMkRULG1CQUFDO0NBcEhELElBb0hDOztJQUVEO0tBS3lCOztnQkFMeEIsUUFBUSxTQUFDO29CQUNSLFlBQVksRUFBRSxDQUFDLFlBQVksQ0FBQztvQkFDNUIsT0FBTyxFQUFFLENBQUMsWUFBWSxDQUFDO29CQUN2QixPQUFPLEVBQUUsQ0FBQyxZQUFZLEVBQUUsaUJBQWlCLENBQUM7aUJBQzNDOztJQUN1QixnQkFBQztDQUx6Qjs7Ozs7O0FDcElBO0lBR0E7UUFnRFcsV0FBTSxHQUEyQixDQUFDLENBQUM7UUFDbkMsV0FBTSxHQUFHLENBQUMsQ0FBQztRQUNYLGVBQVUsR0FBRyxNQUFNLENBQUM7S0FDOUI7O2dCQW5EQSxTQUFTLFNBQUM7b0JBQ1QsUUFBUSxFQUFFLGNBQWM7b0JBQ3hCLFFBQVEsRUFBRSx5TkFPVDtvQkFtQ0QsbUJBQW1CLEVBQUUsS0FBSztvQkFDMUIsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07NkJBbkN0QyxvekJBaUNSO2lCQUdGOzs7eUJBRUUsS0FBSzt5QkFDTCxLQUFLOzZCQUNMLEtBQUs7O0lBQ1Isc0JBQUM7Q0FuREQsSUFtREM7O0lBRUQ7S0FLNkI7O2dCQUw1QixRQUFRLFNBQUM7b0JBQ1IsWUFBWSxFQUFFLENBQUMsZUFBZSxDQUFDO29CQUMvQixPQUFPLEVBQUUsQ0FBQyxlQUFlLENBQUM7b0JBQzFCLE9BQU8sRUFBRSxDQUFDLFlBQVksQ0FBQztpQkFDeEI7O0lBQzJCLG1CQUFDO0NBTDdCOzs7Ozs7QUN4REE7SUFlQTtRQTREWSxhQUFRLEdBQUcsSUFBSSxZQUFZLEVBQXVDLENBQUM7S0FtQzlFOzs7O0lBOUJDLHlDQUFXOzs7SUFBWDtRQUNFLElBQUksQ0FBQyxVQUFVLEdBQUcsU0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsaUJBQWMsQ0FBQztRQUNsRCxJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDdEQsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDO0tBQzNDOzs7OztJQUNELDBDQUFZOzs7O0lBQVosVUFBYSxFQUFzRDtZQUFwRCxZQUFHLEVBQUUsY0FBSSxFQUFFLG9DQUFlLEVBQUUsa0NBQWMsRUFBRSxrQkFBTTtRQUMvRCxJQUFJLElBQUksR0FBRyxDQUFDLEVBQUU7WUFDWixJQUFJLEdBQUcsQ0FBQyxDQUFDO1NBQ1Y7YUFBTSxJQUFJLElBQUksR0FBRyxjQUFjLEVBQUU7WUFDaEMsSUFBSSxHQUFHLGNBQWMsQ0FBQztTQUN2QjthQUFNLElBQUksR0FBRyxHQUFHLENBQUMsRUFBRTtZQUNsQixHQUFHLEdBQUcsQ0FBQyxDQUFDO1NBQ1Q7YUFBTSxJQUFJLEdBQUcsR0FBRyxlQUFlLEVBQUU7WUFDaEMsR0FBRyxHQUFHLGVBQWUsQ0FBQztTQUN2Qjs7WUFFSyxVQUFVLEdBQUcsSUFBSSxHQUFHLGNBQWM7O1lBQ3BDLE1BQU0sR0FBRyxFQUFFLEdBQUcsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDO1FBQ3pDLE1BQU0sR0FBRyxNQUFNLEdBQUcsQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUM7UUFDakMsTUFBTSxHQUFHLE1BQU0sR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLE1BQU0sQ0FBQzs7WUFFM0IsSUFBSSxHQUFlO1lBQ3ZCLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDYixDQUFDLEVBQUUsVUFBVTtZQUNiLENBQUMsRUFBRSxNQUFNO1lBQ1QsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNiLE1BQU0sRUFBRSxNQUFNO1NBQ2Y7UUFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksTUFBQSxFQUFFLE1BQU0sUUFBQSxFQUFFLENBQUMsQ0FBQztLQUN0Qzs7Z0JBOUZGLFNBQVMsU0FBQztvQkFDVCxRQUFRLEVBQUUsa0JBQWtCO29CQUM1QixRQUFRLEVBQUUscWNBU1Q7b0JBd0NELG1CQUFtQixFQUFFLEtBQUs7b0JBQzFCLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNOzZCQXZDN0MsZzJCQW9DRDtpQkFJRjs7O3NCQUVFLEtBQUs7c0JBQ0wsS0FBSzt5QkFDTCxLQUFLOzBCQUNMLEtBQUs7eUJBQ0wsS0FBSzsyQkFDTCxNQUFNOztJQW1DVCwwQkFBQztDQS9GRCxJQStGQzs7SUFFRDtLQUtnQzs7Z0JBTC9CLFFBQVEsU0FBQztvQkFDUixZQUFZLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQztvQkFDbkMsT0FBTyxFQUFFLENBQUMsbUJBQW1CLENBQUM7b0JBQzlCLE9BQU8sRUFBRSxDQUFDLFlBQVksRUFBRSxpQkFBaUIsQ0FBQztpQkFDM0M7O0lBQzhCLHVCQUFDO0NBTGhDOzs7Ozs7O0lDbkdBO1FBd0JXLFVBQUssR0FBOEIsRUFBRSxDQUFDO1FBQ3RDLGVBQVUsR0FBOEIsRUFBRSxDQUFDO1FBRTFDLFlBQU8sR0FBRyxJQUFJLFlBQVksRUFBaUMsQ0FBQztRQUM1RCxZQUFPLEdBQUcsSUFBSSxZQUFZLEVBQWlDLENBQUM7UUFDdEUsY0FBUyxHQUE0QixFQUFFLENBQUM7UUFDeEMsZ0JBQVcsR0FBNEIsRUFBRSxDQUFDO1FBQzFDLFlBQU8sR0FBRyxLQUFLLENBQUM7S0FnQ2pCOzs7O0lBOUJDLGtDQUFROzs7SUFBUjtRQUNFLElBQUksQ0FBQyxTQUFTLGNBQ1osVUFBVSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQ3RCLE1BQU0sRUFBRSxNQUFNLEVBQ2QsS0FBSyxFQUFFLE1BQU0sRUFDYixNQUFNLEVBQUUsU0FBUyxFQUNqQixRQUFRLEVBQUUsVUFBVSxFQUNwQixPQUFPLEVBQUUsTUFBTSxJQUNaLElBQUksQ0FBQyxLQUFLLENBQ2QsQ0FBQztRQUNGLElBQUksQ0FBQyxXQUFXLGdCQUNYLElBQUksQ0FBQyxTQUFTLEVBQ2QsSUFBSSxDQUFDLFVBQVUsQ0FDbkIsQ0FBQztLQUNIOzs7O0lBQ0Qsc0NBQVk7OztJQUFaO1FBQ0UsT0FBTyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO0tBQ3ZFOzs7O0lBQ0Qsd0NBQWM7OztJQUFkO1FBQ0UsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7S0FDdEI7Ozs7SUFDRCxxQ0FBVzs7O0lBQVg7UUFDRSxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztLQUNyQjs7Ozs7O0lBQ0QscUNBQVc7Ozs7O0lBQVgsVUFBWSxHQUFHLEVBQUUsTUFBTTtRQUNyQixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsS0FBQSxFQUFFLE1BQU0sUUFBQSxFQUFFLENBQUMsQ0FBQztLQUNwQzs7Ozs7O0lBQ0QscUNBQVc7Ozs7O0lBQVgsVUFBWSxHQUFHLEVBQUUsTUFBTTtRQUNyQixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsS0FBQSxFQUFFLE1BQU0sUUFBQSxFQUFFLENBQUMsQ0FBQztLQUNwQzs7Z0JBOURGLFNBQVMsU0FBQztvQkFDVCxRQUFRLEVBQUUsY0FBYztvQkFDeEIsUUFBUSxFQUFFLDZmQWdCVDtvQkFDRCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtvQkFDL0MsbUJBQW1CLEVBQUUsS0FBSztpQkFDM0I7Ozt3QkFFRSxLQUFLO3dCQUNMLEtBQUs7NkJBQ0wsS0FBSzt3QkFDTCxLQUFLOzBCQUNMLE1BQU07MEJBQ04sTUFBTTs7SUFtQ1Qsc0JBQUM7Q0EvREQsSUErREM7O0lBRUQ7S0FLNEI7O2dCQUwzQixRQUFRLFNBQUM7b0JBQ1IsWUFBWSxFQUFFLENBQUMsZUFBZSxDQUFDO29CQUMvQixPQUFPLEVBQUUsQ0FBQyxlQUFlLENBQUM7b0JBQzFCLE9BQU8sRUFBRSxDQUFDLFlBQVksRUFBRSxnQkFBZ0IsQ0FBQztpQkFDMUM7O0lBQzBCLG1CQUFDO0NBTDVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OyJ9