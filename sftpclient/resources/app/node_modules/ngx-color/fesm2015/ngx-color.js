import { CommonModule } from '@angular/common';
import { ChangeDetectionStrategy, Component, Input, NgModule, Directive, ElementRef, HostListener, Output, EventEmitter } from '@angular/core';
import { Subject, fromEvent } from 'rxjs';
import { distinctUntilChanged, debounceTime } from 'rxjs/operators';
import * as _tinycolor from 'tinycolor2';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const checkboardCache = {};
/**
 * @param {?} c1
 * @param {?} c2
 * @param {?} size
 * @return {?}
 */
function render(c1, c2, size) {
    if (typeof document === 'undefined') {
        return null;
    }
    /** @type {?} */
    const canvas = document.createElement('canvas');
    canvas.width = size * 2;
    canvas.height = size * 2;
    /** @type {?} */
    const ctx = canvas.getContext('2d');
    if (!ctx) {
        return null;
    } // If no context can be found, return early.
    ctx.fillStyle = c1;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = c2;
    ctx.fillRect(0, 0, size, size);
    ctx.translate(size, size);
    ctx.fillRect(0, 0, size, size);
    return canvas.toDataURL();
}
/**
 * @param {?} c1
 * @param {?} c2
 * @param {?} size
 * @return {?}
 */
function getCheckerboard(c1, c2, size) {
    /** @type {?} */
    const key = `${c1}-${c2}-${size}`;
    if (checkboardCache[key]) {
        return checkboardCache[key];
    }
    /** @type {?} */
    const checkboard = render(c1, c2, size);
    if (!checkboard) {
        return null;
    }
    checkboardCache[key] = checkboard;
    return checkboard;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class CheckboardComponent {
    constructor() {
        this.white = 'transparent';
        this.size = 8;
        this.grey = 'rgba(0,0,0,.08)';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const background = getCheckerboard(this.white, this.grey, this.size);
        this.gridStyles = {
            borderRadius: this.borderRadius,
            boxShadow: this.boxShadow,
            background: `url(${background}) center left`,
        };
    }
}
CheckboardComponent.decorators = [
    { type: Component, args: [{
                selector: 'color-checkboard',
                template: `<div class="grid" [ngStyle]="gridStyles"></div>`,
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
  .grid {
    top: 0px;
    right: 0px;
    bottom: 0px;
    left: 0px;
    position: absolute;
  }
  `]
            }] }
];
CheckboardComponent.propDecorators = {
    white: [{ type: Input }],
    size: [{ type: Input }],
    grey: [{ type: Input }],
    boxShadow: [{ type: Input }],
    borderRadius: [{ type: Input }]
};
class CheckboardModule {
}
CheckboardModule.decorators = [
    { type: NgModule, args: [{
                declarations: [CheckboardComponent],
                exports: [CheckboardComponent],
                imports: [CommonModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class CoordinatesDirective {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
        this.coordinatesChange = new Subject();
        this.mousechange = new Subject();
        this.mouseListening = false;
    }
    /**
     * @param {?} $event
     * @param {?} x
     * @param {?} y
     * @param {?=} isTouch
     * @return {?}
     */
    mousemove($event, x, y, isTouch = false) {
        if (this.mouseListening) {
            $event.preventDefault();
            this.mousechange.next({ $event, x, y, isTouch });
        }
    }
    /**
     * @return {?}
     */
    mouseup() {
        this.mouseListening = false;
    }
    /**
     * @param {?} $event
     * @param {?} x
     * @param {?} y
     * @param {?=} isTouch
     * @return {?}
     */
    mousedown($event, x, y, isTouch = false) {
        $event.preventDefault();
        this.mouseListening = true;
        this.mousechange.next({ $event, x, y, isTouch });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.sub = this.mousechange
            .pipe(
        // limit times it is updated for the same area
        distinctUntilChanged((p, q) => p.x === q.x && p.y === q.y))
            .subscribe(n => this.handleChange(n.x, n.y, n.$event, n.isTouch));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.sub.unsubscribe();
    }
    /**
     * @param {?} x
     * @param {?} y
     * @param {?} $event
     * @param {?} isTouch
     * @return {?}
     */
    handleChange(x, y, $event, isTouch) {
        /** @type {?} */
        const containerWidth = this.el.nativeElement.clientWidth;
        /** @type {?} */
        const containerHeight = this.el.nativeElement.clientHeight;
        /** @type {?} */
        const left = x -
            (this.el.nativeElement.getBoundingClientRect().left + window.pageXOffset);
        /** @type {?} */
        let top = y - this.el.nativeElement.getBoundingClientRect().top;
        if (!isTouch) {
            top = top - window.pageYOffset;
        }
        this.coordinatesChange.next({
            x,
            y,
            top,
            left,
            containerWidth,
            containerHeight,
            $event,
        });
    }
}
CoordinatesDirective.decorators = [
    { type: Directive, args: [{ selector: '[ngx-color-coordinates]' },] }
];
/** @nocollapse */
CoordinatesDirective.ctorParameters = () => [
    { type: ElementRef }
];
CoordinatesDirective.propDecorators = {
    coordinatesChange: [{ type: Output }],
    mousemove: [{ type: HostListener, args: ['window:mousemove', ['$event', '$event.pageX', '$event.pageY'],] }, { type: HostListener, args: ['window:touchmove', [
                    '$event',
                    '$event.touches[0].clientX',
                    '$event.touches[0].clientY',
                    'true',
                ],] }],
    mouseup: [{ type: HostListener, args: ['window:mouseup',] }, { type: HostListener, args: ['window:touchend',] }],
    mousedown: [{ type: HostListener, args: ['mousedown', ['$event', '$event.pageX', '$event.pageY'],] }, { type: HostListener, args: ['touchstart', [
                    '$event',
                    '$event.touches[0].clientX',
                    '$event.touches[0].clientY',
                    'true',
                ],] }]
};
class CoordinatesModule {
}
CoordinatesModule.decorators = [
    { type: NgModule, args: [{
                declarations: [CoordinatesDirective],
                exports: [CoordinatesDirective],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AlphaComponent {
    constructor() {
        this.direction = 'horizontal';
        this.onChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (this.direction === 'vertical') {
            this.pointerLeft = 0;
            this.pointerTop = this.rgb.a * 100;
            this.gradient = {
                background: `linear-gradient(to bottom, rgba(${this.rgb.r},${this.rgb.g},${this.rgb.b}, 0) 0%,
          rgba(${this.rgb.r},${this.rgb.g},${this.rgb.b}, 1) 100%)`,
            };
        }
        else {
            this.gradient = {
                background: `linear-gradient(to right, rgba(${this.rgb.r},${this.rgb.g},${this.rgb.b}, 0) 0%,
          rgba(${this.rgb.r},${this.rgb.g},${this.rgb.b}, 1) 100%)`,
            };
            this.pointerLeft = this.rgb.a * 100;
        }
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    handleChange({ top, left, containerHeight, containerWidth, $event }) {
        /** @type {?} */
        let data;
        if (this.direction === 'vertical') {
            /** @type {?} */
            let a;
            if (top < 0) {
                a = 0;
            }
            else if (top > containerHeight) {
                a = 1;
            }
            else {
                a = Math.round(top * 100 / containerHeight) / 100;
            }
            if (this.hsl.a !== a) {
                data = {
                    h: this.hsl.h,
                    s: this.hsl.s,
                    l: this.hsl.l,
                    a,
                    source: 'rgb',
                };
            }
        }
        else {
            /** @type {?} */
            let a;
            if (left < 0) {
                a = 0;
            }
            else if (left > containerWidth) {
                a = 1;
            }
            else {
                a = Math.round(left * 100 / containerWidth) / 100;
            }
            if (this.hsl.a !== a) {
                data = {
                    h: this.hsl.h,
                    s: this.hsl.s,
                    l: this.hsl.l,
                    a,
                    source: 'rgb',
                };
            }
        }
        if (!data) {
            return null;
        }
        this.onChange.emit({ data, $event });
    }
}
AlphaComponent.decorators = [
    { type: Component, args: [{
                selector: 'color-alpha',
                template: `
  <div class="alpha" [style.border-radius]="radius">
    <div class="alpha-checkboard">
      <color-checkboard></color-checkboard>
    </div>
    <div class="alpha-gradient" [ngStyle]="gradient" [style.box-shadow]="shadow" [style.border-radius]="radius"></div>
    <div ngx-color-coordinates (coordinatesChange)="handleChange($event)" class="alpha-container color-alpha-{{direction}}">
      <div class="alpha-pointer" [style.left.%]="pointerLeft" [style.top.%]="pointerTop">
        <div class="alpha-slider" [ngStyle]="pointer"></div>
      </div>
    </div>
  </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                styles: [`
    .alpha {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
    }
    .alpha-checkboard {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      overflow: hidden;
    }
    .alpha-gradient {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
    }
    .alpha-container {
      position: relative;
      height: 100%;
      margin: 0 3px;
    }
    .alpha-pointer {
      position: absolute;
    }
    .alpha-slider {
      width: 4px;
      border-radius: 1px;
      height: 8px;
      box-shadow: 0 0 2px rgba(0, 0, 0, .6);
      background: #fff;
      margin-top: 1px;
      transform: translateX(-2px);
    },
  `]
            }] }
];
AlphaComponent.propDecorators = {
    hsl: [{ type: Input }],
    rgb: [{ type: Input }],
    pointer: [{ type: Input }],
    shadow: [{ type: Input }],
    radius: [{ type: Input }],
    direction: [{ type: Input }],
    onChange: [{ type: Output }]
};
class AlphaModule {
}
AlphaModule.decorators = [
    { type: NgModule, args: [{
                declarations: [AlphaComponent],
                exports: [AlphaComponent],
                imports: [CommonModule, CheckboardModule, CoordinatesModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const tinycolor = _tinycolor;
/**
 * @param {?} data
 * @return {?}
 */
function simpleCheckForValidColor(data) {
    /** @type {?} */
    const keysToCheck = ['r', 'g', 'b', 'a', 'h', 's', 'l', 'v'];
    /** @type {?} */
    let checked = 0;
    /** @type {?} */
    let passed = 0;
    keysToCheck.forEach(letter => {
        if (!data[letter]) {
            return;
        }
        checked += 1;
        if (!isNaN(data[letter])) {
            passed += 1;
        }
        if (letter === 's' || letter === 'l') {
            /** @type {?} */
            const percentPatt = /^\d+%$/;
            if (percentPatt.test(data[letter])) {
                passed += 1;
            }
        }
    });
    return checked === passed ? data : false;
}
/**
 * @param {?} data
 * @param {?=} oldHue
 * @return {?}
 */
function toState(data, oldHue) {
    /** @type {?} */
    const color = data.hex ? tinycolor(data.hex) : tinycolor(data);
    /** @type {?} */
    const hsl = color.toHsl();
    /** @type {?} */
    const hsv = color.toHsv();
    /** @type {?} */
    const rgb = color.toRgb();
    /** @type {?} */
    const hex = color.toHex();
    if (hsl.s === 0) {
        hsl.h = oldHue || 0;
        hsv.h = oldHue || 0;
    }
    /** @type {?} */
    const transparent = hex === '000000' && rgb.a === 0;
    return {
        hsl,
        hex: transparent ? 'transparent' : `#${hex}`,
        rgb,
        hsv,
        oldHue: data.h || oldHue || hsl.h,
        source: data.source,
    };
}
/**
 * @param {?} hex
 * @return {?}
 */
function isValidHex(hex) {
    return tinycolor(hex).isValid();
}
/**
 * @param {?} data
 * @return {?}
 */
function getContrastingColor(data) {
    if (!data) {
        return '#fff';
    }
    /** @type {?} */
    const col = toState(data);
    if (col.hex === 'transparent') {
        return 'rgba(0,0,0,0.4)';
    }
    /** @type {?} */
    const yiq = (col.rgb.r * 299 + col.rgb.g * 587 + col.rgb.b * 114) / 1000;
    return yiq >= 128 ? '#000' : '#fff';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ColorWrap {
    constructor() {
        this.className = '';
        this.color = {
            h: 250,
            s: 0.5,
            l: 0.2,
            a: 1,
        };
        this.onChange = new EventEmitter();
        this.onChangeComplete = new EventEmitter();
        this.onSwatchHover = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.changes = this.onChange.pipe(debounceTime(100), distinctUntilChanged())
            .subscribe(x => this.onChangeComplete.emit(x));
        this.setState(toState(this.color, 0));
        this.currentColor = this.hex;
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.setState(toState(this.color, this.oldHue));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.changes.unsubscribe();
    }
    /**
     * @param {?} data
     * @return {?}
     */
    setState(data) {
        this.oldHue = data.oldHue;
        this.hsl = data.hsl;
        this.hsv = data.hsv;
        this.rgb = data.rgb;
        this.hex = data.hex;
        this.source = data.source;
        this.afterValidChange();
    }
    /**
     * @param {?} data
     * @param {?} $event
     * @return {?}
     */
    handleChange(data, $event) {
        /** @type {?} */
        const isValidColor = simpleCheckForValidColor(data);
        if (isValidColor) {
            /** @type {?} */
            const color = toState(data, data.h || this.oldHue);
            this.setState(color);
            this.onChange.emit({ color, $event });
            this.afterValidChange();
        }
    }
    /**
     * hook for components after a complete change
     * @return {?}
     */
    afterValidChange() { }
    /**
     * @param {?} data
     * @param {?} $event
     * @return {?}
     */
    handleSwatchHover(data, $event) {
        /** @type {?} */
        const isValidColor = simpleCheckForValidColor(data);
        if (isValidColor) {
            /** @type {?} */
            const color = toState(data, data.h || this.oldHue);
            this.setState(color);
            this.onSwatchHover.emit({ color, $event });
        }
    }
}
ColorWrap.decorators = [
    { type: Component, args: [{
                // create seletor base for test override property
                selector: 'color-wrap',
                template: ``
            }] }
];
ColorWrap.propDecorators = {
    className: [{ type: Input }],
    color: [{ type: Input }],
    onChange: [{ type: Output }],
    onChangeComplete: [{ type: Output }],
    onSwatchHover: [{ type: Output }]
};
class ColorWrapModule {
}
ColorWrapModule.decorators = [
    { type: NgModule, args: [{
                declarations: [ColorWrap],
                exports: [ColorWrap],
                imports: [CommonModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class EditableInputComponent {
    constructor() {
        this.placeholder = '';
        this.onChange = new EventEmitter();
        this.focus = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.wrapStyle = this.style && this.style.wrap ? this.style.wrap : {};
        this.inputStyle = this.style && this.style.input ? this.style.input : {};
        this.labelStyle = this.style && this.style.label ? this.style.label : {};
        if (this.dragLabel) {
            this.labelStyle.cursor = 'ew-resize';
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    handleFocus($event) {
        this.focus = true;
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    handleFocusOut($event) {
        this.focus = false;
        this.currentValue = this.blurValue;
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    handleKeydown($event) {
        // In case `e.target.value` is a percentage remove the `%` character
        // and update accordingly with a percentage
        // https://github.com/casesandberg/react-color/issues/383
        /** @type {?} */
        const stringValue = String($event.target.value);
        /** @type {?} */
        const isPercentage = stringValue.indexOf('%') > -1;
        /** @type {?} */
        const number = Number(stringValue.replace(/%/g, ''));
        if (!isNaN(number)) {
            /** @type {?} */
            const amount = this.arrowOffset || 1;
            // Up
            if ($event.keyCode === 38) {
                if (this.label) {
                    this.onChange.emit({
                        data: { [this.label]: number + amount },
                        $event,
                    });
                }
                else {
                    this.onChange.emit({ data: number + amount, $event });
                }
                if (isPercentage) {
                    this.currentValue = `${number + amount}%`;
                }
                else {
                    this.currentValue = number + amount;
                }
            }
            // Down
            if ($event.keyCode === 40) {
                if (this.label) {
                    this.onChange.emit({
                        data: { [this.label]: number - amount },
                        $event,
                    });
                }
                else {
                    this.onChange.emit({ data: number - amount, $event });
                }
                if (isPercentage) {
                    this.currentValue = `${number - amount}%`;
                }
                else {
                    this.currentValue = number - amount;
                }
            }
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    handleKeyup($event) {
        if ($event.keyCode === 40 || $event.keyCode === 38) {
            return;
        }
        if (this.label) {
            this.onChange.emit({
                data: { [this.label]: $event.target.value },
                $event,
            });
        }
        else {
            this.onChange.emit({ data: $event.target.value, $event });
        }
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (!this.focus) {
            this.currentValue = String(this.value).toUpperCase();
            this.blurValue = String(this.value).toUpperCase();
        }
        else {
            this.blurValue = String(this.value).toUpperCase();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unsubscribe();
    }
    /**
     * @return {?}
     */
    subscribe() {
        this.mousemove = fromEvent(document, 'mousemove').subscribe((ev) => this.handleDrag(ev));
        this.mouseup = fromEvent(document, 'mouseup').subscribe(() => this.unsubscribe());
    }
    /**
     * @return {?}
     */
    unsubscribe() {
        if (this.mousemove) {
            this.mousemove.unsubscribe();
        }
        if (this.mouseup) {
            this.mouseup.unsubscribe();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    handleMousedown($event) {
        if (this.dragLabel) {
            $event.preventDefault();
            this.handleDrag($event);
            this.subscribe();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    handleDrag($event) {
        if (this.dragLabel) {
            /** @type {?} */
            const newValue = Math.round(this.value + $event.movementX);
            if (newValue >= 0 && newValue <= this.dragMax) {
                this.onChange.emit({ data: { [this.label]: newValue }, $event });
            }
        }
    }
}
EditableInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'color-editable-input',
                template: `
  <div class="wrap" [ngStyle]="wrapStyle">
    <input [ngStyle]="inputStyle" spellCheck="false"
      [value]="currentValue" [placeholder]="placeholder"
      (keydown)="handleKeydown($event)" (keyup)="handleKeyup($event)"
      (focus)="handleFocus($event)" (focusout)="handleFocusOut($event)" />
    <span *ngIf="label" [ngStyle]="labelStyle" (mousedown)="handleMousedown($event)">
      {{ label }}
    </span>
  </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
    :host {
      display: flex;
    }
    .wrap {
      position: relative;
    }
  `]
            }] }
];
EditableInputComponent.propDecorators = {
    style: [{ type: Input }],
    label: [{ type: Input }],
    value: [{ type: Input }],
    arrowOffset: [{ type: Input }],
    dragLabel: [{ type: Input }],
    dragMax: [{ type: Input }],
    placeholder: [{ type: Input }],
    onChange: [{ type: Output }]
};
class EditableInputModule {
}
EditableInputModule.decorators = [
    { type: NgModule, args: [{
                declarations: [EditableInputComponent],
                exports: [EditableInputComponent],
                imports: [CommonModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class HueComponent {
    constructor() {
        this.hidePointer = false;
        this.direction = 'horizontal';
        this.onChange = new EventEmitter();
        this.left = '0px';
        this.top = '';
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (this.direction === 'horizontal') {
            this.left = `${this.hsl.h * 100 / 360}%`;
        }
        else {
            this.top = `${-(this.hsl.h * 100 / 360) + 100}%`;
        }
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    handleChange({ top, left, containerHeight, containerWidth, $event }) {
        /** @type {?} */
        let data;
        if (this.direction === 'vertical') {
            /** @type {?} */
            let h;
            if (top < 0) {
                h = 359;
            }
            else if (top > containerHeight) {
                h = 0;
            }
            else {
                /** @type {?} */
                const percent = -(top * 100 / containerHeight) + 100;
                h = 360 * percent / 100;
            }
            if (this.hsl.h !== h) {
                data = {
                    h,
                    s: this.hsl.s,
                    l: this.hsl.l,
                    a: this.hsl.a,
                    source: 'rgb',
                };
            }
        }
        else {
            /** @type {?} */
            let h;
            if (left < 0) {
                h = 0;
            }
            else if (left > containerWidth) {
                h = 359;
            }
            else {
                /** @type {?} */
                const percent = left * 100 / containerWidth;
                h = 360 * percent / 100;
            }
            if (this.hsl.h !== h) {
                data = {
                    h,
                    s: this.hsl.s,
                    l: this.hsl.l,
                    a: this.hsl.a,
                    source: 'rgb',
                };
            }
        }
        if (!data) {
            return null;
        }
        this.onChange.emit({ data, $event });
    }
}
HueComponent.decorators = [
    { type: Component, args: [{
                selector: 'color-hue',
                template: `
  <div class="color-hue color-hue-{{direction}}" [style.border-radius.px]="radius" [style.box-shadow]="shadow">
    <div ngx-color-coordinates (coordinatesChange)="handleChange($event)" class="color-hue-container">
      <div class="color-hue-pointer" [style.left]="left" [style.top]="top" *ngIf="!hidePointer">
        <div class="color-hue-slider" [ngStyle]="pointer"></div>
      </div>
    </div>
  </div>
  `,
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
    .color-hue {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
    }
    .color-hue-container {
      margin: 0 2px;
      position: relative;
      height: 100%;
    }
    .color-hue-pointer {
      position: absolute;
    }
    .color-hue-slider {
      margin-top: 1px;
      width: 4px;
      border-radius: 1px;
      height: 8px;
      box-shadow: 0 0 2px rgba(0, 0, 0, .6);
      background: #fff;
      transform: translateX(-2px);
    }
    .color-hue-horizontal {
      background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0
        33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);
    }
    .color-hue-vertical {
      background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%,
        #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);
    }
  `]
            }] }
];
HueComponent.propDecorators = {
    hsl: [{ type: Input }],
    pointer: [{ type: Input }],
    radius: [{ type: Input }],
    shadow: [{ type: Input }],
    hidePointer: [{ type: Input }],
    direction: [{ type: Input }],
    onChange: [{ type: Output }]
};
class HueModule {
}
HueModule.decorators = [
    { type: NgModule, args: [{
                declarations: [HueComponent],
                exports: [HueComponent],
                imports: [CommonModule, CoordinatesModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class RaisedComponent {
    constructor() {
        this.zDepth = 1;
        this.radius = 1;
        this.background = '#fff';
    }
}
RaisedComponent.decorators = [
    { type: Component, args: [{
                selector: 'color-raised',
                template: `
  <div class="raised-wrap">
    <div class="raised-bg zDepth-{{zDepth}}" [style.background]="background"></div>
    <div class="raised-content">
      <ng-content></ng-content>
    </div>
  </div>
  `,
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
    .raised-wrap {
      position: relative;
      display: inline-block;
    }
    .raised-bg {
      position: absolute;
      top: 0px;
      right: 0px;
      bottom: 0px;
      left: 0px;
    }
    .raised-content {
      position: relative;
    }
    .zDepth-0 {
      box-shadow: none;
    }
    .zDepth-1 {
      box-shadow: 0 2px 10px rgba(0,0,0,.12), 0 2px 5px rgba(0,0,0,.16);
    }
    .zDepth-2 {
      box-shadow: 0 6px 20px rgba(0,0,0,.19), 0 8px 17px rgba(0,0,0,.2);
    }
    .zDepth-3 {
      box-shadow: 0 17px 50px rgba(0,0,0,.19), 0 12px 15px rgba(0,0,0,.24);
    }
    .zDepth-4 {
      box-shadow: 0 25px 55px rgba(0,0,0,.21), 0 16px 28px rgba(0,0,0,.22);
    }
    .zDepth-5 {
      box-shadow: 0 40px 77px rgba(0,0,0,.22), 0 27px 24px rgba(0,0,0,.2);
    }
  `]
            }] }
];
RaisedComponent.propDecorators = {
    zDepth: [{ type: Input }],
    radius: [{ type: Input }],
    background: [{ type: Input }]
};
class RaisedModule {
}
RaisedModule.decorators = [
    { type: NgModule, args: [{
                declarations: [RaisedComponent],
                exports: [RaisedComponent],
                imports: [CommonModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SaturationComponent {
    constructor() {
        this.onChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.background = `hsl(${this.hsl.h}, 100%, 50%)`;
        this.pointerTop = -(this.hsv.v * 100) + 1 + 100 + '%';
        this.pointerLeft = this.hsv.s * 100 + '%';
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    handleChange({ top, left, containerHeight, containerWidth, $event }) {
        if (left < 0) {
            left = 0;
        }
        else if (left > containerWidth) {
            left = containerWidth;
        }
        else if (top < 0) {
            top = 0;
        }
        else if (top > containerHeight) {
            top = containerHeight;
        }
        /** @type {?} */
        const saturation = left / containerWidth;
        /** @type {?} */
        let bright = -(top / containerHeight) + 1;
        bright = bright > 0 ? bright : 0;
        bright = bright > 1 ? 1 : bright;
        /** @type {?} */
        const data = {
            h: this.hsl.h,
            s: saturation,
            v: bright,
            a: this.hsl.a,
            source: 'hsva',
        };
        this.onChange.emit({ data, $event });
    }
}
SaturationComponent.decorators = [
    { type: Component, args: [{
                selector: 'color-saturation',
                template: `
  <div class="color-saturation" ngx-color-coordinates (coordinatesChange)="handleChange($event)" [style.background]="background">
    <div class="saturation-white">
      <div class="saturation-black"></div>
      <div class="saturation-pointer" [ngStyle]="pointer" [style.top]="pointerTop" [style.left]="pointerLeft">
        <div class="saturation-circle" [ngStyle]="circle"></div>
      </div>
    </div>
  </div>
  `,
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
    .saturation-white {
      background: linear-gradient(to right, #fff, rgba(255,255,255,0));
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
    }
    .saturation-black {
      background: linear-gradient(to top, #000, rgba(0,0,0,0));
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
    }
    .color-saturation {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
    }
    .saturation-pointer {
      position: absolute;
      cursor: default;
    }
    .saturation-circle {
      width: 4px;
      height: 4px;
      box-shadow: 0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3), 0 0 1px 2px rgba(0,0,0,.4);
      border-radius: 50%;
      cursor: hand;
      transform: translate(-2px, -4px);
    }
  `]
            }] }
];
SaturationComponent.propDecorators = {
    hsl: [{ type: Input }],
    hsv: [{ type: Input }],
    radius: [{ type: Input }],
    pointer: [{ type: Input }],
    circle: [{ type: Input }],
    onChange: [{ type: Output }]
};
class SaturationModule {
}
SaturationModule.decorators = [
    { type: NgModule, args: [{
                declarations: [SaturationComponent],
                exports: [SaturationComponent],
                imports: [CommonModule, CoordinatesModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class SwatchComponent {
    constructor() {
        this.style = {};
        this.focusStyle = {};
        this.onClick = new EventEmitter();
        this.onHover = new EventEmitter();
        this.divStyles = {};
        this.focusStyles = {};
        this.inFocus = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.divStyles = Object.assign({ background: this.color, height: '100%', width: '100%', cursor: 'pointer', position: 'relative', outline: 'none' }, this.style);
        this.focusStyles = Object.assign({}, this.divStyles, this.focusStyle);
    }
    /**
     * @return {?}
     */
    activeStyles() {
        return this.focus || this.inFocus ? this.focusStyles : this.divStyles;
    }
    /**
     * @return {?}
     */
    handleFocusOut() {
        this.inFocus = false;
    }
    /**
     * @return {?}
     */
    handleFocus() {
        this.inFocus = true;
    }
    /**
     * @param {?} hex
     * @param {?} $event
     * @return {?}
     */
    handleHover(hex, $event) {
        this.onHover.emit({ hex, $event });
    }
    /**
     * @param {?} hex
     * @param {?} $event
     * @return {?}
     */
    handleClick(hex, $event) {
        this.onClick.emit({ hex, $event });
    }
}
SwatchComponent.decorators = [
    { type: Component, args: [{
                selector: 'color-swatch',
                template: `
  <div class="swatch"
    [ngStyle]="activeStyles()" [attr.title]="color"
    (click)="handleClick(color, $event)"
    (keydown.enter)="handleClick(color, $event)"
    (focus)="handleFocus()"
    (focusout)="handleFocusOut()"
    (mouseover)="handleHover(color, $event)"
    tabindex="0"
  >
    <ng-content></ng-content>
    <color-checkboard
      *ngIf="color === 'transparent'"
      boxShadow="inset 0 0 0 1px rgba(0,0,0,0.1)"
    ></color-checkboard>
  </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false
            }] }
];
SwatchComponent.propDecorators = {
    color: [{ type: Input }],
    style: [{ type: Input }],
    focusStyle: [{ type: Input }],
    focus: [{ type: Input }],
    onClick: [{ type: Output }],
    onHover: [{ type: Output }]
};
class SwatchModule {
}
SwatchModule.decorators = [
    { type: NgModule, args: [{
                declarations: [SwatchComponent],
                exports: [SwatchComponent],
                imports: [CommonModule, CheckboardModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { AlphaComponent, AlphaModule, CheckboardComponent, CheckboardModule, ColorWrap, ColorWrapModule, EditableInputComponent, EditableInputModule, HueComponent, HueModule, RaisedComponent, RaisedModule, SaturationComponent, SaturationModule, SwatchComponent, SwatchModule, CoordinatesDirective, CoordinatesModule, render, getCheckerboard, simpleCheckForValidColor, toState, isValidHex, getContrastingColor };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWNvbG9yLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9uZ3gtY29sb3IvaGVscGVycy9jaGVja2JvYXJkLnRzIiwibmc6Ly9uZ3gtY29sb3IvY2hlY2tib2FyZC5jb21wb25lbnQudHMiLCJuZzovL25neC1jb2xvci9jb29yZGluYXRlcy5kaXJlY3RpdmUudHMiLCJuZzovL25neC1jb2xvci9hbHBoYS5jb21wb25lbnQudHMiLCJuZzovL25neC1jb2xvci9oZWxwZXJzL2NvbG9yLnRzIiwibmc6Ly9uZ3gtY29sb3IvY29sb3Itd3JhcC5jb21wb25lbnQudHMiLCJuZzovL25neC1jb2xvci9lZGl0YWJsZS1pbnB1dC5jb21wb25lbnQudHMiLCJuZzovL25neC1jb2xvci9odWUuY29tcG9uZW50LnRzIiwibmc6Ly9uZ3gtY29sb3IvcmFpc2VkLmNvbXBvbmVudC50cyIsIm5nOi8vbmd4LWNvbG9yL3NhdHVyYXRpb24uY29tcG9uZW50LnRzIiwibmc6Ly9uZ3gtY29sb3Ivc3dhdGNoLmNvbXBvbmVudC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjaGVja2JvYXJkQ2FjaGU6IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9ID0ge307XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIoYzE6IHN0cmluZywgYzI6IHN0cmluZywgc2l6ZTogbnVtYmVyKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIGNhbnZhcy53aWR0aCA9IHNpemUgKiAyO1xuICBjYW52YXMuaGVpZ2h0ID0gc2l6ZSAqIDI7XG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBpZiAoIWN0eCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIElmIG5vIGNvbnRleHQgY2FuIGJlIGZvdW5kLCByZXR1cm4gZWFybHkuXG4gIGN0eC5maWxsU3R5bGUgPSBjMTtcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGN0eC5maWxsU3R5bGUgPSBjMjtcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIHNpemUsIHNpemUpO1xuICBjdHgudHJhbnNsYXRlKHNpemUsIHNpemUpO1xuICBjdHguZmlsbFJlY3QoMCwgMCwgc2l6ZSwgc2l6ZSk7XG4gIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGVja2VyYm9hcmQoYzE6IHN0cmluZywgYzI6IHN0cmluZywgc2l6ZTogbnVtYmVyKSB7XG4gIGNvbnN0IGtleSA9IGAke2MxfS0ke2MyfS0ke3NpemV9YDtcbiAgaWYgKGNoZWNrYm9hcmRDYWNoZVtrZXldKSB7XG4gICAgcmV0dXJuIGNoZWNrYm9hcmRDYWNoZVtrZXldO1xuICB9XG4gIGNvbnN0IGNoZWNrYm9hcmQgPSByZW5kZXIoYzEsIGMyLCBzaXplKTtcbiAgaWYgKCFjaGVja2JvYXJkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY2hlY2tib2FyZENhY2hlW2tleV0gPSBjaGVja2JvYXJkO1xuICByZXR1cm4gY2hlY2tib2FyZDtcbn1cbiIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBJbnB1dCxcbiAgTmdNb2R1bGUsXG4gIE9uSW5pdCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IGdldENoZWNrZXJib2FyZCB9IGZyb20gJy4vaGVscGVycy9jaGVja2JvYXJkJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY29sb3ItY2hlY2tib2FyZCcsXG4gIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cImdyaWRcIiBbbmdTdHlsZV09XCJncmlkU3R5bGVzXCI+PC9kaXY+YCxcbiAgc3R5bGVzOiBbXG4gICAgYFxuICAuZ3JpZCB7XG4gICAgdG9wOiAwcHg7XG4gICAgcmlnaHQ6IDBweDtcbiAgICBib3R0b206IDBweDtcbiAgICBsZWZ0OiAwcHg7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICB9XG4gIGAsXG4gIF0sXG4gIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgQ2hlY2tib2FyZENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIEBJbnB1dCgpIHdoaXRlID0gJ3RyYW5zcGFyZW50JztcbiAgQElucHV0KCkgc2l6ZSA9IDg7XG4gIEBJbnB1dCgpIGdyZXkgPSAncmdiYSgwLDAsMCwuMDgpJztcbiAgQElucHV0KCkgYm94U2hhZG93OiBzdHJpbmc7XG4gIEBJbnB1dCgpIGJvcmRlclJhZGl1czogc3RyaW5nO1xuICBncmlkU3R5bGVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG4gIG5nT25Jbml0KCkge1xuICAgIGNvbnN0IGJhY2tncm91bmQgPSBnZXRDaGVja2VyYm9hcmQodGhpcy53aGl0ZSwgdGhpcy5ncmV5LCB0aGlzLnNpemUpO1xuICAgIHRoaXMuZ3JpZFN0eWxlcyA9IHtcbiAgICAgIGJvcmRlclJhZGl1czogdGhpcy5ib3JkZXJSYWRpdXMsXG4gICAgICBib3hTaGFkb3c6IHRoaXMuYm94U2hhZG93LFxuICAgICAgYmFja2dyb3VuZDogYHVybCgke2JhY2tncm91bmR9KSBjZW50ZXIgbGVmdGAsXG4gICAgfTtcbiAgfVxufVxuXG5ATmdNb2R1bGUoe1xuICBkZWNsYXJhdGlvbnM6IFtDaGVja2JvYXJkQ29tcG9uZW50XSxcbiAgZXhwb3J0czogW0NoZWNrYm9hcmRDb21wb25lbnRdLFxuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2hlY2tib2FyZE1vZHVsZSB7fVxuIiwiaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBIb3N0TGlzdGVuZXIsXG4gIE5nTW9kdWxlLFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgU3ViamVjdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW25neC1jb2xvci1jb29yZGluYXRlc10nIH0pXG5leHBvcnQgY2xhc3MgQ29vcmRpbmF0ZXNEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gIEBPdXRwdXQoKVxuICBjb29yZGluYXRlc0NoYW5nZSA9IG5ldyBTdWJqZWN0PHtcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xuICAgIHRvcDogbnVtYmVyO1xuICAgIGxlZnQ6IG51bWJlcjtcbiAgICBjb250YWluZXJXaWR0aDogbnVtYmVyO1xuICAgIGNvbnRhaW5lckhlaWdodDogbnVtYmVyO1xuICAgICRldmVudDogYW55O1xuICB9PigpO1xuICBwcml2YXRlIG1vdXNlY2hhbmdlID0gbmV3IFN1YmplY3Q8e1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG4gICAgJGV2ZW50OiBhbnk7XG4gICAgaXNUb3VjaDogYm9vbGVhbjtcbiAgfT4oKTtcblxuICBwcml2YXRlIG1vdXNlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgc3ViOiBTdWJzY3JpcHRpb247XG4gIEBIb3N0TGlzdGVuZXIoJ3dpbmRvdzptb3VzZW1vdmUnLCBbJyRldmVudCcsICckZXZlbnQucGFnZVgnLCAnJGV2ZW50LnBhZ2VZJ10pXG4gIEBIb3N0TGlzdGVuZXIoJ3dpbmRvdzp0b3VjaG1vdmUnLCBbXG4gICAgJyRldmVudCcsXG4gICAgJyRldmVudC50b3VjaGVzWzBdLmNsaWVudFgnLFxuICAgICckZXZlbnQudG91Y2hlc1swXS5jbGllbnRZJyxcbiAgICAndHJ1ZScsXG4gIF0pXG4gIG1vdXNlbW92ZSgkZXZlbnQ6IEV2ZW50LCB4OiBudW1iZXIsIHk6IG51bWJlciwgaXNUb3VjaCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMubW91c2VMaXN0ZW5pbmcpIHtcbiAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5tb3VzZWNoYW5nZS5uZXh0KHsgJGV2ZW50LCB4LCB5LCBpc1RvdWNoIH0pO1xuICAgIH1cbiAgfVxuICBASG9zdExpc3RlbmVyKCd3aW5kb3c6bW91c2V1cCcpXG4gIEBIb3N0TGlzdGVuZXIoJ3dpbmRvdzp0b3VjaGVuZCcpXG4gIG1vdXNldXAoKSB7XG4gICAgdGhpcy5tb3VzZUxpc3RlbmluZyA9IGZhbHNlO1xuICB9XG4gIEBIb3N0TGlzdGVuZXIoJ21vdXNlZG93bicsIFsnJGV2ZW50JywgJyRldmVudC5wYWdlWCcsICckZXZlbnQucGFnZVknXSlcbiAgQEhvc3RMaXN0ZW5lcigndG91Y2hzdGFydCcsIFtcbiAgICAnJGV2ZW50JyxcbiAgICAnJGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCcsXG4gICAgJyRldmVudC50b3VjaGVzWzBdLmNsaWVudFknLFxuICAgICd0cnVlJyxcbiAgXSlcbiAgbW91c2Vkb3duKCRldmVudDogRXZlbnQsIHg6IG51bWJlciwgeTogbnVtYmVyLCBpc1RvdWNoID0gZmFsc2UpIHtcbiAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLm1vdXNlTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICB0aGlzLm1vdXNlY2hhbmdlLm5leHQoeyAkZXZlbnQsIHgsIHksIGlzVG91Y2ggfSk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsOiBFbGVtZW50UmVmKSB7fVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuc3ViID0gdGhpcy5tb3VzZWNoYW5nZVxuICAgICAgLnBpcGUoXG4gICAgICAgIC8vIGxpbWl0IHRpbWVzIGl0IGlzIHVwZGF0ZWQgZm9yIHRoZSBzYW1lIGFyZWFcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKHAsIHEpID0+IHAueCA9PT0gcS54ICYmIHAueSA9PT0gcS55KSxcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUobiA9PiB0aGlzLmhhbmRsZUNoYW5nZShuLngsIG4ueSwgbi4kZXZlbnQsIG4uaXNUb3VjaCkpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWIudW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIGhhbmRsZUNoYW5nZSh4OiBudW1iZXIsIHk6IG51bWJlciwgJGV2ZW50OiBFdmVudCwgaXNUb3VjaDogYm9vbGVhbikge1xuICAgIGNvbnN0IGNvbnRhaW5lcldpZHRoID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIGNvbnN0IGNvbnRhaW5lckhlaWdodCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgY29uc3QgbGVmdCA9XG4gICAgICB4IC1cbiAgICAgICh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCk7XG4gICAgbGV0IHRvcCA9IHkgLSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuXG4gICAgaWYgKCFpc1RvdWNoKSB7XG4gICAgICB0b3AgPSB0b3AgLSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgfVxuICAgIHRoaXMuY29vcmRpbmF0ZXNDaGFuZ2UubmV4dCh7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICBjb250YWluZXJXaWR0aCxcbiAgICAgIGNvbnRhaW5lckhlaWdodCxcbiAgICAgICRldmVudCxcbiAgICB9KTtcbiAgfVxufVxuXG5ATmdNb2R1bGUoe1xuICBkZWNsYXJhdGlvbnM6IFtDb29yZGluYXRlc0RpcmVjdGl2ZV0sXG4gIGV4cG9ydHM6IFtDb29yZGluYXRlc0RpcmVjdGl2ZV0sXG59KVxuZXhwb3J0IGNsYXNzIENvb3JkaW5hdGVzTW9kdWxlIHt9XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgTmdNb2R1bGUsXG4gIE9uQ2hhbmdlcyxcbiAgT3V0cHV0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2hlY2tib2FyZE1vZHVsZSB9IGZyb20gJy4vY2hlY2tib2FyZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29vcmRpbmF0ZXNNb2R1bGUgfSBmcm9tICcuL2Nvb3JkaW5hdGVzLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBIU0xBLCBSR0JBIH0gZnJvbSAnLi9oZWxwZXJzL2NvbG9yLmludGVyZmFjZXMnO1xuXG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2NvbG9yLWFscGhhJyxcbiAgdGVtcGxhdGU6IGBcbiAgPGRpdiBjbGFzcz1cImFscGhhXCIgW3N0eWxlLmJvcmRlci1yYWRpdXNdPVwicmFkaXVzXCI+XG4gICAgPGRpdiBjbGFzcz1cImFscGhhLWNoZWNrYm9hcmRcIj5cbiAgICAgIDxjb2xvci1jaGVja2JvYXJkPjwvY29sb3ItY2hlY2tib2FyZD5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiYWxwaGEtZ3JhZGllbnRcIiBbbmdTdHlsZV09XCJncmFkaWVudFwiIFtzdHlsZS5ib3gtc2hhZG93XT1cInNoYWRvd1wiIFtzdHlsZS5ib3JkZXItcmFkaXVzXT1cInJhZGl1c1wiPjwvZGl2PlxuICAgIDxkaXYgbmd4LWNvbG9yLWNvb3JkaW5hdGVzIChjb29yZGluYXRlc0NoYW5nZSk9XCJoYW5kbGVDaGFuZ2UoJGV2ZW50KVwiIGNsYXNzPVwiYWxwaGEtY29udGFpbmVyIGNvbG9yLWFscGhhLXt7ZGlyZWN0aW9ufX1cIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJhbHBoYS1wb2ludGVyXCIgW3N0eWxlLmxlZnQuJV09XCJwb2ludGVyTGVmdFwiIFtzdHlsZS50b3AuJV09XCJwb2ludGVyVG9wXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJhbHBoYS1zbGlkZXJcIiBbbmdTdHlsZV09XCJwb2ludGVyXCI+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4gIGAsXG4gIHN0eWxlczogW1xuICAgIGBcbiAgICAuYWxwaGEge1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgdG9wOiAwO1xuICAgICAgYm90dG9tOiAwO1xuICAgICAgbGVmdDogMDtcbiAgICAgIHJpZ2h0OiAwO1xuICAgIH1cbiAgICAuYWxwaGEtY2hlY2tib2FyZCB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB0b3A6IDA7XG4gICAgICBib3R0b206IDA7XG4gICAgICBsZWZ0OiAwO1xuICAgICAgcmlnaHQ6IDA7XG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIH1cbiAgICAuYWxwaGEtZ3JhZGllbnQge1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgdG9wOiAwO1xuICAgICAgYm90dG9tOiAwO1xuICAgICAgbGVmdDogMDtcbiAgICAgIHJpZ2h0OiAwO1xuICAgIH1cbiAgICAuYWxwaGEtY29udGFpbmVyIHtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgIG1hcmdpbjogMCAzcHg7XG4gICAgfVxuICAgIC5hbHBoYS1wb2ludGVyIHtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB9XG4gICAgLmFscGhhLXNsaWRlciB7XG4gICAgICB3aWR0aDogNHB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogMXB4O1xuICAgICAgaGVpZ2h0OiA4cHg7XG4gICAgICBib3gtc2hhZG93OiAwIDAgMnB4IHJnYmEoMCwgMCwgMCwgLjYpO1xuICAgICAgYmFja2dyb3VuZDogI2ZmZjtcbiAgICAgIG1hcmdpbi10b3A6IDFweDtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMnB4KTtcbiAgICB9LFxuICBgLFxuICBdLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG59KVxuZXhwb3J0IGNsYXNzIEFscGhhQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgaHNsOiBIU0xBO1xuICBASW5wdXQoKSByZ2I6IFJHQkE7XG4gIEBJbnB1dCgpIHBvaW50ZXI6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG4gIEBJbnB1dCgpIHNoYWRvdzogc3RyaW5nO1xuICBASW5wdXQoKSByYWRpdXM6IHN0cmluZztcbiAgQElucHV0KCkgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcgfCAndmVydGljYWwnID0gJ2hvcml6b250YWwnO1xuICBAT3V0cHV0KCkgb25DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgZ3JhZGllbnQ6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG4gIHBvaW50ZXJMZWZ0OiBudW1iZXI7XG4gIHBvaW50ZXJUb3A6IG51bWJlcjtcblxuICBuZ09uQ2hhbmdlcygpIHtcbiAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgIHRoaXMucG9pbnRlckxlZnQgPSAwO1xuICAgICAgdGhpcy5wb2ludGVyVG9wID0gdGhpcy5yZ2IuYSAqIDEwMDtcbiAgICAgIHRoaXMuZ3JhZGllbnQgPSB7XG4gICAgICAgIGJhY2tncm91bmQ6IGBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCByZ2JhKCR7dGhpcy5yZ2Iucn0sJHtcbiAgICAgICAgICB0aGlzLnJnYi5nXG4gICAgICAgIH0sJHt0aGlzLnJnYi5ifSwgMCkgMCUsXG4gICAgICAgICAgcmdiYSgke3RoaXMucmdiLnJ9LCR7dGhpcy5yZ2IuZ30sJHt0aGlzLnJnYi5ifSwgMSkgMTAwJSlgLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ncmFkaWVudCA9IHtcbiAgICAgICAgYmFja2dyb3VuZDogYGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgcmdiYSgke3RoaXMucmdiLnJ9LCR7XG4gICAgICAgICAgdGhpcy5yZ2IuZ1xuICAgICAgICB9LCR7dGhpcy5yZ2IuYn0sIDApIDAlLFxuICAgICAgICAgIHJnYmEoJHt0aGlzLnJnYi5yfSwke3RoaXMucmdiLmd9LCR7dGhpcy5yZ2IuYn0sIDEpIDEwMCUpYCxcbiAgICAgIH07XG4gICAgICB0aGlzLnBvaW50ZXJMZWZ0ID0gdGhpcy5yZ2IuYSAqIDEwMDtcbiAgICB9XG4gIH1cbiAgaGFuZGxlQ2hhbmdlKHsgdG9wLCBsZWZ0LCBjb250YWluZXJIZWlnaHQsIGNvbnRhaW5lcldpZHRoLCAkZXZlbnQgfSkge1xuICAgIGxldCBkYXRhO1xuICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgbGV0IGE7XG4gICAgICBpZiAodG9wIDwgMCkge1xuICAgICAgICBhID0gMDtcbiAgICAgIH0gZWxzZSBpZiAodG9wID4gY29udGFpbmVySGVpZ2h0KSB7XG4gICAgICAgIGEgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYSA9IE1hdGgucm91bmQodG9wICogMTAwIC8gY29udGFpbmVySGVpZ2h0KSAvIDEwMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaHNsLmEgIT09IGEpIHtcbiAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICBoOiB0aGlzLmhzbC5oLFxuICAgICAgICAgIHM6IHRoaXMuaHNsLnMsXG4gICAgICAgICAgbDogdGhpcy5oc2wubCxcbiAgICAgICAgICBhLFxuICAgICAgICAgIHNvdXJjZTogJ3JnYicsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBhO1xuICAgICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICAgIGEgPSAwO1xuICAgICAgfSBlbHNlIGlmIChsZWZ0ID4gY29udGFpbmVyV2lkdGgpIHtcbiAgICAgICAgYSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhID0gTWF0aC5yb3VuZChsZWZ0ICogMTAwIC8gY29udGFpbmVyV2lkdGgpIC8gMTAwO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5oc2wuYSAhPT0gYSkge1xuICAgICAgICBkYXRhID0ge1xuICAgICAgICAgIGg6IHRoaXMuaHNsLmgsXG4gICAgICAgICAgczogdGhpcy5oc2wucyxcbiAgICAgICAgICBsOiB0aGlzLmhzbC5sLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgc291cmNlOiAncmdiJyxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5vbkNoYW5nZS5lbWl0KHsgZGF0YSwgJGV2ZW50IH0pO1xuICB9XG59XG5cbkBOZ01vZHVsZSh7XG4gIGRlY2xhcmF0aW9uczogW0FscGhhQ29tcG9uZW50XSxcbiAgZXhwb3J0czogW0FscGhhQ29tcG9uZW50XSxcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2hlY2tib2FyZE1vZHVsZSwgQ29vcmRpbmF0ZXNNb2R1bGVdLFxufSlcbmV4cG9ydCBjbGFzcyBBbHBoYU1vZHVsZSB7fVxuIiwiaW1wb3J0ICogYXMgX3Rpbnljb2xvciBmcm9tICd0aW55Y29sb3IyJztcblxuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuL2NvbG9yLmludGVyZmFjZXMnO1xuXG5jb25zdCB0aW55Y29sb3IgPSBfdGlueWNvbG9yO1xuXG5leHBvcnQgZnVuY3Rpb24gc2ltcGxlQ2hlY2tGb3JWYWxpZENvbG9yKGRhdGEpIHtcbiAgY29uc3Qga2V5c1RvQ2hlY2sgPSBbJ3InLCAnZycsICdiJywgJ2EnLCAnaCcsICdzJywgJ2wnLCAndiddO1xuICBsZXQgY2hlY2tlZCA9IDA7XG4gIGxldCBwYXNzZWQgPSAwO1xuICBrZXlzVG9DaGVjay5mb3JFYWNoKGxldHRlciA9PiB7XG4gICAgaWYgKCFkYXRhW2xldHRlcl0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2hlY2tlZCArPSAxO1xuICAgIGlmICghaXNOYU4oZGF0YVtsZXR0ZXJdKSkge1xuICAgICAgcGFzc2VkICs9IDE7XG4gICAgfVxuICAgIGlmIChsZXR0ZXIgPT09ICdzJyB8fCBsZXR0ZXIgPT09ICdsJykge1xuICAgICAgY29uc3QgcGVyY2VudFBhdHQgPSAvXlxcZCslJC87XG4gICAgICBpZiAocGVyY2VudFBhdHQudGVzdChkYXRhW2xldHRlcl0pKSB7XG4gICAgICAgIHBhc3NlZCArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjaGVja2VkID09PSBwYXNzZWQgPyBkYXRhIDogZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1N0YXRlKGRhdGEsIG9sZEh1ZT86IG51bWJlcik6IENvbG9yIHtcbiAgY29uc3QgY29sb3IgPSBkYXRhLmhleCA/IHRpbnljb2xvcihkYXRhLmhleCkgOiB0aW55Y29sb3IoZGF0YSk7XG4gIGNvbnN0IGhzbCA9IGNvbG9yLnRvSHNsKCk7XG4gIGNvbnN0IGhzdiA9IGNvbG9yLnRvSHN2KCk7XG4gIGNvbnN0IHJnYiA9IGNvbG9yLnRvUmdiKCk7XG4gIGNvbnN0IGhleCA9IGNvbG9yLnRvSGV4KCk7XG4gIGlmIChoc2wucyA9PT0gMCkge1xuICAgIGhzbC5oID0gb2xkSHVlIHx8IDA7XG4gICAgaHN2LmggPSBvbGRIdWUgfHwgMDtcbiAgfVxuICBjb25zdCB0cmFuc3BhcmVudCA9IGhleCA9PT0gJzAwMDAwMCcgJiYgcmdiLmEgPT09IDA7XG5cbiAgcmV0dXJuIHtcbiAgICBoc2wsXG4gICAgaGV4OiB0cmFuc3BhcmVudCA/ICd0cmFuc3BhcmVudCcgOiBgIyR7aGV4fWAsXG4gICAgcmdiLFxuICAgIGhzdixcbiAgICBvbGRIdWU6IGRhdGEuaCB8fCBvbGRIdWUgfHwgaHNsLmgsXG4gICAgc291cmNlOiBkYXRhLnNvdXJjZSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRIZXgoaGV4OiBzdHJpbmcpIHtcbiAgcmV0dXJuIHRpbnljb2xvcihoZXgpLmlzVmFsaWQoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRyYXN0aW5nQ29sb3IoZGF0YSkge1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm4gJyNmZmYnO1xuICB9XG4gIGNvbnN0IGNvbCA9IHRvU3RhdGUoZGF0YSk7XG4gIGlmIChjb2wuaGV4ID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgcmV0dXJuICdyZ2JhKDAsMCwwLDAuNCknO1xuICB9XG4gIGNvbnN0IHlpcSA9IChjb2wucmdiLnIgKiAyOTkgKyBjb2wucmdiLmcgKiA1ODcgKyBjb2wucmdiLmIgKiAxMTQpIC8gMTAwMDtcbiAgcmV0dXJuIHlpcSA+PSAxMjggPyAnIzAwMCcgOiAnI2ZmZic7XG59XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBOZ01vZHVsZSxcbiAgT25DaGFuZ2VzLFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUsICBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgc2ltcGxlQ2hlY2tGb3JWYWxpZENvbG9yLCB0b1N0YXRlIH0gZnJvbSAnLi9oZWxwZXJzL2NvbG9yJztcbmltcG9ydCB7IENvbG9yLCBIU0xBLCBIU1ZBLCBSR0JBIH0gZnJvbSAnLi9oZWxwZXJzL2NvbG9yLmludGVyZmFjZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbG9yRXZlbnQge1xuICAkZXZlbnQ6IEV2ZW50O1xuICBjb2xvcjogQ29sb3I7XG59XG5cbkBDb21wb25lbnQoe1xuICAvLyBjcmVhdGUgc2VsZXRvciBiYXNlIGZvciB0ZXN0IG92ZXJyaWRlIHByb3BlcnR5XG4gIHNlbGVjdG9yOiAnY29sb3Itd3JhcCcsXG4gIHRlbXBsYXRlOiBgYCxcbn0pXG5leHBvcnQgY2xhc3MgQ29sb3JXcmFwIGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gIEBJbnB1dCgpIGNsYXNzTmFtZSA9ICcnO1xuICBASW5wdXQoKSBjb2xvcjogSFNMQSA9IHtcbiAgICBoOiAyNTAsXG4gICAgczogMC41LFxuICAgIGw6IDAuMixcbiAgICBhOiAxLFxuICB9O1xuICBAT3V0cHV0KCkgb25DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPENvbG9yRXZlbnQ+KCk7XG4gIEBPdXRwdXQoKSBvbkNoYW5nZUNvbXBsZXRlID0gbmV3IEV2ZW50RW1pdHRlcjxDb2xvckV2ZW50PigpO1xuICBAT3V0cHV0KCkgb25Td2F0Y2hIb3ZlciA9IG5ldyBFdmVudEVtaXR0ZXI8Q29sb3JFdmVudD4oKTtcbiAgb2xkSHVlOiBudW1iZXI7XG4gIGhzbDogSFNMQTtcbiAgaHN2OiBIU1ZBO1xuICByZ2I6IFJHQkE7XG4gIGhleDogc3RyaW5nO1xuICBzb3VyY2U6IHN0cmluZztcbiAgY3VycmVudENvbG9yOiBzdHJpbmc7XG4gIGNoYW5nZXM6IFN1YnNjcmlwdGlvbjtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLmNoYW5nZXMgPSB0aGlzLm9uQ2hhbmdlLnBpcGUoXG4gICAgICAgIGRlYm91bmNlVGltZSgxMDApLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSh4ID0+IHRoaXMub25DaGFuZ2VDb21wbGV0ZS5lbWl0KHgpKTtcbiAgICB0aGlzLnNldFN0YXRlKHRvU3RhdGUodGhpcy5jb2xvciwgMCkpO1xuICAgIHRoaXMuY3VycmVudENvbG9yID0gdGhpcy5oZXg7XG4gIH1cbiAgbmdPbkNoYW5nZXMoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh0b1N0YXRlKHRoaXMuY29sb3IsIHRoaXMub2xkSHVlKSk7XG4gIH1cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5jaGFuZ2VzLnVuc3Vic2NyaWJlKCk7XG4gIH1cbiAgc2V0U3RhdGUoZGF0YSkge1xuICAgIHRoaXMub2xkSHVlID0gZGF0YS5vbGRIdWU7XG4gICAgdGhpcy5oc2wgPSBkYXRhLmhzbDtcbiAgICB0aGlzLmhzdiA9IGRhdGEuaHN2O1xuICAgIHRoaXMucmdiID0gZGF0YS5yZ2I7XG4gICAgdGhpcy5oZXggPSBkYXRhLmhleDtcbiAgICB0aGlzLnNvdXJjZSA9IGRhdGEuc291cmNlO1xuICAgIHRoaXMuYWZ0ZXJWYWxpZENoYW5nZSgpO1xuICB9XG4gIGhhbmRsZUNoYW5nZShkYXRhLCAkZXZlbnQpIHtcbiAgICBjb25zdCBpc1ZhbGlkQ29sb3IgPSBzaW1wbGVDaGVja0ZvclZhbGlkQ29sb3IoZGF0YSk7XG4gICAgaWYgKGlzVmFsaWRDb2xvcikge1xuICAgICAgY29uc3QgY29sb3IgPSB0b1N0YXRlKGRhdGEsIGRhdGEuaCB8fCB0aGlzLm9sZEh1ZSk7XG4gICAgICB0aGlzLnNldFN0YXRlKGNvbG9yKTtcbiAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7IGNvbG9yLCAkZXZlbnQgfSk7XG4gICAgICB0aGlzLmFmdGVyVmFsaWRDaGFuZ2UoKTtcbiAgICB9XG4gIH1cbiAgLyoqIGhvb2sgZm9yIGNvbXBvbmVudHMgYWZ0ZXIgYSBjb21wbGV0ZSBjaGFuZ2UgKi9cbiAgYWZ0ZXJWYWxpZENoYW5nZSgpIHt9XG5cbiAgaGFuZGxlU3dhdGNoSG92ZXIoZGF0YSwgJGV2ZW50KSB7XG4gICAgY29uc3QgaXNWYWxpZENvbG9yID0gc2ltcGxlQ2hlY2tGb3JWYWxpZENvbG9yKGRhdGEpO1xuICAgIGlmIChpc1ZhbGlkQ29sb3IpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gdG9TdGF0ZShkYXRhLCBkYXRhLmggfHwgdGhpcy5vbGRIdWUpO1xuICAgICAgdGhpcy5zZXRTdGF0ZShjb2xvcik7XG4gICAgICB0aGlzLm9uU3dhdGNoSG92ZXIuZW1pdCh7IGNvbG9yLCAkZXZlbnQgfSk7XG4gICAgfVxuICB9XG59XG5cbkBOZ01vZHVsZSh7XG4gIGRlY2xhcmF0aW9uczogW0NvbG9yV3JhcF0sXG4gIGV4cG9ydHM6IFtDb2xvcldyYXBdLFxuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ29sb3JXcmFwTW9kdWxlIHt9XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgTmdNb2R1bGUsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE91dHB1dCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IGZyb21FdmVudCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2NvbG9yLWVkaXRhYmxlLWlucHV0JyxcbiAgdGVtcGxhdGU6IGBcbiAgPGRpdiBjbGFzcz1cIndyYXBcIiBbbmdTdHlsZV09XCJ3cmFwU3R5bGVcIj5cbiAgICA8aW5wdXQgW25nU3R5bGVdPVwiaW5wdXRTdHlsZVwiIHNwZWxsQ2hlY2s9XCJmYWxzZVwiXG4gICAgICBbdmFsdWVdPVwiY3VycmVudFZhbHVlXCIgW3BsYWNlaG9sZGVyXT1cInBsYWNlaG9sZGVyXCJcbiAgICAgIChrZXlkb3duKT1cImhhbmRsZUtleWRvd24oJGV2ZW50KVwiIChrZXl1cCk9XCJoYW5kbGVLZXl1cCgkZXZlbnQpXCJcbiAgICAgIChmb2N1cyk9XCJoYW5kbGVGb2N1cygkZXZlbnQpXCIgKGZvY3Vzb3V0KT1cImhhbmRsZUZvY3VzT3V0KCRldmVudClcIiAvPlxuICAgIDxzcGFuICpuZ0lmPVwibGFiZWxcIiBbbmdTdHlsZV09XCJsYWJlbFN0eWxlXCIgKG1vdXNlZG93bik9XCJoYW5kbGVNb3VzZWRvd24oJGV2ZW50KVwiPlxuICAgICAge3sgbGFiZWwgfX1cbiAgICA8L3NwYW4+XG4gIDwvZGl2PlxuICBgLFxuICBzdHlsZXM6IFtcbiAgICBgXG4gICAgOmhvc3Qge1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICB9XG4gICAgLndyYXAge1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIH1cbiAgYCxcbiAgXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIEVkaXRhYmxlSW5wdXRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcbiAgQElucHV0KCkgc3R5bGU6IHtcbiAgICB3cmFwOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICAgIGlucHV0OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICAgIGxhYmVsOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICB9O1xuICBASW5wdXQoKSBsYWJlbDogc3RyaW5nO1xuICBASW5wdXQoKSB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyO1xuICBASW5wdXQoKSBhcnJvd09mZnNldDogbnVtYmVyO1xuICBASW5wdXQoKSBkcmFnTGFiZWw6IGJvb2xlYW47XG4gIEBJbnB1dCgpIGRyYWdNYXg6IG51bWJlcjtcbiAgQElucHV0KCkgcGxhY2Vob2xkZXIgPSAnJztcbiAgQE91dHB1dCgpIG9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBjdXJyZW50VmFsdWU6IHN0cmluZyB8IG51bWJlcjtcbiAgYmx1clZhbHVlOiBzdHJpbmc7XG4gIHdyYXBTdHlsZTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgaW5wdXRTdHlsZTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgbGFiZWxTdHlsZTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgZm9jdXMgPSBmYWxzZTtcbiAgbW91c2Vtb3ZlOiBTdWJzY3JpcHRpb247XG4gIG1vdXNldXA6IFN1YnNjcmlwdGlvbjtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLndyYXBTdHlsZSA9IHRoaXMuc3R5bGUgJiYgdGhpcy5zdHlsZS53cmFwID8gdGhpcy5zdHlsZS53cmFwIDoge307XG4gICAgdGhpcy5pbnB1dFN0eWxlID0gdGhpcy5zdHlsZSAmJiB0aGlzLnN0eWxlLmlucHV0ID8gdGhpcy5zdHlsZS5pbnB1dCA6IHt9O1xuICAgIHRoaXMubGFiZWxTdHlsZSA9IHRoaXMuc3R5bGUgJiYgdGhpcy5zdHlsZS5sYWJlbCA/IHRoaXMuc3R5bGUubGFiZWwgOiB7fTtcbiAgICBpZiAodGhpcy5kcmFnTGFiZWwpIHtcbiAgICAgIHRoaXMubGFiZWxTdHlsZS5jdXJzb3IgPSAnZXctcmVzaXplJztcbiAgICB9XG4gIH1cbiAgaGFuZGxlRm9jdXMoJGV2ZW50KSB7XG4gICAgdGhpcy5mb2N1cyA9IHRydWU7XG4gIH1cbiAgaGFuZGxlRm9jdXNPdXQoJGV2ZW50KSB7XG4gICAgdGhpcy5mb2N1cyA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudFZhbHVlID0gdGhpcy5ibHVyVmFsdWU7XG4gIH1cbiAgaGFuZGxlS2V5ZG93bigkZXZlbnQpIHtcbiAgICAvLyBJbiBjYXNlIGBlLnRhcmdldC52YWx1ZWAgaXMgYSBwZXJjZW50YWdlIHJlbW92ZSB0aGUgYCVgIGNoYXJhY3RlclxuICAgIC8vIGFuZCB1cGRhdGUgYWNjb3JkaW5nbHkgd2l0aCBhIHBlcmNlbnRhZ2VcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2FzZXNhbmRiZXJnL3JlYWN0LWNvbG9yL2lzc3Vlcy8zODNcbiAgICBjb25zdCBzdHJpbmdWYWx1ZSA9IFN0cmluZygkZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICBjb25zdCBpc1BlcmNlbnRhZ2UgPSBzdHJpbmdWYWx1ZS5pbmRleE9mKCclJykgPiAtMTtcbiAgICBjb25zdCBudW1iZXIgPSBOdW1iZXIoc3RyaW5nVmFsdWUucmVwbGFjZSgvJS9nLCAnJykpO1xuICAgIGlmICghaXNOYU4obnVtYmVyKSkge1xuICAgICAgY29uc3QgYW1vdW50ID0gdGhpcy5hcnJvd09mZnNldCB8fCAxO1xuXG4gICAgICAvLyBVcFxuICAgICAgaWYgKCRldmVudC5rZXlDb2RlID09PSAzOCkge1xuICAgICAgICBpZiAodGhpcy5sYWJlbCkge1xuICAgICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7XG4gICAgICAgICAgICBkYXRhOiB7IFt0aGlzLmxhYmVsXTogbnVtYmVyICsgYW1vdW50IH0sXG4gICAgICAgICAgICAkZXZlbnQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkNoYW5nZS5lbWl0KHsgZGF0YTogbnVtYmVyICsgYW1vdW50LCAkZXZlbnQgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQZXJjZW50YWdlKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBgJHtudW1iZXIgKyBhbW91bnR9JWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBudW1iZXIgKyBhbW91bnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRG93blxuICAgICAgaWYgKCRldmVudC5rZXlDb2RlID09PSA0MCkge1xuICAgICAgICBpZiAodGhpcy5sYWJlbCkge1xuICAgICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7XG4gICAgICAgICAgICBkYXRhOiB7IFt0aGlzLmxhYmVsXTogbnVtYmVyIC0gYW1vdW50IH0sXG4gICAgICAgICAgICAkZXZlbnQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkNoYW5nZS5lbWl0KHsgZGF0YTogbnVtYmVyIC0gYW1vdW50LCAkZXZlbnQgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQZXJjZW50YWdlKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBgJHtudW1iZXIgLSBhbW91bnR9JWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBudW1iZXIgLSBhbW91bnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFuZGxlS2V5dXAoJGV2ZW50KSB7XG4gICAgaWYgKCRldmVudC5rZXlDb2RlID09PSA0MCB8fCAkZXZlbnQua2V5Q29kZSA9PT0gMzgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubGFiZWwpIHtcbiAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7XG4gICAgICAgIGRhdGE6IHsgW3RoaXMubGFiZWxdOiAkZXZlbnQudGFyZ2V0LnZhbHVlIH0sXG4gICAgICAgICRldmVudCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoeyBkYXRhOiAkZXZlbnQudGFyZ2V0LnZhbHVlLCAkZXZlbnQgfSk7XG4gICAgfVxuICB9XG4gIG5nT25DaGFuZ2VzKCkge1xuICAgIGlmICghdGhpcy5mb2N1cykge1xuICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBTdHJpbmcodGhpcy52YWx1ZSkudG9VcHBlckNhc2UoKTtcbiAgICAgIHRoaXMuYmx1clZhbHVlID0gU3RyaW5nKHRoaXMudmFsdWUpLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmx1clZhbHVlID0gU3RyaW5nKHRoaXMudmFsdWUpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICB9XG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgfVxuICBzdWJzY3JpYmUoKSB7XG4gICAgdGhpcy5tb3VzZW1vdmUgPSBmcm9tRXZlbnQoZG9jdW1lbnQsICdtb3VzZW1vdmUnKS5zdWJzY3JpYmUoKGV2OiBFdmVudCkgPT5cbiAgICAgIHRoaXMuaGFuZGxlRHJhZyhldiksXG4gICAgKTtcbiAgICB0aGlzLm1vdXNldXAgPSBmcm9tRXZlbnQoZG9jdW1lbnQsICdtb3VzZXVwJykuc3Vic2NyaWJlKCgpID0+XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlKCksXG4gICAgKTtcbiAgfVxuICB1bnN1YnNjcmliZSgpIHtcbiAgICBpZiAodGhpcy5tb3VzZW1vdmUpIHtcbiAgICAgIHRoaXMubW91c2Vtb3ZlLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1vdXNldXApIHtcbiAgICAgIHRoaXMubW91c2V1cC51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVNb3VzZWRvd24oJGV2ZW50OiBFdmVudCkge1xuICAgIGlmICh0aGlzLmRyYWdMYWJlbCkge1xuICAgICAgJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLmhhbmRsZURyYWcoJGV2ZW50KTtcbiAgICAgIHRoaXMuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG4gIGhhbmRsZURyYWcoJGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZHJhZ0xhYmVsKSB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IE1hdGgucm91bmQodGhpcy52YWx1ZSArICRldmVudC5tb3ZlbWVudFgpO1xuICAgICAgaWYgKG5ld1ZhbHVlID49IDAgJiYgbmV3VmFsdWUgPD0gdGhpcy5kcmFnTWF4KSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh7IGRhdGE6IHsgW3RoaXMubGFiZWxdOiBuZXdWYWx1ZSB9LCAkZXZlbnQgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbkBOZ01vZHVsZSh7XG4gIGRlY2xhcmF0aW9uczogW0VkaXRhYmxlSW5wdXRDb21wb25lbnRdLFxuICBleHBvcnRzOiBbRWRpdGFibGVJbnB1dENvbXBvbmVudF0sXG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxufSlcbmV4cG9ydCBjbGFzcyBFZGl0YWJsZUlucHV0TW9kdWxlIHt9XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgTmdNb2R1bGUsXG4gIE9uQ2hhbmdlcyxcbiAgT3V0cHV0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ29vcmRpbmF0ZXNNb2R1bGUgfSBmcm9tICcuL2Nvb3JkaW5hdGVzLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBIU0xBLCBIU0xBc291cmNlIH0gZnJvbSAnLi9oZWxwZXJzL2NvbG9yLmludGVyZmFjZXMnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjb2xvci1odWUnLFxuICB0ZW1wbGF0ZTogYFxuICA8ZGl2IGNsYXNzPVwiY29sb3ItaHVlIGNvbG9yLWh1ZS17e2RpcmVjdGlvbn19XCIgW3N0eWxlLmJvcmRlci1yYWRpdXMucHhdPVwicmFkaXVzXCIgW3N0eWxlLmJveC1zaGFkb3ddPVwic2hhZG93XCI+XG4gICAgPGRpdiBuZ3gtY29sb3ItY29vcmRpbmF0ZXMgKGNvb3JkaW5hdGVzQ2hhbmdlKT1cImhhbmRsZUNoYW5nZSgkZXZlbnQpXCIgY2xhc3M9XCJjb2xvci1odWUtY29udGFpbmVyXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY29sb3ItaHVlLXBvaW50ZXJcIiBbc3R5bGUubGVmdF09XCJsZWZ0XCIgW3N0eWxlLnRvcF09XCJ0b3BcIiAqbmdJZj1cIiFoaWRlUG9pbnRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29sb3ItaHVlLXNsaWRlclwiIFtuZ1N0eWxlXT1cInBvaW50ZXJcIj48L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbiAgYCxcbiAgc3R5bGVzOiBbXG4gICAgYFxuICAgIC5jb2xvci1odWUge1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgdG9wOiAwO1xuICAgICAgYm90dG9tOiAwO1xuICAgICAgbGVmdDogMDtcbiAgICAgIHJpZ2h0OiAwO1xuICAgIH1cbiAgICAuY29sb3ItaHVlLWNvbnRhaW5lciB7XG4gICAgICBtYXJnaW46IDAgMnB4O1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cbiAgICAuY29sb3ItaHVlLXBvaW50ZXIge1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIH1cbiAgICAuY29sb3ItaHVlLXNsaWRlciB7XG4gICAgICBtYXJnaW4tdG9wOiAxcHg7XG4gICAgICB3aWR0aDogNHB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogMXB4O1xuICAgICAgaGVpZ2h0OiA4cHg7XG4gICAgICBib3gtc2hhZG93OiAwIDAgMnB4IHJnYmEoMCwgMCwgMCwgLjYpO1xuICAgICAgYmFja2dyb3VuZDogI2ZmZjtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMnB4KTtcbiAgICB9XG4gICAgLmNvbG9yLWh1ZS1ob3Jpem9udGFsIHtcbiAgICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgI2YwMCAwJSwgI2ZmMCAxNyUsICMwZjBcbiAgICAgICAgMzMlLCAjMGZmIDUwJSwgIzAwZiA2NyUsICNmMGYgODMlLCAjZjAwIDEwMCUpO1xuICAgIH1cbiAgICAuY29sb3ItaHVlLXZlcnRpY2FsIHtcbiAgICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byB0b3AsICNmMDAgMCUsICNmZjAgMTclLCAjMGYwIDMzJSxcbiAgICAgICAgIzBmZiA1MCUsICMwMGYgNjclLCAjZjBmIDgzJSwgI2YwMCAxMDAlKTtcbiAgICB9XG4gIGAsXG4gIF0sXG4gIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgSHVlQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgaHNsOiBIU0xBO1xuICBASW5wdXQoKSBwb2ludGVyOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICBASW5wdXQoKSByYWRpdXM6IG51bWJlcjtcbiAgQElucHV0KCkgc2hhZG93OiBzdHJpbmc7XG4gIEBJbnB1dCgpIGhpZGVQb2ludGVyID0gZmFsc2U7XG4gIEBJbnB1dCgpIGRpcmVjdGlvbjogJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJyA9ICdob3Jpem9udGFsJztcbiAgQE91dHB1dCgpIG9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjx7IGRhdGE6IEhTTEFzb3VyY2U7ICRldmVudDogRXZlbnQgfT4oKTtcbiAgbGVmdCA9ICcwcHgnO1xuICB0b3AgPSAnJztcblxuICBuZ09uQ2hhbmdlcygpIHtcbiAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgdGhpcy5sZWZ0ID0gYCR7dGhpcy5oc2wuaCAqIDEwMCAvIDM2MH0lYDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50b3AgPSBgJHstKHRoaXMuaHNsLmggKiAxMDAgLyAzNjApICsgMTAwfSVgO1xuICAgIH1cbiAgfVxuICBoYW5kbGVDaGFuZ2UoeyB0b3AsIGxlZnQsIGNvbnRhaW5lckhlaWdodCwgY29udGFpbmVyV2lkdGgsICRldmVudCB9KSB7XG4gICAgbGV0IGRhdGE6IEhTTEFzb3VyY2U7XG4gICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICBsZXQgaDtcbiAgICAgIGlmICh0b3AgPCAwKSB7XG4gICAgICAgIGggPSAzNTk7XG4gICAgICB9IGVsc2UgaWYgKHRvcCA+IGNvbnRhaW5lckhlaWdodCkge1xuICAgICAgICBoID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBlcmNlbnQgPSAtKHRvcCAqIDEwMCAvIGNvbnRhaW5lckhlaWdodCkgKyAxMDA7XG4gICAgICAgIGggPSAzNjAgKiBwZXJjZW50IC8gMTAwO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5oc2wuaCAhPT0gaCkge1xuICAgICAgICBkYXRhID0ge1xuICAgICAgICAgIGgsXG4gICAgICAgICAgczogdGhpcy5oc2wucyxcbiAgICAgICAgICBsOiB0aGlzLmhzbC5sLFxuICAgICAgICAgIGE6IHRoaXMuaHNsLmEsXG4gICAgICAgICAgc291cmNlOiAncmdiJyxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGg7XG4gICAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgICAgaCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGxlZnQgPiBjb250YWluZXJXaWR0aCkge1xuICAgICAgICBoID0gMzU5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcGVyY2VudCA9IGxlZnQgKiAxMDAgLyBjb250YWluZXJXaWR0aDtcbiAgICAgICAgaCA9IDM2MCAqIHBlcmNlbnQgLyAxMDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhzbC5oICE9PSBoKSB7XG4gICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgaCxcbiAgICAgICAgICBzOiB0aGlzLmhzbC5zLFxuICAgICAgICAgIGw6IHRoaXMuaHNsLmwsXG4gICAgICAgICAgYTogdGhpcy5oc2wuYSxcbiAgICAgICAgICBzb3VyY2U6ICdyZ2InLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLm9uQ2hhbmdlLmVtaXQoeyBkYXRhLCAkZXZlbnQgfSk7XG4gIH1cbn1cblxuQE5nTW9kdWxlKHtcbiAgZGVjbGFyYXRpb25zOiBbSHVlQ29tcG9uZW50XSxcbiAgZXhwb3J0czogW0h1ZUNvbXBvbmVudF0sXG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENvb3JkaW5hdGVzTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgSHVlTW9kdWxlIHt9XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgSW5wdXQsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2NvbG9yLXJhaXNlZCcsXG4gIHRlbXBsYXRlOiBgXG4gIDxkaXYgY2xhc3M9XCJyYWlzZWQtd3JhcFwiPlxuICAgIDxkaXYgY2xhc3M9XCJyYWlzZWQtYmcgekRlcHRoLXt7ekRlcHRofX1cIiBbc3R5bGUuYmFja2dyb3VuZF09XCJiYWNrZ3JvdW5kXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInJhaXNlZC1jb250ZW50XCI+XG4gICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuICBgLFxuICBzdHlsZXM6IFtgXG4gICAgLnJhaXNlZC13cmFwIHtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICB9XG4gICAgLnJhaXNlZC1iZyB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB0b3A6IDBweDtcbiAgICAgIHJpZ2h0OiAwcHg7XG4gICAgICBib3R0b206IDBweDtcbiAgICAgIGxlZnQ6IDBweDtcbiAgICB9XG4gICAgLnJhaXNlZC1jb250ZW50IHtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB9XG4gICAgLnpEZXB0aC0wIHtcbiAgICAgIGJveC1zaGFkb3c6IG5vbmU7XG4gICAgfVxuICAgIC56RGVwdGgtMSB7XG4gICAgICBib3gtc2hhZG93OiAwIDJweCAxMHB4IHJnYmEoMCwwLDAsLjEyKSwgMCAycHggNXB4IHJnYmEoMCwwLDAsLjE2KTtcbiAgICB9XG4gICAgLnpEZXB0aC0yIHtcbiAgICAgIGJveC1zaGFkb3c6IDAgNnB4IDIwcHggcmdiYSgwLDAsMCwuMTkpLCAwIDhweCAxN3B4IHJnYmEoMCwwLDAsLjIpO1xuICAgIH1cbiAgICAuekRlcHRoLTMge1xuICAgICAgYm94LXNoYWRvdzogMCAxN3B4IDUwcHggcmdiYSgwLDAsMCwuMTkpLCAwIDEycHggMTVweCByZ2JhKDAsMCwwLC4yNCk7XG4gICAgfVxuICAgIC56RGVwdGgtNCB7XG4gICAgICBib3gtc2hhZG93OiAwIDI1cHggNTVweCByZ2JhKDAsMCwwLC4yMSksIDAgMTZweCAyOHB4IHJnYmEoMCwwLDAsLjIyKTtcbiAgICB9XG4gICAgLnpEZXB0aC01IHtcbiAgICAgIGJveC1zaGFkb3c6IDAgNDBweCA3N3B4IHJnYmEoMCwwLDAsLjIyKSwgMCAyN3B4IDI0cHggcmdiYSgwLDAsMCwuMik7XG4gICAgfVxuICBgXSxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBSYWlzZWRDb21wb25lbnQge1xuICBASW5wdXQoKSB6RGVwdGg6IDAgfCAxIHwgMiB8IDMgfCA0IHwgNSAgPSAxO1xuICBASW5wdXQoKSByYWRpdXMgPSAxO1xuICBASW5wdXQoKSBiYWNrZ3JvdW5kID0gJyNmZmYnO1xufVxuXG5ATmdNb2R1bGUoe1xuICBkZWNsYXJhdGlvbnM6IFtSYWlzZWRDb21wb25lbnRdLFxuICBleHBvcnRzOiBbUmFpc2VkQ29tcG9uZW50XSxcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXG59KVxuZXhwb3J0IGNsYXNzIFJhaXNlZE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBOZ01vZHVsZSxcbiAgT25DaGFuZ2VzLFxuICBPdXRwdXQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5cbmltcG9ydCB7IENvb3JkaW5hdGVzTW9kdWxlIH0gZnJvbSAnLi9jb29yZGluYXRlcy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSFNMQSwgSFNWQSwgSFNWQXNvdXJjZSB9IGZyb20gJy4vaGVscGVycy9jb2xvci5pbnRlcmZhY2VzJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY29sb3Itc2F0dXJhdGlvbicsXG4gIHRlbXBsYXRlOiBgXG4gIDxkaXYgY2xhc3M9XCJjb2xvci1zYXR1cmF0aW9uXCIgbmd4LWNvbG9yLWNvb3JkaW5hdGVzIChjb29yZGluYXRlc0NoYW5nZSk9XCJoYW5kbGVDaGFuZ2UoJGV2ZW50KVwiIFtzdHlsZS5iYWNrZ3JvdW5kXT1cImJhY2tncm91bmRcIj5cbiAgICA8ZGl2IGNsYXNzPVwic2F0dXJhdGlvbi13aGl0ZVwiPlxuICAgICAgPGRpdiBjbGFzcz1cInNhdHVyYXRpb24tYmxhY2tcIj48L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJzYXR1cmF0aW9uLXBvaW50ZXJcIiBbbmdTdHlsZV09XCJwb2ludGVyXCIgW3N0eWxlLnRvcF09XCJwb2ludGVyVG9wXCIgW3N0eWxlLmxlZnRdPVwicG9pbnRlckxlZnRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNhdHVyYXRpb24tY2lyY2xlXCIgW25nU3R5bGVdPVwiY2lyY2xlXCI+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4gIGAsXG4gIHN0eWxlczogW1xuICAgIGBcbiAgICAuc2F0dXJhdGlvbi13aGl0ZSB7XG4gICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsICNmZmYsIHJnYmEoMjU1LDI1NSwyNTUsMCkpO1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgdG9wOiAwO1xuICAgICAgYm90dG9tOiAwO1xuICAgICAgbGVmdDogMDtcbiAgICAgIHJpZ2h0OiAwO1xuICAgIH1cbiAgICAuc2F0dXJhdGlvbi1ibGFjayB7XG4gICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gdG9wLCAjMDAwLCByZ2JhKDAsMCwwLDApKTtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHRvcDogMDtcbiAgICAgIGJvdHRvbTogMDtcbiAgICAgIGxlZnQ6IDA7XG4gICAgICByaWdodDogMDtcbiAgICB9XG4gICAgLmNvbG9yLXNhdHVyYXRpb24ge1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgdG9wOiAwO1xuICAgICAgYm90dG9tOiAwO1xuICAgICAgbGVmdDogMDtcbiAgICAgIHJpZ2h0OiAwO1xuICAgIH1cbiAgICAuc2F0dXJhdGlvbi1wb2ludGVyIHtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGN1cnNvcjogZGVmYXVsdDtcbiAgICB9XG4gICAgLnNhdHVyYXRpb24tY2lyY2xlIHtcbiAgICAgIHdpZHRoOiA0cHg7XG4gICAgICBoZWlnaHQ6IDRweDtcbiAgICAgIGJveC1zaGFkb3c6IDAgMCAwIDEuNXB4ICNmZmYsIGluc2V0IDAgMCAxcHggMXB4IHJnYmEoMCwwLDAsLjMpLCAwIDAgMXB4IDJweCByZ2JhKDAsMCwwLC40KTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgIGN1cnNvcjogaGFuZDtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC0ycHgsIC00cHgpO1xuICAgIH1cbiAgYCxcbiAgXSxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBTYXR1cmF0aW9uQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgaHNsOiBIU0xBO1xuICBASW5wdXQoKSBoc3Y6IEhTVkE7XG4gIEBJbnB1dCgpIHJhZGl1czogbnVtYmVyO1xuICBASW5wdXQoKSBwb2ludGVyOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICBASW5wdXQoKSBjaXJjbGU6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH07XG4gIEBPdXRwdXQoKSBvbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8eyBkYXRhOiBIU1ZBc291cmNlOyAkZXZlbnQ6IEV2ZW50IH0+KCk7XG4gIGJhY2tncm91bmQ6IHN0cmluZztcbiAgcG9pbnRlclRvcDogc3RyaW5nO1xuICBwb2ludGVyTGVmdDogc3RyaW5nO1xuXG4gIG5nT25DaGFuZ2VzKCkge1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IGBoc2woJHt0aGlzLmhzbC5ofSwgMTAwJSwgNTAlKWA7XG4gICAgdGhpcy5wb2ludGVyVG9wID0gLSh0aGlzLmhzdi52ICogMTAwKSArIDEgKyAxMDAgKyAnJSc7XG4gICAgdGhpcy5wb2ludGVyTGVmdCA9IHRoaXMuaHN2LnMgKiAxMDAgKyAnJSc7XG4gIH1cbiAgaGFuZGxlQ2hhbmdlKHsgdG9wLCBsZWZ0LCBjb250YWluZXJIZWlnaHQsIGNvbnRhaW5lcldpZHRoLCAkZXZlbnQgfSkge1xuICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgbGVmdCA9IDA7XG4gICAgfSBlbHNlIGlmIChsZWZ0ID4gY29udGFpbmVyV2lkdGgpIHtcbiAgICAgIGxlZnQgPSBjb250YWluZXJXaWR0aDtcbiAgICB9IGVsc2UgaWYgKHRvcCA8IDApIHtcbiAgICAgIHRvcCA9IDA7XG4gICAgfSBlbHNlIGlmICh0b3AgPiBjb250YWluZXJIZWlnaHQpIHtcbiAgICAgIHRvcCA9IGNvbnRhaW5lckhlaWdodDtcbiAgICB9XG5cbiAgICBjb25zdCBzYXR1cmF0aW9uID0gbGVmdCAvIGNvbnRhaW5lcldpZHRoO1xuICAgIGxldCBicmlnaHQgPSAtKHRvcCAvIGNvbnRhaW5lckhlaWdodCkgKyAxO1xuICAgIGJyaWdodCA9IGJyaWdodCA+IDAgPyBicmlnaHQgOiAwO1xuICAgIGJyaWdodCA9IGJyaWdodCA+IDEgPyAxIDogYnJpZ2h0O1xuXG4gICAgY29uc3QgZGF0YTogSFNWQXNvdXJjZSA9IHtcbiAgICAgIGg6IHRoaXMuaHNsLmgsXG4gICAgICBzOiBzYXR1cmF0aW9uLFxuICAgICAgdjogYnJpZ2h0LFxuICAgICAgYTogdGhpcy5oc2wuYSxcbiAgICAgIHNvdXJjZTogJ2hzdmEnLFxuICAgIH07XG4gICAgdGhpcy5vbkNoYW5nZS5lbWl0KHsgZGF0YSwgJGV2ZW50IH0pO1xuICB9XG59XG5cbkBOZ01vZHVsZSh7XG4gIGRlY2xhcmF0aW9uczogW1NhdHVyYXRpb25Db21wb25lbnRdLFxuICBleHBvcnRzOiBbU2F0dXJhdGlvbkNvbXBvbmVudF0sXG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENvb3JkaW5hdGVzTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgU2F0dXJhdGlvbk1vZHVsZSB7fVxuIiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE5nTW9kdWxlLFxuICBPbkluaXQsXG4gIE91dHB1dCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENoZWNrYm9hcmRNb2R1bGUgfSBmcm9tICcuL2NoZWNrYm9hcmQuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY29sb3Itc3dhdGNoJyxcbiAgdGVtcGxhdGU6IGBcbiAgPGRpdiBjbGFzcz1cInN3YXRjaFwiXG4gICAgW25nU3R5bGVdPVwiYWN0aXZlU3R5bGVzKClcIiBbYXR0ci50aXRsZV09XCJjb2xvclwiXG4gICAgKGNsaWNrKT1cImhhbmRsZUNsaWNrKGNvbG9yLCAkZXZlbnQpXCJcbiAgICAoa2V5ZG93bi5lbnRlcik9XCJoYW5kbGVDbGljayhjb2xvciwgJGV2ZW50KVwiXG4gICAgKGZvY3VzKT1cImhhbmRsZUZvY3VzKClcIlxuICAgIChmb2N1c291dCk9XCJoYW5kbGVGb2N1c091dCgpXCJcbiAgICAobW91c2VvdmVyKT1cImhhbmRsZUhvdmVyKGNvbG9yLCAkZXZlbnQpXCJcbiAgICB0YWJpbmRleD1cIjBcIlxuICA+XG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDxjb2xvci1jaGVja2JvYXJkXG4gICAgICAqbmdJZj1cImNvbG9yID09PSAndHJhbnNwYXJlbnQnXCJcbiAgICAgIGJveFNoYWRvdz1cImluc2V0IDAgMCAwIDFweCByZ2JhKDAsMCwwLDAuMSlcIlxuICAgID48L2NvbG9yLWNoZWNrYm9hcmQ+XG4gIDwvZGl2PlxuICBgLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG59KVxuZXhwb3J0IGNsYXNzIFN3YXRjaENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIEBJbnB1dCgpIGNvbG9yO1xuICBASW5wdXQoKSBzdHlsZTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuICBASW5wdXQoKSBmb2N1c1N0eWxlOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gIEBJbnB1dCgpIGZvY3VzOiBib29sZWFuO1xuICBAT3V0cHV0KCkgb25DbGljayA9IG5ldyBFdmVudEVtaXR0ZXI8eyBoZXg6IHN0cmluZywgJGV2ZW50OiBFdmVudH0+KCk7XG4gIEBPdXRwdXQoKSBvbkhvdmVyID0gbmV3IEV2ZW50RW1pdHRlcjx7IGhleDogc3RyaW5nLCAkZXZlbnQ6IEV2ZW50fT4oKTtcbiAgZGl2U3R5bGVzOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSA9IHt9O1xuICBmb2N1c1N0eWxlczoge1trZXk6IHN0cmluZ106IHN0cmluZ30gPSB7fTtcbiAgaW5Gb2N1cyA9IGZhbHNlO1xuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuZGl2U3R5bGVzID0ge1xuICAgICAgYmFja2dyb3VuZDogdGhpcy5jb2xvcixcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgICAuLi50aGlzLnN0eWxlLFxuICAgIH07XG4gICAgdGhpcy5mb2N1c1N0eWxlcyA9IHtcbiAgICAgIC4uLnRoaXMuZGl2U3R5bGVzLFxuICAgICAgLi4udGhpcy5mb2N1c1N0eWxlLFxuICAgIH07XG4gIH1cbiAgYWN0aXZlU3R5bGVzKCkge1xuICAgIHJldHVybiB0aGlzLmZvY3VzIHx8IHRoaXMuaW5Gb2N1cyA/IHRoaXMuZm9jdXNTdHlsZXMgOiB0aGlzLmRpdlN0eWxlcztcbiAgfVxuICBoYW5kbGVGb2N1c091dCgpIHtcbiAgICB0aGlzLmluRm9jdXMgPSBmYWxzZTtcbiAgfVxuICBoYW5kbGVGb2N1cygpIHtcbiAgICB0aGlzLmluRm9jdXMgPSB0cnVlO1xuICB9XG4gIGhhbmRsZUhvdmVyKGhleCwgJGV2ZW50KSB7XG4gICAgdGhpcy5vbkhvdmVyLmVtaXQoeyBoZXgsICRldmVudCB9KTtcbiAgfVxuICBoYW5kbGVDbGljayhoZXgsICRldmVudCkge1xuICAgIHRoaXMub25DbGljay5lbWl0KHsgaGV4LCAkZXZlbnQgfSk7XG4gIH1cbn1cblxuQE5nTW9kdWxlKHtcbiAgZGVjbGFyYXRpb25zOiBbU3dhdGNoQ29tcG9uZW50XSxcbiAgZXhwb3J0czogW1N3YXRjaENvbXBvbmVudF0sXG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENoZWNrYm9hcmRNb2R1bGVdLFxufSlcbmV4cG9ydCBjbGFzcyBTd2F0Y2hNb2R1bGUge31cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztNQUFNLGVBQWUsR0FBNEIsRUFBRTs7Ozs7OztBQUVuRCxTQUFnQixNQUFNLENBQUMsRUFBVSxFQUFFLEVBQVUsRUFBRSxJQUFZO0lBQ3pELElBQUksT0FBTyxRQUFRLEtBQUssV0FBVyxFQUFFO1FBQ25DLE9BQU8sSUFBSSxDQUFDO0tBQ2I7O1VBQ0ssTUFBTSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDO0lBQy9DLE1BQU0sQ0FBQyxLQUFLLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQztJQUN4QixNQUFNLENBQUMsTUFBTSxHQUFHLElBQUksR0FBRyxDQUFDLENBQUM7O1VBQ25CLEdBQUcsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQztJQUNuQyxJQUFJLENBQUMsR0FBRyxFQUFFO1FBQ1IsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUNELEdBQUcsQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDO0lBQ25CLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNoRCxHQUFHLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztJQUNuQixHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQy9CLEdBQUcsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzFCLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDL0IsT0FBTyxNQUFNLENBQUMsU0FBUyxFQUFFLENB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