/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { Directive, ElementRef, HostListener, NgModule, Output, } from '@angular/core';
import { Subject } from 'rxjs';
import { distinctUntilChanged } from 'rxjs/operators';
export class CoordinatesDirective {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
        this.coordinatesChange = new Subject();
        this.mousechange = new Subject();
        this.mouseListening = false;
    }
    /**
     * @param {?} $event
     * @param {?} x
     * @param {?} y
     * @param {?=} isTouch
     * @return {?}
     */
    mousemove($event, x, y, isTouch = false) {
        if (this.mouseListening) {
            $event.preventDefault();
            this.mousechange.next({ $event, x, y, isTouch });
        }
    }
    /**
     * @return {?}
     */
    mouseup() {
        this.mouseListening = false;
    }
    /**
     * @param {?} $event
     * @param {?} x
     * @param {?} y
     * @param {?=} isTouch
     * @return {?}
     */
    mousedown($event, x, y, isTouch = false) {
        $event.preventDefault();
        this.mouseListening = true;
        this.mousechange.next({ $event, x, y, isTouch });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.sub = this.mousechange
            .pipe(
        // limit times it is updated for the same area
        distinctUntilChanged((p, q) => p.x === q.x && p.y === q.y))
            .subscribe(n => this.handleChange(n.x, n.y, n.$event, n.isTouch));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.sub.unsubscribe();
    }
    /**
     * @param {?} x
     * @param {?} y
     * @param {?} $event
     * @param {?} isTouch
     * @return {?}
     */
    handleChange(x, y, $event, isTouch) {
        /** @type {?} */
        const containerWidth = this.el.nativeElement.clientWidth;
        /** @type {?} */
        const containerHeight = this.el.nativeElement.clientHeight;
        /** @type {?} */
        const left = x -
            (this.el.nativeElement.getBoundingClientRect().left + window.pageXOffset);
        /** @type {?} */
        let top = y - this.el.nativeElement.getBoundingClientRect().top;
        if (!isTouch) {
            top = top - window.pageYOffset;
        }
        this.coordinatesChange.next({
            x,
            y,
            top,
            left,
            containerWidth,
            containerHeight,
            $event,
        });
    }
}
CoordinatesDirective.decorators = [
    { type: Directive, args: [{ selector: '[ngx-color-coordinates]' },] }
];
/** @nocollapse */
CoordinatesDirective.ctorParameters = () => [
    { type: ElementRef }
];
CoordinatesDirective.propDecorators = {
    coordinatesChange: [{ type: Output }],
    mousemove: [{ type: HostListener, args: ['window:mousemove', ['$event', '$event.pageX', '$event.pageY'],] }, { type: HostListener, args: ['window:touchmove', [
                    '$event',
                    '$event.touches[0].clientX',
                    '$event.touches[0].clientY',
                    'true',
                ],] }],
    mouseup: [{ type: HostListener, args: ['window:mouseup',] }, { type: HostListener, args: ['window:touchend',] }],
    mousedown: [{ type: HostListener, args: ['mousedown', ['$event', '$event.pageX', '$event.pageY'],] }, { type: HostListener, args: ['touchstart', [
                    '$event',
                    '$event.touches[0].clientX',
                    '$event.touches[0].clientY',
                    'true',
                ],] }]
};
if (false) {
    /** @type {?} */
    CoordinatesDirective.prototype.coordinatesChange;
    /** @type {?} */
    CoordinatesDirective.prototype.mousechange;
    /** @type {?} */
    CoordinatesDirective.prototype.mouseListening;
    /** @type {?} */
    CoordinatesDirective.prototype.sub;
    /** @type {?} */
    CoordinatesDirective.prototype.el;
}
export class CoordinatesModule {
}
CoordinatesModule.decorators = [
    { type: NgModule, args: [{
                declarations: [CoordinatesDirective],
                exports: [CoordinatesDirective],
            },] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29vcmRpbmF0ZXMuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWNvbG9yLyIsInNvdXJjZXMiOlsiY29vcmRpbmF0ZXMuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osUUFBUSxFQUdSLE1BQU0sR0FDUCxNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsT0FBTyxFQUFnQixNQUFNLE1BQU0sQ0FBQztBQUM3QyxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUd0RCxNQUFNLE9BQU8sb0JBQW9COzs7O0lBbUQvQixZQUFvQixFQUFjO1FBQWQsT0FBRSxHQUFGLEVBQUUsQ0FBWTtRQWpEbEMsc0JBQWlCLEdBQUcsSUFBSSxPQUFPLEVBUTNCLENBQUM7UUFDRyxnQkFBVyxHQUFHLElBQUksT0FBTyxFQUs3QixDQUFDO1FBRUcsbUJBQWMsR0FBRyxLQUFLLENBQUM7SUFpQ00sQ0FBQzs7Ozs7Ozs7SUF4QnRDLFNBQVMsQ0FBQyxNQUFhLEVBQUUsQ0FBUyxFQUFFLENBQVMsRUFBRSxPQUFPLEdBQUcsS0FBSztRQUM1RCxJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUU7WUFDdkIsTUFBTSxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQ3hCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztTQUNsRDtJQUNILENBQUM7Ozs7SUFHRCxPQUFPO1FBQ0wsSUFBSSxDQUFDLGNBQWMsR0FBRyxLQUFLLENBQUM7SUFDOUIsQ0FBQzs7Ozs7Ozs7SUFRRCxTQUFTLENBQUMsTUFBYSxFQUFFLENBQVMsRUFBRSxDQUFTLEVBQUUsT0FBTyxHQUFHLEtBQUs7UUFDNUQsTUFBTSxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ3hCLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDO1FBQzNCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztJQUNuRCxDQUFDOzs7O0lBSUQsUUFBUTtRQUNOLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLFdBQVc7YUFDeEIsSUFBSTtRQUNILDhDQUE4QztRQUM5QyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDM0Q7YUFDQSxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ3RFLENBQUM7Ozs7SUFFRCxXQUFXO1FBQ1QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUN6QixDQUFDOzs7Ozs7OztJQUVELFlBQVksQ0FBQyxDQUFTLEVBQUUsQ0FBUyxFQUFFLE1BQWEsRUFBRSxPQUFnQjs7Y0FDMUQsY0FBYyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLFdBQVc7O2NBQ2xELGVBQWUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxZQUFZOztjQUNwRCxJQUFJLEdBQ1IsQ0FBQztZQUNELENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQzs7WUFDdkUsR0FBRyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLEdBQUc7UUFFL0QsSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNaLEdBQUcsR0FBRyxHQUFHLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQztTQUNoQztRQUNELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUM7WUFDMUIsQ0FBQztZQUNELENBQUM7WUFDRCxHQUFHO1lBQ0gsSUFBSTtZQUNKLGNBQWM7WUFDZCxlQUFlO1lBQ2YsTUFBTTtTQUNQLENBQUMsQ0FBQztJQUNMLENBQUM7OztZQXZGRixTQUFTLFNBQUMsRUFBRSxRQUFRLEVBQUUseUJBQXlCLEVBQUU7Ozs7WUFYaEQsVUFBVTs7O2dDQWFULE1BQU07d0JBbUJOLFlBQVksU0FBQyxrQkFBa0IsRUFBRSxDQUFDLFFBQVEsRUFBRSxjQUFjLEVBQUUsY0FBYyxDQUFDLGNBQzNFLFlBQVksU0FBQyxrQkFBa0IsRUFBRTtvQkFDaEMsUUFBUTtvQkFDUiwyQkFBMkI7b0JBQzNCLDJCQUEyQjtvQkFDM0IsTUFBTTtpQkFDUDtzQkFPQSxZQUFZLFNBQUMsZ0JBQWdCLGNBQzdCLFlBQVksU0FBQyxpQkFBaUI7d0JBSTlCLFlBQVksU0FBQyxXQUFXLEVBQUUsQ0FBQyxRQUFRLEVBQUUsY0FBYyxFQUFFLGNBQWMsQ0FBQyxjQUNwRSxZQUFZLFNBQUMsWUFBWSxFQUFFO29CQUMxQixRQUFRO29CQUNSLDJCQUEyQjtvQkFDM0IsMkJBQTJCO29CQUMzQixNQUFNO2lCQUNQOzs7O0lBM0NELGlEQVNLOztJQUNMLDJDQUtLOztJQUVMLDhDQUErQjs7SUFDL0IsbUNBQTBCOztJQWdDZCxrQ0FBc0I7O0FBMENwQyxNQUFNLE9BQU8saUJBQWlCOzs7WUFKN0IsUUFBUSxTQUFDO2dCQUNSLFlBQVksRUFBRSxDQUFDLG9CQUFvQixDQUFDO2dCQUNwQyxPQUFPLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQzthQUNoQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgSG9zdExpc3RlbmVyLFxuICBOZ01vZHVsZSxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE91dHB1dCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tuZ3gtY29sb3ItY29vcmRpbmF0ZXNdJyB9KVxuZXhwb3J0IGNsYXNzIENvb3JkaW5hdGVzRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBAT3V0cHV0KClcbiAgY29vcmRpbmF0ZXNDaGFuZ2UgPSBuZXcgU3ViamVjdDx7XG4gICAgeDogbnVtYmVyO1xuICAgIHk6IG51bWJlcjtcbiAgICB0b3A6IG51bWJlcjtcbiAgICBsZWZ0OiBudW1iZXI7XG4gICAgY29udGFpbmVyV2lkdGg6IG51bWJlcjtcbiAgICBjb250YWluZXJIZWlnaHQ6IG51bWJlcjtcbiAgICAkZXZlbnQ6IGFueTtcbiAgfT4oKTtcbiAgcHJpdmF0ZSBtb3VzZWNoYW5nZSA9IG5ldyBTdWJqZWN0PHtcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xuICAgICRldmVudDogYW55O1xuICAgIGlzVG91Y2g6IGJvb2xlYW47XG4gIH0+KCk7XG5cbiAgcHJpdmF0ZSBtb3VzZUxpc3RlbmluZyA9IGZhbHNlO1xuICBwcml2YXRlIHN1YjogU3Vic2NyaXB0aW9uO1xuICBASG9zdExpc3RlbmVyKCd3aW5kb3c6bW91c2Vtb3ZlJywgWyckZXZlbnQnLCAnJGV2ZW50LnBhZ2VYJywgJyRldmVudC5wYWdlWSddKVxuICBASG9zdExpc3RlbmVyKCd3aW5kb3c6dG91Y2htb3ZlJywgW1xuICAgICckZXZlbnQnLFxuICAgICckZXZlbnQudG91Y2hlc1swXS5jbGllbnRYJyxcbiAgICAnJGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WScsXG4gICAgJ3RydWUnLFxuICBdKVxuICBtb3VzZW1vdmUoJGV2ZW50OiBFdmVudCwgeDogbnVtYmVyLCB5OiBudW1iZXIsIGlzVG91Y2ggPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLm1vdXNlTGlzdGVuaW5nKSB7XG4gICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMubW91c2VjaGFuZ2UubmV4dCh7ICRldmVudCwgeCwgeSwgaXNUb3VjaCB9KTtcbiAgICB9XG4gIH1cbiAgQEhvc3RMaXN0ZW5lcignd2luZG93Om1vdXNldXAnKVxuICBASG9zdExpc3RlbmVyKCd3aW5kb3c6dG91Y2hlbmQnKVxuICBtb3VzZXVwKCkge1xuICAgIHRoaXMubW91c2VMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgfVxuICBASG9zdExpc3RlbmVyKCdtb3VzZWRvd24nLCBbJyRldmVudCcsICckZXZlbnQucGFnZVgnLCAnJGV2ZW50LnBhZ2VZJ10pXG4gIEBIb3N0TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBbXG4gICAgJyRldmVudCcsXG4gICAgJyRldmVudC50b3VjaGVzWzBdLmNsaWVudFgnLFxuICAgICckZXZlbnQudG91Y2hlc1swXS5jbGllbnRZJyxcbiAgICAndHJ1ZScsXG4gIF0pXG4gIG1vdXNlZG93bigkZXZlbnQ6IEV2ZW50LCB4OiBudW1iZXIsIHk6IG51bWJlciwgaXNUb3VjaCA9IGZhbHNlKSB7XG4gICAgJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5tb3VzZUxpc3RlbmluZyA9IHRydWU7XG4gICAgdGhpcy5tb3VzZWNoYW5nZS5uZXh0KHsgJGV2ZW50LCB4LCB5LCBpc1RvdWNoIH0pO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlbDogRWxlbWVudFJlZikge31cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnN1YiA9IHRoaXMubW91c2VjaGFuZ2VcbiAgICAgIC5waXBlKFxuICAgICAgICAvLyBsaW1pdCB0aW1lcyBpdCBpcyB1cGRhdGVkIGZvciB0aGUgc2FtZSBhcmVhXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKChwLCBxKSA9PiBwLnggPT09IHEueCAmJiBwLnkgPT09IHEueSksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKG4gPT4gdGhpcy5oYW5kbGVDaGFuZ2Uobi54LCBuLnksIG4uJGV2ZW50LCBuLmlzVG91Y2gpKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3ViLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICBoYW5kbGVDaGFuZ2UoeDogbnVtYmVyLCB5OiBudW1iZXIsICRldmVudDogRXZlbnQsIGlzVG91Y2g6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBjb250YWluZXJXaWR0aCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICBjb25zdCBjb250YWluZXJIZWlnaHQgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgIGNvbnN0IGxlZnQgPVxuICAgICAgeCAtXG4gICAgICAodGhpcy5lbC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQpO1xuICAgIGxldCB0b3AgPSB5IC0gdGhpcy5lbC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcblxuICAgIGlmICghaXNUb3VjaCkge1xuICAgICAgdG9wID0gdG9wIC0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgIH1cbiAgICB0aGlzLmNvb3JkaW5hdGVzQ2hhbmdlLm5leHQoe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB0b3AsXG4gICAgICBsZWZ0LFxuICAgICAgY29udGFpbmVyV2lkdGgsXG4gICAgICBjb250YWluZXJIZWlnaHQsXG4gICAgICAkZXZlbnQsXG4gICAgfSk7XG4gIH1cbn1cblxuQE5nTW9kdWxlKHtcbiAgZGVjbGFyYXRpb25zOiBbQ29vcmRpbmF0ZXNEaXJlY3RpdmVdLFxuICBleHBvcnRzOiBbQ29vcmRpbmF0ZXNEaXJlY3RpdmVdLFxufSlcbmV4cG9ydCBjbGFzcyBDb29yZGluYXRlc01vZHVsZSB7fVxuIl19